

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <meta name="description" content="第三章 Java线程本章内容：  创建和运行线程 查看线程 线程 API 线程状态  3.1 创建和运行线程 每个程序一启动，都有一个主程序线程，称之为主线程。默认已经有一个主线程在运行了。  方法一，直接使用Thread12345678&#x2F;&#x2F; 创建线程对象Thread t &#x3D; new Thread() &amp;#123; 	public void run() &amp;#123; 	&#x2F;&#x2F; 要执行的任务 	&amp;#1">
<meta property="og:type" content="article">
<meta property="og:title" content="第三章 Java线程">
<meta property="og:url" content="http://example.com/2021/12/20/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="密鼬CyrptoSkunk">
<meta property="og:description" content="第三章 Java线程本章内容：  创建和运行线程 查看线程 线程 API 线程状态  3.1 创建和运行线程 每个程序一启动，都有一个主程序线程，称之为主线程。默认已经有一个主线程在运行了。  方法一，直接使用Thread12345678&#x2F;&#x2F; 创建线程对象Thread t &#x3D; new Thread() &amp;#123; 	public void run() &amp;#123; 	&#x2F;&#x2F; 要执行的任务 	&amp;#1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211218171132351.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211218170423475.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211218170523199.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211218170708785.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211218170923368.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211218172101398.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211218172237257.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211218172311299.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211218224550413.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211218230238918.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211218230301086.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211218230316126.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211219120326852.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211219120527024.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211220155929525.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211220164128203.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/20200307093417-638644.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/20200307093352-614933.png">
<meta property="og:image" content="http://image.cryptomartin.top/img/image-20211220194112708.png">
<meta property="article:published_time" content="2021-12-20T11:50:45.000Z">
<meta property="article:modified_time" content="2021-12-20T11:54:29.776Z">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="高并发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://image.cryptomartin.top/img/image-20211218171132351.png">
  
  <title>第三章 Java线程 - 密鼬CyrptoSkunk</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>密鼬cryptoskunk</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="第三章 Java线程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-20 19:50" pubdate>
        2021年12月20日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      41 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">第三章 Java线程</h1>
            
            <div class="markdown-body">
              <h1 id="第三章-Java线程"><a href="#第三章-Java线程" class="headerlink" title="第三章 Java线程"></a>第三章 Java线程</h1><p><strong>本章内容</strong>：</p>
<ul>
<li>创建和运行线程</li>
<li>查看线程</li>
<li>线程 API</li>
<li>线程状态</li>
</ul>
<h2 id="3-1-创建和运行线程"><a href="#3-1-创建和运行线程" class="headerlink" title="3.1 创建和运行线程"></a>3.1 创建和运行线程</h2><blockquote>
<p>每个程序一启动，都有一个主程序线程，称之为主线程。默认已经有一个主线程在运行了。</p>
</blockquote>
<h3 id="方法一，直接使用Thread"><a href="#方法一，直接使用Thread" class="headerlink" title="方法一，直接使用Thread"></a>方法一，直接使用Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程对象</span><br>Thread t = <span class="hljs-keyword">new</span> Thread() &#123;<br> 	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br> 	<span class="hljs-comment">// 要执行的任务</span><br> 	&#125;<br>&#125;;<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//构造方法的参数是给线程指定名字，推荐</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//setName给线程指定名称</span><br>        <span class="hljs-comment">//t.setName(&quot;t1&quot;);</span><br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>        log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:42:09 [main] c.Test1 - running<br>16:42:09 [t1] c.Test1 - running<br></code></pre></td></tr></table></figure>



<h3 id="方法二，使用Runnable配合Thread"><a href="#方法二，使用Runnable配合Thread" class="headerlink" title="方法二，使用Runnable配合Thread"></a>方法二，使用Runnable配合Thread</h3><p>把【线程】和【任务】（要执行的代码）分开</p>
<ul>
<li>Thread 代表线程</li>
<li>Runnable 可运行的任务（线程要执行的代码）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-comment">// 要执行的任务</span><br>	&#125;<br>&#125;;<br><span class="hljs-comment">// 创建线程对象，把runnable对象放入线程中</span><br>Thread t = <span class="hljs-keyword">new</span> Thread( runnable );<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建可运行的任务对象</span><br>        Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//创建线程对象,这边IDE提示：不建议显示创建线程，请使用线程池。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;t2&quot;</span>);<br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:54:14 [t2] c.Test2 - running<br></code></pre></td></tr></table></figure>

<p>Java8后可以使用lambda简化代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建可运行的任务对象</span><br>        Runnable runnable = () -&gt; log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>        <span class="hljs-comment">//创建线程对象,这边IDE提示：不建议显示创建线程，请使用线程池。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;t2&quot;</span>);<br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="***** 原理之 Thread 与 Runnable 的关系"></a>***** <strong>原理之</strong> <strong>Thread</strong> <strong>与</strong> <strong>Runnable</strong> 的关系</h3><blockquote>
<p>Test1是用了哪个run方法？</p>
</blockquote>
<p><img src="http://image.cryptomartin.top/img/image-20211218171132351.png" srcset="/img/loading.gif" lazyload alt="image-20211218171132351"></p>
<blockquote>
<p>方法1是重写了父类的run方法，以子类的run方法为准。</p>
</blockquote>
<hr>
<blockquote>
<p>Test2是用了哪个run方法？</p>
</blockquote>
<p><img src="http://image.cryptomartin.top/img/image-20211218170423475.png" srcset="/img/loading.gif" lazyload alt="image-20211218170423475"></p>
<p><img src="http://image.cryptomartin.top/img/image-20211218170523199.png" srcset="/img/loading.gif" lazyload alt="image-20211218170523199"></p>
<p><img src="http://image.cryptomartin.top/img/image-20211218170708785.png" srcset="/img/loading.gif" lazyload alt="image-20211218170708785"></p>
<p><img src="http://image.cryptomartin.top/img/image-20211218170923368.png" srcset="/img/loading.gif" lazyload alt="image-20211218170923368"></p>
<blockquote>
<p>如果有Runnable对象，Thread优先采用Runnable对象的run方法。</p>
</blockquote>
<p><strong>小结</strong></p>
<ul>
<li>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</li>
<li>用 Runnable 更容易与线程池等高级 API 配合</li>
<li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
</ul>
<blockquote>
<p>更推荐Runnable的方法！！！优先组合关系，不是继承关系。</p>
</blockquote>
<h3 id="方法三，FutureTask配置Thread"><a href="#方法三，FutureTask配置Thread" class="headerlink" title="方法三，FutureTask配置Thread"></a>方法三，FutureTask配置Thread</h3><p><img src="http://image.cryptomartin.top/img/image-20211218172101398.png" srcset="/img/loading.gif" lazyload alt="image-20211218172101398"></p>
<p><img src="http://image.cryptomartin.top/img/image-20211218172237257.png" srcset="/img/loading.gif" lazyload alt="image-20211218172237257"></p>
<p><img src="http://image.cryptomartin.top/img/image-20211218172311299.png" srcset="/img/loading.gif" lazyload alt="image-20211218172311299"></p>
<p>Future中的get方法可以返回任务执行的结果；Runnable是void没有返回结果。</p>
<hr>
<p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        FutureTask&lt;Integer&gt; task =<span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>                <span class="hljs-comment">//让当前线程睡眠1s</span><br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//FutureTask实现了Runnable接口，所以可以放入Thread。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(task,<span class="hljs-string">&quot;t1&quot;</span>);<br>        t.start();<br><br>        <span class="hljs-comment">//主线程阻塞，等待结果FutureTask结果返回；FutureTask实现了任务及异步结果的集合功能</span><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,task.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">17:32:24 [t1] c.Test2 - running...<br>17:32:26 [main] c.Test2 - 100<br></code></pre></td></tr></table></figure>



<h2 id="3-2-观察多个线程同时运行"><a href="#3-2-观察多个线程同时运行" class="headerlink" title="3.2 观察多个线程同时运行"></a>3.2 观察多个线程同时运行</h2><p>主要是理解</p>
<ul>
<li>交替执行</li>
<li>谁先谁后，不由我们控制</li>
</ul>
<h2 id="3-3-查看进程线程的方法"><a href="#3-3-查看进程线程的方法" class="headerlink" title="3.3 查看进程线程的方法"></a>3.3 查看进程线程的方法</h2><p><strong>windows</strong></p>
<ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li>
<li><code>tasklist</code> 查看进程</li>
<li><code>taskkill</code> 杀死进程</li>
</ul>
<p><strong>linux</strong></p>
<ul>
<li><code>ps -fe</code> 查看所有进程</li>
<li><code>ps -fT -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li>
<li><code>kill</code> 杀死进程</li>
<li><code>top</code> 按大写 H 切换是否显示线程</li>
<li><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li>
</ul>
<h2 id="3-4-原理之线程运行"><a href="#3-4-原理之线程运行" class="headerlink" title="3.4 * 原理之线程运行"></a>3.4 * 原理之线程运行</h2><h3 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h3><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p>
<p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</p>
<ul>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法，互不干扰</li>
</ul>
<p>线程运行原理-栈帧图解：</p>
<p><img src="http://image.cryptomartin.top/img/image-20211218224550413.png" srcset="/img/loading.gif" lazyload alt="image-20211218224550413"></p>
<h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p>
<ul>
<li>线程的 cpu 时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li>
</ul>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p>
<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Context Switch 频繁发生会影响性能</li>
</ul>
<h2 id="3-5-常见方法"><a href="#3-5-常见方法" class="headerlink" title="3.5 常见方法"></a>3.5 常见方法</h2><p><img src="http://image.cryptomartin.top/img/image-20211218230238918.png" srcset="/img/loading.gif" lazyload alt="image-20211218230238918"></p>
<p><img src="http://image.cryptomartin.top/img/image-20211218230301086.png" srcset="/img/loading.gif" lazyload alt="image-20211218230301086"></p>
<p><img src="http://image.cryptomartin.top/img/image-20211218230316126.png" srcset="/img/loading.gif" lazyload alt="image-20211218230316126"></p>
<h3 id="3-5-1-Start与run"><a href="#3-5-1-Start与run" class="headerlink" title="3.5.1 Start与run"></a>3.5.1 Start与run</h3><p><strong>调用run方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>            log.debug(<span class="hljs-string">&quot;t1 Thread is running...&quot;</span>);<br>        &#125;<br>    &#125;;<br>    t1.run();<br>    log.debug(<span class="hljs-string">&quot;main Thread is running...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>输出</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">23:16:48 [main] c.Test4 - t1 Thread is running...<br>23:16:48 [main] c.Test4 - main Thread is running...<br></code></pre></td></tr></table></figure>

<p>程序仍在 main 线程运行。</p>
<p><strong>调用start方法</strong></p>
<p>将上述代码中的<code>t1.run()</code>改为<code>t1.start()</code>，输出</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">23:21:01 [t1] c.Test4 - t1 Thread is running...<br>23:21:01 [main] c.Test4 - main Thread is running...<br></code></pre></td></tr></table></figure>

<p>程序在 t1 线程运行。</p>
<p><strong>小结</strong></p>
<ul>
<li>直接调用 <code>run()</code> 是在主线程中执行了 <code>run()</code>，没有启动新的线程</li>
<li>使用 <code>start()</code> 是启动新的线程，通过新的线程间接执行 <code>run()</code>方法 中的代码</li>
</ul>
<h3 id="3-5-2-sleep与yield"><a href="#3-5-2-sleep与yield" class="headerlink" title="3.5.2 sleep与yield"></a>3.5.2 sleep与yield</h3><p><strong>sleep</strong></p>
<ol>
<li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 <code>InterruptedException</code>异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】</li>
<li>睡眠结束后的线程未必会立刻得到执行(需要分配到cpu时间片)</li>
<li>建议用 TimeUnit 的 <code>sleep()</code> 代替 Thread 的 <code>sleep()</code>来获得更好的可读性</li>
</ol>
<p>ps:<code>sleep()</code>方法写在哪个线程中，那个线程就进入睡眠。</p>
<p><strong>yield(让出的意思)</strong></p>
<ol>
<li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</li>
<li>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)</li>
</ol>
<p>阻塞状态与就绪状态线程区别：</p>
<ul>
<li>就绪状态，还是有机会被任务调度器调度的，任务调度器会分时间片给就绪状态的线程。</li>
<li>阻塞状态，任务调度器不会分时间片给阻塞状态的线程，只有睡眠时间到了，醒过来后，任务调度器才会时间片分给醒来的线程。</li>
</ul>
<p> <strong>小结</strong></p>
<p>yield让出cpu使用权，但是cpu可能会再分配时间片给该线程；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片</p>
<h3 id="3-5-3-线程优先级"><a href="#3-5-3-线程优先级" class="headerlink" title="3.5.3 线程优先级"></a>3.5.3 线程优先级</h3><ul>
<li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li>
<li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li>
</ul>
<h3 id="3-3-4-join"><a href="#3-3-4-join" class="headerlink" title="3.3.4 join"></a>3.3.4 join</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test10&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        test1();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>            r = <span class="hljs-number">10</span>;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">//t1.join();</span><br>        log.debug(<span class="hljs-string">&quot;结果为:&#123;&#125;&quot;</span>, r);<br>        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>输出</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">11:58:20 [main] c.Test10 - 开始<br>11:58:20 [t1] c.Test10 - 开始<br>11:58:20 [main] c.Test10 - 结果为:0<br>11:58:20 [main] c.Test10 - 结束<br>11:58:21 [t1] c.Test10 - 结束<br></code></pre></td></tr></table></figure>

<p>分析</p>
<ul>
<li>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 <code>r=10</code></li>
<li>而主线程一开始就要打印 r 的结果，所以只能打印出 <code>r=0</code></li>
</ul>
<p>解决方法</p>
<ul>
<li>用 <code>sleep()</code> 行不行？为什么？</li>
<li>用 <code>join()</code>，加在 <code>t1.start()</code> 之后即可</li>
</ul>
<p><img src="http://image.cryptomartin.top/img/image-20211219120326852.png" srcset="/img/loading.gif" lazyload alt="image-20211219120326852"></p>
<p>以<code>调用方角度</code>来讲，如果:</p>
<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<p><img src="http://image.cryptomartin.top/img/image-20211219120527024.png" srcset="/img/loading.gif" lazyload alt="image-20211219120527024"></p>
<blockquote>
<p><code>t1 thread</code>调用<code>join()</code>方法之后，<code>main thread</code>跟<code>t1 thread</code>是同步的，<code>main thread</code>必须等待<code>t1 thread</code>执行完成后，才能继续执行。</p>
</blockquote>
<p><strong>join()方法等待多个线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r1 = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r2 = <span class="hljs-number">0</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       test2();<br>   &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>           sleep(<span class="hljs-number">1</span>);<br>           r1 = <span class="hljs-number">10</span>;<br>       &#125;);<br>       Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>           sleep(<span class="hljs-number">2</span>);<br>           r2 = <span class="hljs-number">20</span>;<br>       &#125;);<br>       t1.start();<br>       t2.start();<br>       <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>       log.debug(<span class="hljs-string">&quot;join begin&quot;</span>);<br>       t2.join();<br>       log.debug(<span class="hljs-string">&quot;t2 join end&quot;</span>);<br>       t1.join();<br>       log.debug(<span class="hljs-string">&quot;t1 join end&quot;</span>);<br>       <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>       log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);<br>   &#125;<br></code></pre></td></tr></table></figure>

<p><code>输出</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">14:16:35 [main] c.TestJoin - join begin<br>14:16:37 [main] c.TestJoin - t2 join end<br>14:16:37 [main] c.TestJoin - t1 join end<br>14:16:37 [main] c.TestJoin - r1: 10 r2: 20 cost: 2003<br></code></pre></td></tr></table></figure>

<p>分析如下</p>
<ul>
<li>第一个 join：等待 t1 时, t2 并没有停止, 而在运行</li>
<li>第二个 join：1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s</li>
</ul>
<p>如果颠倒两个 join 呢？</p>
<p>答：结果还是一样</p>
<p><strong>join(long n):最多等待n毫秒</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r1 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r2 = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    test3();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        sleep(<span class="hljs-number">2</span>);<br>        r1 = <span class="hljs-number">10</span>;<br>    &#125;);<br><br>    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>    t1.start();<br><br>    <span class="hljs-comment">// 线程执行结束会导致 join 结束</span><br>    log.debug(<span class="hljs-string">&quot;join begin&quot;</span>);<br>    t1.join(<span class="hljs-number">1500</span>);<br>    <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>    log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>输出</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">14:24:33 [main] c.TestJoin - join begin<br>14:24:35 [main] c.TestJoin - r1: 0 r2: 0 cost: 1508<br></code></pre></td></tr></table></figure>

<blockquote>
<p>没等够时间，就按时间到期结束；如果等待时间还没万，但线程结束了，就不再等待了。</p>
</blockquote>
<h3 id="3-5-5-interrupt-方法详解"><a href="#3-5-5-interrupt-方法详解" class="headerlink" title="3.5.5 interrupt 方法详解"></a>3.5.5 interrupt 方法详解</h3><h4 id="interrupt可以打断-sleep，wait，join-的线程"><a href="#interrupt可以打断-sleep，wait，join-的线程" class="headerlink" title="interrupt可以打断 sleep，wait，join 的线程"></a>interrupt可以打断 sleep，wait，join 的线程</h4><p>阻塞</p>
<p>打断 sleep 的线程, 会清空打断状态，以 sleep 为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>	Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>		sleep(<span class="hljs-number">1</span>);<br>	&#125;<br>	, <span class="hljs-string">&quot;t1&quot;</span>);<br>	t1.start();<br>	sleep(<span class="hljs-number">0.5</span>);<br>	t1.interrupt();<br>	log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>输出</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">java.lang.InterruptedException: sleep interrupted<br> at java.lang.Thread.sleep(Native Method)<br> at java.lang.Thread.sleep(Thread.java:340)<br> at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)<br> at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)<br> at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)<br> at java.lang.Thread.run(Thread.java:745)<br>21:18:10.374 [main] c.TestInterrupt - 打断状态: false<br></code></pre></td></tr></table></figure>



<p><strong>打断正常运行的线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>	Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>		<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>			Thread current = Thread.currentThread();<br>			Boolean interrupted = current.isInterrupted();<br>			<span class="hljs-keyword">if</span>(interrupted) &#123;<br>				log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>	, <span class="hljs-string">&quot;t2&quot;</span>);<br>	t2.start();<br>	sleep(<span class="hljs-number">0.5</span>);<br>	t2.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>输出</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">20:57:37.964 [t2] c.TestInterrupt - 打断状态: true<br></code></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li><p>如果位于特殊的阻塞状态，比如调用wait()、wait(long)或者join()或者sleep()等方法，中断标志位将会被清除，并且收到一个InterruptedException</p>
</li>
<li><p>打断正常运行的线程，调用<code>interrupt()</code>方法只是给线程打上一个中断标志位，并不会马上打断该线程。我们可以根据中断标志位来做一些操作。</p>
</li>
</ul>
<h4 id="【模式】模式之两阶段终止"><a href="#【模式】模式之两阶段终止" class="headerlink" title="【模式】模式之两阶段终止"></a>【模式】模式之两阶段终止</h4><p><code>Two Phase Termination</code><br>是在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。</p>
<p><strong>1.错误思路</strong></p>
<ul>
<li>使用线程对象的 stop() 方法停止线程<ul>
<li>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，<br>其它线程将永远无法获取锁</li>
</ul>
</li>
<li>使用 System.exit(int) 方法停止线程<ul>
<li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li>
</ul>
</li>
</ul>
<p><strong>2.两阶段终止模式</strong></p>
<p><img src="http://image.cryptomartin.top/img/image-20211220155929525.png" srcset="/img/loading.gif" lazyload alt="image-20211220155929525"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        TwoPhaseTermination tpt = <span class="hljs-keyword">new</span> TwoPhaseTermination();<br>        tpt.start();<br><br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        tpt.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//监控类</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTermination</span> </span>&#123;<br>    <span class="hljs-comment">//创建监控线程，作为成员变量</span><br>    <span class="hljs-keyword">private</span> Thread monitor;<br><br>    <span class="hljs-comment">//开启监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">//不断执行</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-comment">//查看当前线程的中断标记</span><br>                Thread currentThread = Thread.currentThread();<br>                <span class="hljs-comment">//判断当前线程是否被打断</span><br>                <span class="hljs-keyword">if</span> (currentThread.isInterrupted()) &#123;<br>                    <span class="hljs-comment">//如果被打断</span><br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//如果当前线程没有被打断,睡眠1秒</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    <span class="hljs-comment">//没被打断，且没有异常；记录日志</span><br>                    log.debug(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                    <span class="hljs-comment">//在睡眠中被打断，会清除打断标记，打断标记此时为false;需要将中断标记置为真;重新设置打断标记为true</span><br>                    currentThread.interrupt();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//开启线程</span><br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">//停止监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>输出</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:25:32 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>16:25:33 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>16:25:34 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>java.lang.InterruptedException: sleep interrupted<br><span class="hljs-code">	at java.lang.Thread.sleep(Native Method)</span><br><span class="hljs-code">	at com.sunk.test.TwoPhaseTermination.lambda$start$0(Test3.java:41)</span><br><span class="hljs-code">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="hljs-code">16:25:35 [Thread-0] c.TwoPhaseTermination - 料理后事</span><br></code></pre></td></tr></table></figure>

<p><strong>isInterrupted()与interrupted()区别</strong></p>
<ul>
<li><code>isInterrupted()</code>：判断当前线程是否被打断；不会清除打断标记</li>
<li><code>interrupted()</code>:判断当前线程是否被打断；会清除打断标记，如果打断标记为<code>true</code>，调用此方法后，变为<code>false</code></li>
</ul>
<h4 id="interrupted打断park线程"><a href="#interrupted打断park线程" class="headerlink" title="interrupted打断park线程"></a>interrupted打断park线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test14&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test14</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        test3();<br>    &#125;<br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>            log.debug(<span class="hljs-string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());<br>            <span class="hljs-comment">//打断标记为true，park就失效了。</span><br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        sleep(<span class="hljs-number">0.5</span>);<br>        t1.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>输出</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:38:28 [t1] c.Test14 - park...<br>16:38:28 [t1] c.Test14 - unpark...<br>16:38:28 [t1] c.Test14 - 打断状态：true<br>16:38:28 [t1] c.Test14 - unpark...<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果打断标记已经是 true, 则 park 会失效</p>
</blockquote>
<h2 id="3-6-不推荐的方法"><a href="#3-6-不推荐的方法" class="headerlink" title="3.6 不推荐的方法"></a>3.6 不推荐的方法</h2><p><img src="http://image.cryptomartin.top/img/image-20211220164128203.png" srcset="/img/loading.gif" lazyload alt="image-20211220164128203"></p>
<h2 id="3-7-守护线程"><a href="#3-7-守护线程" class="headerlink" title="3.7 守护线程"></a>3.7 守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做<code>守护线程</code>，<strong>只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test15&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test15</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;t1线程结束&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-comment">//设置t1线程为守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束</span><br>        t1.setDaemon(<span class="hljs-keyword">true</span>);<br>        t1.start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;主线程结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>输出</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">19:06:21 [main] c.Test15 - 主线程结束<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<ul>
<li>垃圾回收器线程就是一种守护线程</li>
<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等<br>待它们处理完当前请求</li>
</ul>
</blockquote>
<h2 id="3-8-线程的五种状态"><a href="#3-8-线程的五种状态" class="headerlink" title="3.8 线程的五种状态"></a>3.8 线程的五种状态</h2><p>五种状态的划分主要是从操作系统的层面进行划分的</p>
<p><img src="http://image.cryptomartin.top/img/20200307093417-638644.png" srcset="/img/loading.gif" lazyload alt="1583507073055"></p>
<ol>
<li><p>初始状态，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联</p>
</li>
<li><p>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</p>
</li>
<li><p>运行状态，指线程获取了CPU时间片，正在运行</p>
<ul>
<li>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</li>
</ul>
</li>
<li><p>阻塞状态</p>
<ul>
<li><p>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】</p>
</li>
<li><p>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p>
</li>
<li><p>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</p>
</li>
</ul>
</li>
<li><p>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p>
</li>
</ol>
<h2 id="3-9-线程的六种状态"><a href="#3-9-线程的六种状态" class="headerlink" title="3.9 线程的六种状态"></a>3.9 线程的六种状态</h2><p>这是从 Java API 层面来描述的，我们主要研究的就是这种。状态转换详情图：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ec94ed32895f">地址</a><br>根据 Thread.State 枚举，分为六种状态 </p>
<p><img src="http://image.cryptomartin.top/img/20200307093352-614933.png" srcset="/img/loading.gif" lazyload alt="1583507709834"></p>
<ul>
<li>NEW 跟五种状态里的初始状态是一个意思</li>
<li> RUNNABLE 是当调用了 <code>start()</code> 方法之后的状态，注意，Java API 层面的 <code>RUNNABLE</code> 状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【io阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li>
<li><code>BLOCKED</code> ， <code>WAITING</code> ， <code>TIMED_WAITING</code> 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节<br> 详述</li>
</ul>
<h2 id="3-10-习题-统筹规划"><a href="#3-10-习题-统筹规划" class="headerlink" title="3.10 习题-统筹规划"></a>3.10 习题-统筹规划</h2><p><img src="http://image.cryptomartin.top/img/image-20211220194112708.png" srcset="/img/loading.gif" lazyload alt="image-20211220194112708"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test16&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test16</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;洗水壶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            log.debug(<span class="hljs-string">&quot;烧开水，花费15分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">15</span>);<br>        &#125;, <span class="hljs-string">&quot;老王&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;洗茶壶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            log.debug(<span class="hljs-string">&quot;洗茶杯，花费2分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>            log.debug(<span class="hljs-string">&quot;拿茶叶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//小王模拟泡茶，等待开水烧开。</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                t1.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;可以泡茶了！&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;小王&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>输出</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">19:38:37 [老王] c.Test16 - 洗水壶，花费1分钟<br>19:38:37 [小王] c.Test16 - 洗茶壶，花费1分钟<br>19:38:38 [老王] c.Test16 - 烧开水，花费15分钟<br>19:38:38 [小王] c.Test16 - 洗茶杯，花费2分钟<br>19:38:40 [小王] c.Test16 - 拿茶叶，花费1分钟<br>19:38:53 [小王] c.Test16 - 可以泡茶了！<br></code></pre></td></tr></table></figure>

<p>ps:秒代替分钟。</p>
<p>执行到<code>19:38:38 [老王] c.Test16 - 烧开水，花费15分钟</code>，会等待15秒，然后会执行<code>19:38:53 [小王] c.Test16 - 可以泡茶了！</code></p>
<h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><p>本章的重点在于掌握</p>
<ul>
<li><p>线程创建</p>
</li>
<li><p>线程重要 api，如 start，run，sleep，join，interrupt 等</p>
</li>
<li><p>线程状态</p>
</li>
<li><p>应用方面</p>
<ul>
<li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li>
<li>提高效率：并行计算，缩短运算时间</li>
<li>同步等待：join</li>
<li>统筹规划：合理使用线程，得到最优效果</li>
</ul>
</li>
<li><p>原理方面</p>
<ul>
<li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li>
<li>Thread 两种创建方式 的源码</li>
</ul>
</li>
<li><p>模式方面</p>
<ul>
<li>两阶段终止模式</li>
</ul>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发</a>
                    
                      <a class="hover-with-bg" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/16/Hexo%20%E5%A4%96%E9%93%BE%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/">
                        <span class="hidden-mobile">Hexo 七牛云外链图片无法显示</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
