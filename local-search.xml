<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>学习JVM引言</title>
    <link href="/2021/12/22/%E5%AD%A6%E4%B9%A0JVM%E5%BC%95%E8%A8%80/"/>
    <url>/2021/12/22/%E5%AD%A6%E4%B9%A0JVM%E5%BC%95%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="学习JVM引言"><a href="#学习JVM引言" class="headerlink" title="学习JVM引言"></a>学习JVM引言</h1><h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>Java Virtual Machine - java 程序的运行环境（java 二进制字节码的运行环境）</p><h3 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收功能</li><li>数组下标越界检查</li><li>多态</li></ul><h3 id="比较："><a href="#比较：" class="headerlink" title="比较："></a>比较：</h3><p>jvm jre jdk</p><p><img src="http://image.cryptomartin.top/img/image-20211222072056047.png" alt="image-20211222072056047"></p><p>JVM：屏蔽Java代码与底层的操作系统的差异</p><p>JRE：JVM基础上加上基础类库，就是JRE。基础类库是什么？jang.lang.*,集合类，线程类，日期类，IO类</p><p>JDK：JRE基础上加上编译工具，就是JDK。编译工具有javac，javap等</p><h2 id="学习JVM有什么用？"><a href="#学习JVM有什么用？" class="headerlink" title="学习JVM有什么用？"></a>学习JVM有什么用？</h2><ul><li>面试</li><li>理解底层原理的实现原理</li><li>中高级程序员的必备技能</li></ul><h2 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h2><p><img src="http://image.cryptomartin.top/img/image-20211222073020952.png" alt="image-20211222073020952"></p><blockquote><p><a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines">维基百科参考</a></p></blockquote><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="http://image.cryptomartin.top/img/image-20211222073238466.png" alt="image-20211222073238466"></p><blockquote><p><a href="https://www.javainterviewpoint.com/java-virtual-machine-architecture-in-java/">参考资料</a></p></blockquote><p>一个类从Java源代码编译为二进制字节码以后，经过类加载器，才能被加载到JVM中运行；</p><p>类都是放在<code>Method Area方法区</code>中，类将来创建的实例对象放在<code>Heap堆</code>中，而<code>Heap堆</code>里面的对象调用<code>方法</code>时,又会用到<code>JVM Stacks虚拟机栈</code>，<code>PC Register程序计数器</code>,<code>Native Method Stacks 本地方法栈</code>;</p><p><code>方法</code> 执行时，每行代码是由<code>执行引擎</code>中的<code>Interpret解释器</code>逐行进行一个执行；<code>方法里的热点代码</code>,即被频繁调用的代码，会由一个<code>JIT Compiler即时编译器</code>对<code>方法里的热点代码</code>做一个编译，也可以理解为做优化后的执行。</p><p><code>GC垃圾回收</code>会对<code>Heap堆</code>里面不再被引用的对象进行一个垃圾回收。</p><p>还有一些Java代码不方便实现的功能，必须调用底层操作系统的功能，跟操作系统交互需要一个<code>本地方法接口</code></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>JVM学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章 Java线程</title>
    <link href="/2021/12/20/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/12/20/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-Java线程"><a href="#第三章-Java线程" class="headerlink" title="第三章 Java线程"></a>第三章 Java线程</h1><p><strong>本章内容</strong>：</p><ul><li>创建和运行线程</li><li>查看线程</li><li>线程 API</li><li>线程状态</li></ul><h2 id="3-1-创建和运行线程"><a href="#3-1-创建和运行线程" class="headerlink" title="3.1 创建和运行线程"></a>3.1 创建和运行线程</h2><blockquote><p>每个程序一启动，都有一个主程序线程，称之为主线程。默认已经有一个主线程在运行了。</p></blockquote><h3 id="方法一，直接使用Thread"><a href="#方法一，直接使用Thread" class="headerlink" title="方法一，直接使用Thread"></a>方法一，直接使用Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程对象</span><br>Thread t = <span class="hljs-keyword">new</span> Thread() &#123;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 要执行的任务</span><br> &#125;<br>&#125;;<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//构造方法的参数是给线程指定名字，推荐</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//setName给线程指定名称</span><br>        <span class="hljs-comment">//t.setName(&quot;t1&quot;);</span><br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>        log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:42:09 [main] c.Test1 - running<br>16:42:09 [t1] c.Test1 - running<br></code></pre></td></tr></table></figure><h3 id="方法二，使用Runnable配合Thread"><a href="#方法二，使用Runnable配合Thread" class="headerlink" title="方法二，使用Runnable配合Thread"></a>方法二，使用Runnable配合Thread</h3><p>把【线程】和【任务】（要执行的代码）分开</p><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务（线程要执行的代码）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 要执行的任务</span><br>&#125;<br>&#125;;<br><span class="hljs-comment">// 创建线程对象，把runnable对象放入线程中</span><br>Thread t = <span class="hljs-keyword">new</span> Thread( runnable );<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建可运行的任务对象</span><br>        Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//创建线程对象,这边IDE提示：不建议显示创建线程，请使用线程池。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;t2&quot;</span>);<br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:54:14 [t2] c.Test2 - running<br></code></pre></td></tr></table></figure><p>Java8后可以使用lambda简化代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建可运行的任务对象</span><br>        Runnable runnable = () -&gt; log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>        <span class="hljs-comment">//创建线程对象,这边IDE提示：不建议显示创建线程，请使用线程池。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;t2&quot;</span>);<br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="***** 原理之 Thread 与 Runnable 的关系"></a>***** <strong>原理之</strong> <strong>Thread</strong> <strong>与</strong> <strong>Runnable</strong> 的关系</h3><blockquote><p>Test1是用了哪个run方法？</p></blockquote><p><img src="http://image.cryptomartin.top/img/image-20211218171132351.png" alt="image-20211218171132351"></p><blockquote><p>方法1是重写了父类的run方法，以子类的run方法为准。</p></blockquote><hr><blockquote><p>Test2是用了哪个run方法？</p></blockquote><p><img src="http://image.cryptomartin.top/img/image-20211218170423475.png" alt="image-20211218170423475"></p><p><img src="http://image.cryptomartin.top/img/image-20211218170523199.png" alt="image-20211218170523199"></p><p><img src="http://image.cryptomartin.top/img/image-20211218170708785.png" alt="image-20211218170708785"></p><p><img src="http://image.cryptomartin.top/img/image-20211218170923368.png" alt="image-20211218170923368"></p><blockquote><p>如果有Runnable对象，Thread优先采用Runnable对象的run方法。</p></blockquote><p><strong>小结</strong></p><ul><li>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合</li><li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><blockquote><p>更推荐Runnable的方法！！！优先组合关系，不是继承关系。</p></blockquote><h3 id="方法三，FutureTask配置Thread"><a href="#方法三，FutureTask配置Thread" class="headerlink" title="方法三，FutureTask配置Thread"></a>方法三，FutureTask配置Thread</h3><p><img src="http://image.cryptomartin.top/img/image-20211218172101398.png" alt="image-20211218172101398"></p><p><img src="http://image.cryptomartin.top/img/image-20211218172237257.png" alt="image-20211218172237257"></p><p><img src="http://image.cryptomartin.top/img/image-20211218172311299.png" alt="image-20211218172311299"></p><p>Future中的get方法可以返回任务执行的结果；Runnable是void没有返回结果。</p><hr><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        FutureTask&lt;Integer&gt; task =<span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>                <span class="hljs-comment">//让当前线程睡眠1s</span><br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//FutureTask实现了Runnable接口，所以可以放入Thread。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(task,<span class="hljs-string">&quot;t1&quot;</span>);<br>        t.start();<br><br>        <span class="hljs-comment">//主线程阻塞，等待结果FutureTask结果返回；FutureTask实现了任务及异步结果的集合功能</span><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,task.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">17:32:24 [t1] c.Test2 - running...<br>17:32:26 [main] c.Test2 - 100<br></code></pre></td></tr></table></figure><h2 id="3-2-观察多个线程同时运行"><a href="#3-2-观察多个线程同时运行" class="headerlink" title="3.2 观察多个线程同时运行"></a>3.2 观察多个线程同时运行</h2><p>主要是理解</p><ul><li>交替执行</li><li>谁先谁后，不由我们控制</li></ul><h2 id="3-3-查看进程线程的方法"><a href="#3-3-查看进程线程的方法" class="headerlink" title="3.3 查看进程线程的方法"></a>3.3 查看进程线程的方法</h2><p><strong>windows</strong></p><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li><code>tasklist</code> 查看进程</li><li><code>taskkill</code> 杀死进程</li></ul><p><strong>linux</strong></p><ul><li><code>ps -fe</code> 查看所有进程</li><li><code>ps -fT -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>top</code> 按大写 H 切换是否显示线程</li><li><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li></ul><h2 id="3-4-原理之线程运行"><a href="#3-4-原理之线程运行" class="headerlink" title="3.4 * 原理之线程运行"></a>3.4 * 原理之线程运行</h2><h3 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h3><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</p><ul><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法，互不干扰</li></ul><p>线程运行原理-栈帧图解：</p><p><img src="http://image.cryptomartin.top/img/image-20211218224550413.png" alt="image-20211218224550413"></p><h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul><h2 id="3-5-常见方法"><a href="#3-5-常见方法" class="headerlink" title="3.5 常见方法"></a>3.5 常见方法</h2><p><img src="http://image.cryptomartin.top/img/image-20211218230238918.png" alt="image-20211218230238918"></p><p><img src="http://image.cryptomartin.top/img/image-20211218230301086.png" alt="image-20211218230301086"></p><p><img src="http://image.cryptomartin.top/img/image-20211218230316126.png" alt="image-20211218230316126"></p><h3 id="3-5-1-Start与run"><a href="#3-5-1-Start与run" class="headerlink" title="3.5.1 Start与run"></a>3.5.1 Start与run</h3><p><strong>调用run方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>            log.debug(<span class="hljs-string">&quot;t1 Thread is running...&quot;</span>);<br>        &#125;<br>    &#125;;<br>    t1.run();<br>    log.debug(<span class="hljs-string">&quot;main Thread is running...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">23:16:48 [main] c.Test4 - t1 Thread is running...<br>23:16:48 [main] c.Test4 - main Thread is running...<br></code></pre></td></tr></table></figure><p>程序仍在 main 线程运行。</p><p><strong>调用start方法</strong></p><p>将上述代码中的<code>t1.run()</code>改为<code>t1.start()</code>，输出</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">23:21:01 [t1] c.Test4 - t1 Thread is running...<br>23:21:01 [main] c.Test4 - main Thread is running...<br></code></pre></td></tr></table></figure><p>程序在 t1 线程运行。</p><p><strong>小结</strong></p><ul><li>直接调用 <code>run()</code> 是在主线程中执行了 <code>run()</code>，没有启动新的线程</li><li>使用 <code>start()</code> 是启动新的线程，通过新的线程间接执行 <code>run()</code>方法 中的代码</li></ul><h3 id="3-5-2-sleep与yield"><a href="#3-5-2-sleep与yield" class="headerlink" title="3.5.2 sleep与yield"></a>3.5.2 sleep与yield</h3><p><strong>sleep</strong></p><ol><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 <code>InterruptedException</code>异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】</li><li>睡眠结束后的线程未必会立刻得到执行(需要分配到cpu时间片)</li><li>建议用 TimeUnit 的 <code>sleep()</code> 代替 Thread 的 <code>sleep()</code>来获得更好的可读性</li></ol><p>ps:<code>sleep()</code>方法写在哪个线程中，那个线程就进入睡眠。</p><p><strong>yield(让出的意思)</strong></p><ol><li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)</li></ol><p>阻塞状态与就绪状态线程区别：</p><ul><li>就绪状态，还是有机会被任务调度器调度的，任务调度器会分时间片给就绪状态的线程。</li><li>阻塞状态，任务调度器不会分时间片给阻塞状态的线程，只有睡眠时间到了，醒过来后，任务调度器才会时间片分给醒来的线程。</li></ul><p> <strong>小结</strong></p><p>yield让出cpu使用权，但是cpu可能会再分配时间片给该线程；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片</p><h3 id="3-5-3-线程优先级"><a href="#3-5-3-线程优先级" class="headerlink" title="3.5.3 线程优先级"></a>3.5.3 线程优先级</h3><ul><li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li><li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><h3 id="3-3-4-join"><a href="#3-3-4-join" class="headerlink" title="3.3.4 join"></a>3.3.4 join</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test10&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        test1();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>            r = <span class="hljs-number">10</span>;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">//t1.join();</span><br>        log.debug(<span class="hljs-string">&quot;结果为:&#123;&#125;&quot;</span>, r);<br>        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">11:58:20 [main] c.Test10 - 开始<br>11:58:20 [t1] c.Test10 - 开始<br>11:58:20 [main] c.Test10 - 结果为:0<br>11:58:20 [main] c.Test10 - 结束<br>11:58:21 [t1] c.Test10 - 结束<br></code></pre></td></tr></table></figure><p>分析</p><ul><li>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 <code>r=10</code></li><li>而主线程一开始就要打印 r 的结果，所以只能打印出 <code>r=0</code></li></ul><p>解决方法</p><ul><li>用 <code>sleep()</code> 行不行？为什么？</li><li>用 <code>join()</code>，加在 <code>t1.start()</code> 之后即可</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211219120326852.png" alt="image-20211219120326852"></p><p>以<code>调用方角度</code>来讲，如果:</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211219120527024.png" alt="image-20211219120527024"></p><blockquote><p><code>t1 thread</code>调用<code>join()</code>方法之后，<code>main thread</code>跟<code>t1 thread</code>是同步的，<code>main thread</code>必须等待<code>t1 thread</code>执行完成后，才能继续执行。</p></blockquote><p><strong>join()方法等待多个线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r1 = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r2 = <span class="hljs-number">0</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       test2();<br>   &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>           sleep(<span class="hljs-number">1</span>);<br>           r1 = <span class="hljs-number">10</span>;<br>       &#125;);<br>       Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>           sleep(<span class="hljs-number">2</span>);<br>           r2 = <span class="hljs-number">20</span>;<br>       &#125;);<br>       t1.start();<br>       t2.start();<br>       <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>       log.debug(<span class="hljs-string">&quot;join begin&quot;</span>);<br>       t2.join();<br>       log.debug(<span class="hljs-string">&quot;t2 join end&quot;</span>);<br>       t1.join();<br>       log.debug(<span class="hljs-string">&quot;t1 join end&quot;</span>);<br>       <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>       log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);<br>   &#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">14:16:35 [main] c.TestJoin - join begin<br>14:16:37 [main] c.TestJoin - t2 join end<br>14:16:37 [main] c.TestJoin - t1 join end<br>14:16:37 [main] c.TestJoin - r1: 10 r2: 20 cost: 2003<br></code></pre></td></tr></table></figure><p>分析如下</p><ul><li>第一个 join：等待 t1 时, t2 并没有停止, 而在运行</li><li>第二个 join：1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s</li></ul><p>如果颠倒两个 join 呢？</p><p>答：结果还是一样</p><p><strong>join(long n):最多等待n毫秒</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r1 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r2 = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    test3();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        sleep(<span class="hljs-number">2</span>);<br>        r1 = <span class="hljs-number">10</span>;<br>    &#125;);<br><br>    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>    t1.start();<br><br>    <span class="hljs-comment">// 线程执行结束会导致 join 结束</span><br>    log.debug(<span class="hljs-string">&quot;join begin&quot;</span>);<br>    t1.join(<span class="hljs-number">1500</span>);<br>    <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>    log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">14:24:33 [main] c.TestJoin - join begin<br>14:24:35 [main] c.TestJoin - r1: 0 r2: 0 cost: 1508<br></code></pre></td></tr></table></figure><blockquote><p>没等够时间，就按时间到期结束；如果等待时间还没万，但线程结束了，就不再等待了。</p></blockquote><h3 id="3-5-5-interrupt-方法详解"><a href="#3-5-5-interrupt-方法详解" class="headerlink" title="3.5.5 interrupt 方法详解"></a>3.5.5 interrupt 方法详解</h3><h4 id="interrupt可以打断-sleep，wait，join-的线程"><a href="#interrupt可以打断-sleep，wait，join-的线程" class="headerlink" title="interrupt可以打断 sleep，wait，join 的线程"></a>interrupt可以打断 sleep，wait，join 的线程</h4><p>阻塞</p><p>打断 sleep 的线程, 会清空打断状态，以 sleep 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>sleep(<span class="hljs-number">1</span>);<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>sleep(<span class="hljs-number">0.5</span>);<br>t1.interrupt();<br>log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">java.lang.InterruptedException: sleep interrupted<br> at java.lang.Thread.sleep(Native Method)<br> at java.lang.Thread.sleep(Thread.java:340)<br> at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)<br> at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)<br> at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)<br> at java.lang.Thread.run(Thread.java:745)<br>21:18:10.374 [main] c.TestInterrupt - 打断状态: false<br></code></pre></td></tr></table></figure><p><strong>打断正常运行的线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>Thread current = Thread.currentThread();<br>Boolean interrupted = current.isInterrupted();<br><span class="hljs-keyword">if</span>(interrupted) &#123;<br>log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br>sleep(<span class="hljs-number">0.5</span>);<br>t2.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">20:57:37.964 [t2] c.TestInterrupt - 打断状态: true<br></code></pre></td></tr></table></figure><p><strong>小结</strong></p><ul><li><p>如果位于特殊的阻塞状态，比如调用wait()、wait(long)或者join()或者sleep()等方法，中断标志位将会被清除，并且收到一个InterruptedException</p></li><li><p>打断正常运行的线程，调用<code>interrupt()</code>方法只是给线程打上一个中断标志位，并不会马上打断该线程。我们可以根据中断标志位来做一些操作。</p></li></ul><h4 id="【模式】模式之两阶段终止"><a href="#【模式】模式之两阶段终止" class="headerlink" title="【模式】模式之两阶段终止"></a>【模式】模式之两阶段终止</h4><p><code>Two Phase Termination</code><br>是在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。</p><p><strong>1.错误思路</strong></p><ul><li>使用线程对象的 stop() 方法停止线程<ul><li>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，<br>其它线程将永远无法获取锁</li></ul></li><li>使用 System.exit(int) 方法停止线程<ul><li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li></ul></li></ul><p><strong>2.两阶段终止模式</strong></p><p><img src="http://image.cryptomartin.top/img/image-20211220155929525.png" alt="image-20211220155929525"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        TwoPhaseTermination tpt = <span class="hljs-keyword">new</span> TwoPhaseTermination();<br>        tpt.start();<br><br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        tpt.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//监控类</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTermination</span> </span>&#123;<br>    <span class="hljs-comment">//创建监控线程，作为成员变量</span><br>    <span class="hljs-keyword">private</span> Thread monitor;<br><br>    <span class="hljs-comment">//开启监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">//不断执行</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-comment">//查看当前线程的中断标记</span><br>                Thread currentThread = Thread.currentThread();<br>                <span class="hljs-comment">//判断当前线程是否被打断</span><br>                <span class="hljs-keyword">if</span> (currentThread.isInterrupted()) &#123;<br>                    <span class="hljs-comment">//如果被打断</span><br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//如果当前线程没有被打断,睡眠1秒</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    <span class="hljs-comment">//没被打断，且没有异常；记录日志</span><br>                    log.debug(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                    <span class="hljs-comment">//在睡眠中被打断，会清除打断标记，打断标记此时为false;需要将中断标记置为真;重新设置打断标记为true</span><br>                    currentThread.interrupt();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//开启线程</span><br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">//停止监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:25:32 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>16:25:33 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>16:25:34 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>java.lang.InterruptedException: sleep interrupted<br><span class="hljs-code">at java.lang.Thread.sleep(Native Method)</span><br><span class="hljs-code">at com.sunk.test.TwoPhaseTermination.lambda$start$0(Test3.java:41)</span><br><span class="hljs-code">at java.lang.Thread.run(Thread.java:748)</span><br><span class="hljs-code">16:25:35 [Thread-0] c.TwoPhaseTermination - 料理后事</span><br></code></pre></td></tr></table></figure><p><strong>isInterrupted()与interrupted()区别</strong></p><ul><li><code>isInterrupted()</code>：判断当前线程是否被打断；不会清除打断标记</li><li><code>interrupted()</code>:判断当前线程是否被打断；会清除打断标记，如果打断标记为<code>true</code>，调用此方法后，变为<code>false</code></li></ul><h4 id="interrupted打断park线程"><a href="#interrupted打断park线程" class="headerlink" title="interrupted打断park线程"></a>interrupted打断park线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test14&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test14</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        test3();<br>    &#125;<br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>            log.debug(<span class="hljs-string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());<br>            <span class="hljs-comment">//打断标记为true，park就失效了。</span><br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        sleep(<span class="hljs-number">0.5</span>);<br>        t1.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:38:28 [t1] c.Test14 - park...<br>16:38:28 [t1] c.Test14 - unpark...<br>16:38:28 [t1] c.Test14 - 打断状态：true<br>16:38:28 [t1] c.Test14 - unpark...<br></code></pre></td></tr></table></figure><blockquote><p>如果打断标记已经是 true, 则 park 会失效</p></blockquote><h2 id="3-6-不推荐的方法"><a href="#3-6-不推荐的方法" class="headerlink" title="3.6 不推荐的方法"></a>3.6 不推荐的方法</h2><p><img src="http://image.cryptomartin.top/img/image-20211220164128203.png" alt="image-20211220164128203"></p><h2 id="3-7-守护线程"><a href="#3-7-守护线程" class="headerlink" title="3.7 守护线程"></a>3.7 守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做<code>守护线程</code>，<strong>只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test15&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test15</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;t1线程结束&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-comment">//设置t1线程为守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束</span><br>        t1.setDaemon(<span class="hljs-keyword">true</span>);<br>        t1.start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;主线程结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">19:06:21 [main] c.Test15 - 主线程结束<br></code></pre></td></tr></table></figure><blockquote><p>注意:</p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等<br>待它们处理完当前请求</li></ul></blockquote><h2 id="3-8-线程的五种状态"><a href="#3-8-线程的五种状态" class="headerlink" title="3.8 线程的五种状态"></a>3.8 线程的五种状态</h2><p>五种状态的划分主要是从操作系统的层面进行划分的</p><p><img src="http://image.cryptomartin.top/img/20200307093417-638644.png" alt="1583507073055"></p><ol><li><p>初始状态，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联</p></li><li><p>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</p></li><li><p>运行状态，指线程获取了CPU时间片，正在运行</p><ul><li>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</li></ul></li><li><p>阻塞状态</p><ul><li><p>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】</p></li><li><p>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p></li><li><p>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</p></li></ul></li><li><p>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ol><h2 id="3-9-线程的六种状态"><a href="#3-9-线程的六种状态" class="headerlink" title="3.9 线程的六种状态"></a>3.9 线程的六种状态</h2><p>这是从 Java API 层面来描述的，我们主要研究的就是这种。状态转换详情图：<a href="https://www.jianshu.com/p/ec94ed32895f">地址</a><br>根据 Thread.State 枚举，分为六种状态 </p><p><img src="http://image.cryptomartin.top/img/20200307093352-614933.png" alt="1583507709834"></p><ul><li>NEW 跟五种状态里的初始状态是一个意思</li><li> RUNNABLE 是当调用了 <code>start()</code> 方法之后的状态，注意，Java API 层面的 <code>RUNNABLE</code> 状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【io阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li><li><code>BLOCKED</code> ， <code>WAITING</code> ， <code>TIMED_WAITING</code> 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节<br> 详述</li></ul><h2 id="3-10-习题-统筹规划"><a href="#3-10-习题-统筹规划" class="headerlink" title="3.10 习题-统筹规划"></a>3.10 习题-统筹规划</h2><p><img src="http://image.cryptomartin.top/img/image-20211220194112708.png" alt="image-20211220194112708"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test16&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test16</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;洗水壶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            log.debug(<span class="hljs-string">&quot;烧开水，花费15分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">15</span>);<br>        &#125;, <span class="hljs-string">&quot;老王&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;洗茶壶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            log.debug(<span class="hljs-string">&quot;洗茶杯，花费2分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>            log.debug(<span class="hljs-string">&quot;拿茶叶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//小王模拟泡茶，等待开水烧开。</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                t1.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;可以泡茶了！&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;小王&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">19:38:37 [老王] c.Test16 - 洗水壶，花费1分钟<br>19:38:37 [小王] c.Test16 - 洗茶壶，花费1分钟<br>19:38:38 [老王] c.Test16 - 烧开水，花费15分钟<br>19:38:38 [小王] c.Test16 - 洗茶杯，花费2分钟<br>19:38:40 [小王] c.Test16 - 拿茶叶，花费1分钟<br>19:38:53 [小王] c.Test16 - 可以泡茶了！<br></code></pre></td></tr></table></figure><p>ps:秒代替分钟。</p><p>执行到<code>19:38:38 [老王] c.Test16 - 烧开水，花费15分钟</code>，会等待15秒，然后会执行<code>19:38:53 [小王] c.Test16 - 可以泡茶了！</code></p><h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><p>本章的重点在于掌握</p><ul><li><p>线程创建</p></li><li><p>线程重要 api，如 start，run，sleep，join，interrupt 等</p></li><li><p>线程状态</p></li><li><p>应用方面</p><ul><li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li><li>提高效率：并行计算，缩短运算时间</li><li>同步等待：join</li><li>统筹规划：合理使用线程，得到最优效果</li></ul></li><li><p>原理方面</p><ul><li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li><li>Thread 两种创建方式 的源码</li></ul></li><li><p>模式方面</p><ul><li>两阶段终止模式</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 七牛云外链图片无法显示</title>
    <link href="/2021/12/16/Hexo%20%E5%A4%96%E9%93%BE%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/"/>
    <url>/2021/12/16/Hexo%20%E5%A4%96%E9%93%BE%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-七牛云外链图片无法显示"><a href="#Hexo-七牛云外链图片无法显示" class="headerlink" title="Hexo 七牛云外链图片无法显示"></a>Hexo 七牛云外链图片无法显示</h1><h2 id="1-起因"><a href="#1-起因" class="headerlink" title="1. 起因"></a>1. 起因</h2><p>打算好好做Hexo博客，结果太折腾了。七牛云的图床，在Hexo博客结果不能显示，网上的方法用了很多都失败了，自己查了一下错误。</p><p>大概原因是：<code>github请求的协议是用HTTPS，而七牛云是HTTP，协议不兼容导致</code></p><p><img src="http://image.cryptomartin.top/img/image-20211216185546365.png" alt="image-20211216185546365"></p><h2 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h2><p><code>在七牛云打开强制HTTPS</code></p><p><img src="http://image.cryptomartin.top/img/image-20211216190015768.png" alt="image-20211216190015768"></p><p><img src="http://image.cryptomartin.top/img/image-20211216190203695.png" alt="image-20211216190203695"></p><h2 id="3-结果"><a href="#3-结果" class="headerlink" title="3. 结果"></a>3. 结果</h2><p>等待5分钟左右，就有七牛云发邮件，提示成功开启<code>强制HTTPS</code></p><p><img src="http://image.cryptomartin.top/img/image-20211216190318735.png" alt="image-20211216190318735"></p><p>Hexo成功显示七牛云外链图片：</p><p><img src="http://image.cryptomartin.top/img/image-20211216190503464.png" alt="image-20211216190503464"></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 进程与线程</title>
    <link href="/2021/12/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/12/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 进程与线程</h1><p><strong>本章内容</strong></p><ul><li>进程和线程的概念</li><li>并行和并发的概念</li><li>线程基本应用</li></ul><h2 id="2-1-进程与线程概念"><a href="#2-1-进程与线程概念" class="headerlink" title="2.1 进程与线程概念"></a>2.1 进程与线程概念</h2><h3 id="2-1-1-进程"><a href="#2-1-1-进程" class="headerlink" title="2.1.1 进程"></a>2.1.1 进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在<br>指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器<br>等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><p>简单说就是：</p><blockquote><p>进程：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程.</p></blockquote><h3 id="2-1-2-线程"><a href="#2-1-2-线程" class="headerlink" title="2.1.2 线程"></a>2.1.2 线程</h3><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作<br>为线程的容器</li></ul><blockquote><p>线程是进程当中的一条执行流程.</p></blockquote><blockquote><p>线程 = 进程 - 共享资源</p></blockquote><h3 id="2-1-3-进程与线程对比"><a href="#2-1-3-进程与线程对比" class="headerlink" title="2.1.3 进程与线程对比"></a>2.1.3 进程与线程对比</h3><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li><li>进程间通信较为复杂<ul><li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h2 id="2-2-并发与并行的概念"><a href="#2-2-并发与并行的概念" class="headerlink" title="2.2 并发与并行的概念"></a>2.2 并发与并行的概念</h2><p>单核 cpu 下，线程实际还是 <code>串行执行</code> 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows<br>下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感<br>觉是 同时运行的 。总结为一句话就是： <code>微观串行，宏观并行</code> ，<br>一般会将这种 线程轮流使用 CPU 的做法称为并发， concurrent</p><p><img src="http://image.cryptomartin.top/img/image-20211216152119986.png" alt="image-20211216152119986"></p><p>多核 cpu下，每个 核（core） 都可以调度运行线程，这时候线程可以是并行的。</p><p><img src="http://image.cryptomartin.top/img/image-20211216152309525.png" alt="image-20211216152309525"></p><blockquote><p>并发：一段时间内运行多个进程</p><p>并行：一个时间点运行多个进程，一般要求有多个CPU</p></blockquote><h2 id="2-3-应用"><a href="#2-3-应用" class="headerlink" title="2.3 应用"></a>2.3 应用</h2><h3 id="2-3-1-应用之异步调用（案例1）"><a href="#2-3-1-应用之异步调用（案例1）" class="headerlink" title="2.3.1 应用之异步调用（案例1）"></a>2.3.1 应用之异步调用（案例1）</h3><p>以调用方角度来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><h4 id="1-设计"><a href="#1-设计" class="headerlink" title="1) 设计"></a>1) 设计</h4><p>多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，这么cpu只能等5秒，啥都不能做。</p><h4 id="2-结论"><a href="#2-结论" class="headerlink" title="2) 结论"></a>2) 结论</h4><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li><li>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><h3 id="2-3-2-应用之提高效率（案例1）"><a href="#2-3-2-应用之提高效率（案例1）" class="headerlink" title="2.3.2 应用之提高效率（案例1）"></a>2.3.2 应用之提高效率（案例1）</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">计算 <span class="hljs-number">1</span> 花费 <span class="hljs-number">10</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">计算 2</span> 花费 <span class="hljs-number">11</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">计算 3</span> 花费 <span class="hljs-number">9</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">汇总需要 1</span> ms<br></code></pre></td></tr></table></figure><ul><li>如果是串行执行，那么总共花费的时间是 <code>10 + 11 + 9 + 1 = 31ms</code></li><li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个<br>线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 <code>11ms</code> 最后加上汇总时间只会花费 <code>12ms</code></li></ul><p><strong>注意</strong></p><blockquote><p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 并发编程概览</title>
    <link href="/2021/12/16/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E8%A7%88/"/>
    <url>/2021/12/16/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-并发编程概览"><a href="#第一章-并发编程概览" class="headerlink" title="第一章 并发编程概览"></a>第一章 并发编程概览</h1><h2 id="1-1-这门课主要学什么"><a href="#1-1-这门课主要学什么" class="headerlink" title="1.1 这门课主要学什么"></a>1.1 这门课主要学什么</h2><p>这门课中的【并发】一词涵盖了在 Java 平台上的</p><ul><li>进程</li><li>线程</li><li>并发</li><li>并行</li></ul><p>以及 Java 并发工具、并发问题以及解决方案，同时我也会讲解一些其它领域的并发</p><h2 id="1-2-为什么要学并发编程"><a href="#1-2-为什么要学并发编程" class="headerlink" title="1.2 为什么要学并发编程"></a>1.2 为什么要学并发编程</h2><ul><li><p>我工作中用不到并发啊？</p><p>  做CRUD，用不到并发编程；但希望往更高层面发展，必须学并发编程！平时用的Tomcat服务器、Dubbo、消息中间件等，这些底层肯定涉及多线程！</p></li></ul><h2 id="1-3-学习路线"><a href="#1-3-学习路线" class="headerlink" title="1.3 学习路线"></a>1.3 学习路线</h2><p>本门课程以并发、并行为主线，穿插讲解</p><p><strong>应用</strong> - 结合实际<br><strong>原理</strong> - 了然于胸<br><strong>模式</strong> - 正确姿势</p><ul><li><input disabled="" type="checkbox"> 思维导图</li></ul><h2 id="1-4-预备知识"><a href="#1-4-预备知识" class="headerlink" title="1.4 预备知识"></a>1.4 预备知识</h2><ul><li>有一定的框架经验</li><li>线程安全问题，需要你接触过 Java Web 开发、Jdbc 开发、Web 服务器、分布式框架时才会遇到</li><li>基于 JDK 8，最好对函数式编程、lambda 有一定了解</li><li>采用了 slf4j 打印日志，这是好的实践</li><li>采用了 lombok 简化 java bean 编写</li><li>给每个线程好名字，这也是一项好的实践</li></ul><p>pom.xml 依赖如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>logback.xml配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://ch.qos.logback/xml/ns/logback&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://ch.qos.logback/xml/ns/logback logback.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%date&#123;HH:mm:ss&#125; [%t] %logger - %m%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;c&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
