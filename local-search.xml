<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第六章 共享模型之无锁</title>
    <link href="/2022/02/01/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81/"/>
    <url>/2022/02/01/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="第六章-共享模型之无锁"><a href="#第六章-共享模型之无锁" class="headerlink" title="第六章 共享模型之无锁"></a>第六章 共享模型之无锁</h1><p>本章内容</p><ul><li>CAS与volatile</li><li>原子整数</li><li>原子引用</li><li>原子累加器</li><li>Unsafe</li></ul><h2 id="6-1-案例改进-由加锁到无锁"><a href="#6-1-案例改进-由加锁到无锁" class="headerlink" title="6.1 案例改进-由加锁到无锁"></a>6.1 案例改进-由加锁到无锁</h2><h3 id="6-1-1-问题提出"><a href="#6-1-1-问题提出" class="headerlink" title="6.1.1 问题提出"></a>6.1.1 问题提出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAccount</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Account account = <span class="hljs-keyword">new</span> AccountUnsafe(<span class="hljs-number">10000</span>);<br>        Account.demo(account);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Integer balance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = balance;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance-=amount;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-comment">// 获取余额</span><br>    <span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 取款</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                account.withdraw(<span class="hljs-number">10</span>);<br>            &#125;));<br>        &#125;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        ts.forEach(Thread::start);<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(account.getBalance()<br>                + <span class="hljs-string">&quot; cost: &quot;</span> + (end-start)/<span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">430</span> cost: <span class="hljs-number">113</span> ms<br></code></pre></td></tr></table></figure><h3 id="6-1-2-解决思路：加锁"><a href="#6-1-2-解决思路：加锁" class="headerlink" title="6.1.2 解决思路：加锁"></a>6.1.2 解决思路：加锁</h3><p>首先想到的是给 Account 对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer balance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = balance;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>)&#123;<br>            <span class="hljs-keyword">this</span>.balance -= amount;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> cost: <span class="hljs-number">113</span> ms<br></code></pre></td></tr></table></figure><h3 id="6-1-3-解决思路-无锁"><a href="#6-1-3-解决思路-无锁" class="headerlink" title="6.1.3 解决思路-无锁"></a>6.1.3 解决思路-无锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicInteger balance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-comment">//获取最新值</span><br>            <span class="hljs-keyword">int</span> prev = balance.get();<br>            <span class="hljs-comment">//要修改的余额</span><br>            <span class="hljs-keyword">int</span> next = prev - amount;<br>            <span class="hljs-comment">//真正修改，同步到主存</span><br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> cost: <span class="hljs-number">107</span> ms<br></code></pre></td></tr></table></figure><h2 id="6-2-CAS与volatile"><a href="#6-2-CAS与volatile" class="headerlink" title="6.2 CAS与volatile"></a>6.2 CAS与volatile</h2><h3 id="6-2-1-CAS分析"><a href="#6-2-1-CAS分析" class="headerlink" title="6.2.1 CAS分析"></a>6.2.1 CAS分析</h3><p>前面看到的 <code>AtomicInteger</code> 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">int</span> prev = balance.<span class="hljs-built_in">get</span>();<br>            <span class="hljs-keyword">int</span> next = prev - amount;<br>            <span class="hljs-comment">//比较并设置</span><br>            <span class="hljs-keyword">if</span> (balance.<span class="hljs-built_in">compareAndSet</span>(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p><p><img src="http://image.cryptomartin.top/img/image-20220103174310686.png" alt="image-20220103174310686"></p><blockquote><p><strong>注意</strong></p><p>其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。</p><p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p></blockquote><h3 id="6-2-2-CAS必须配合volatile使用"><a href="#6-2-2-CAS必须配合volatile使用" class="headerlink" title="6.2.2 CAS必须配合volatile使用"></a>6.2.2 CAS必须配合volatile使用</h3><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。</p><p><img src="http://image.cryptomartin.top/img/image-20220103175134654.png" alt="image-20220103175134654"></p><p>它可以用来修饰成员变量和静态成员变量，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p><blockquote><p><strong>注意</strong></p><p>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p></blockquote><p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</p><h3 id="6-2-3-为什么无锁效率高"><a href="#6-2-3-为什么无锁效率高" class="headerlink" title="6.2.3 为什么无锁效率高"></a>6.2.3 为什么无锁效率高</h3><ul><li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻</li><li>线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大</li><li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</li></ul><h3 id="6-2-4-CAS的特点"><a href="#6-2-4-CAS的特点" class="headerlink" title="6.2.4 CAS的特点"></a>6.2.4 CAS的特点</h3><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p><ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li><li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思<ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h2 id="6-3-Atomic"><a href="#6-3-Atomic" class="headerlink" title="6.3 Atomic"></a>6.3 Atomic</h2><h3 id="6-3-1-原子整数"><a href="#6-3-1-原子整数" class="headerlink" title="6.3.1 原子整数"></a>6.3.1 原子整数</h3><p>J.U.C 并发包提供了：</p><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><p>以 AtomicInteger 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test34</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>        System.out.println(i.incrementAndGet()); <span class="hljs-comment">//++i 自增再在打印1</span><br>        System.out.println(i.getAndIncrement()); <span class="hljs-comment">//i++ 先打印1再自增</span><br><br>        System.out.println(i.getAndAdd(<span class="hljs-number">5</span>)); <span class="hljs-comment">//打印2，7</span><br>        System.out.println(i.addAndGet(<span class="hljs-number">5</span>)); <span class="hljs-comment">//12,打印12</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p><strong>updateAndGet()原理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test34</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">//             读取到    设置值</span><br>        i.updateAndGet(value -&gt; value * <span class="hljs-number">10</span>);<br>        System.out.println(i.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>手动实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test34</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        //             读取到    设置值</span><br><span class="hljs-comment">        i.updateAndGet(value -&gt; value * 10);</span><br><span class="hljs-comment">        System.out.println(i.get());</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//手动实现updateAndGet</span><br>        System.out.println(updateAndGet(i, p -&gt; p / <span class="hljs-number">2</span>));<br>        System.out.println(i.get());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateAndGet</span><span class="hljs-params">(AtomicInteger i, IntUnaryOperator operator)</span></span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">int</span> prev = i.get();<br>            <span class="hljs-keyword">int</span> next = operator.applyAsInt(prev);<br>            <span class="hljs-keyword">if</span> (i.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">return</span> next;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-2-原子引用"><a href="#6-3-2-原子引用" class="headerlink" title="6.3.2 原子引用"></a>6.3.2 原子引用</h3><p>为什么需要原子引用类型？–为了线程安全和高效</p><ul><li>AtomicReference</li><li>AtomicMarkableReference</li><li>AtomicStampedReference</li></ul><h4 id="6-3-2-1-安全实现-使用-CAS"><a href="#6-3-2-1-安全实现-使用-CAS" class="headerlink" title="6.3.2.1 安全实现-使用 CAS"></a>6.3.2.1 安全实现-使用 CAS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test35</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        DecimalAccountCas dac = <span class="hljs-keyword">new</span> DecimalAccountCas(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;10000&quot;</span>));<br>        DecimalAccount.demo(dac);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountCas</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(balance);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            BigDecimal prev = balance.get();<br>            BigDecimal next = prev.subtract(amount);<br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br>    <span class="hljs-comment">// 获取余额</span><br>    <span class="hljs-function">BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 取款</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(DecimalAccount account)</span> </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                account.withdraw(BigDecimal.TEN);<br>            &#125;));<br>        &#125;<br>        ts.forEach(Thread::start);<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        System.out.println(account.getBalance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="6-3-2-2-ABA问题"><a href="#6-3-2-2-ABA问题" class="headerlink" title="6.3.2.2 ABA问题"></a>6.3.2.2 ABA问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test36&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test36</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        <span class="hljs-comment">// 获取值 A</span><br>        <span class="hljs-comment">// 这个共享变量被它线程修改过？</span><br>        String prev = ref.get();<br>        other();<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 尝试改为 C</span><br>        log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;B&quot;</span>));<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        sleep(<span class="hljs-number">0.5</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;A&quot;</span>));<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">33</span>:<span class="hljs-number">55</span> [main] c.Test36 - main start...<br><span class="hljs-number">11</span>:<span class="hljs-number">33</span>:<span class="hljs-number">55</span> [t1] c.Test36 - change A-&gt;B <span class="hljs-keyword">true</span><br><span class="hljs-number">11</span>:<span class="hljs-number">33</span>:<span class="hljs-number">55</span> [t2] c.Test36 - change B-&gt;A <span class="hljs-keyword">true</span><br><span class="hljs-number">11</span>:<span class="hljs-number">33</span>:<span class="hljs-number">56</span> [main] c.Test36 - change A-&gt;C <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><blockquote><p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：</p><p>只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号</p></blockquote><h4 id="6-3-2-3-ASR"><a href="#6-3-2-3-ASR" class="headerlink" title="6.3.2.3 ASR"></a>6.3.2.3 ASR</h4><p><strong>AtomicStampedReference</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test36&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test36</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        <span class="hljs-comment">// 获取值 A</span><br>        <span class="hljs-comment">// 这个共享变量被它线程修改过？</span><br>        String prev = ref.getReference();<br>        <span class="hljs-comment">//main线程获取版本号</span><br>        <span class="hljs-keyword">int</span> stamp = ref.getStamp();<br>        log.debug(<span class="hljs-string">&quot;main线程在调用other()方法之前的stamp:&#123;&#125;&quot;</span>, stamp);<br>        other();<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 尝试改为 C</span><br>        log.debug(<span class="hljs-string">&quot;main线程在调用other()方法之后的stamp:&#123;&#125;&quot;</span>, stamp);<br>        log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">int</span> stamp = ref.getStamp();<br>            log.debug(<span class="hljs-string">&quot;t1线程获取stamp：&#123;&#125;&quot;</span>, stamp);<br>            log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">0.5</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">int</span> stamp = ref.getStamp();<br>            log.debug(<span class="hljs-string">&quot;t2线程获取stamp：&#123;&#125;&quot;</span>, stamp);<br>            log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">44</span> [main] c.Test36 - main start...<br><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">44</span> [main] c.Test36 - main线程在调用other()方法之前的stamp:<span class="hljs-number">0</span><br><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">44</span> [t1] c.Test36 - t1线程获取stamp：<span class="hljs-number">0</span><br><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">44</span> [t1] c.Test36 - change A-&gt;B <span class="hljs-keyword">true</span><br><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">44</span> [t2] c.Test36 - t2线程获取stamp：<span class="hljs-number">1</span><br><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">44</span> [t2] c.Test36 - change B-&gt;A <span class="hljs-keyword">true</span><br><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">45</span> [main] c.Test36 - main线程在调用other()方法之后的stamp:<span class="hljs-number">0</span><br><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">45</span> [main] c.Test36 - change A-&gt;C <span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： <code>A -&gt; B -&gt; A -&gt; C</code> ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。</p><p>但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了AtomicMarkableReference</p><h4 id="6-3-2-4-AMR"><a href="#6-3-2-4-AMR" class="headerlink" title="6.3.2.4 AMR"></a>6.3.2.4 AMR</h4><pre><code class=" mermaid">graph TDs(保洁阿姨)m(主人)g1(垃圾袋)g2(新垃圾袋)s -. 倒空 .-&gt;g1m -- 检查 --&gt;g1g1 -- 已满 --&gt;g2g1 -- 还空 --&gt;g1</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GarbageBag</span> </span>&#123;<br>String desc;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GarbageBag</span><span class="hljs-params">(String desc)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.desc = desc;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDesc</span><span class="hljs-params">(String desc)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.desc = desc;<br>&#125;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString() + <span class="hljs-string">&quot; &quot;</span> + desc;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestABAAtomicMarkableReference</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>GarbageBag bag = <span class="hljs-keyword">new</span> GarbageBag(<span class="hljs-string">&quot;装满了垃圾&quot;</span>);<br><span class="hljs-comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span><br>AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(bag, <span class="hljs-keyword">true</span>);<br>log.debug(<span class="hljs-string">&quot;主线程 start...&quot;</span>);<br>GarbageBag prev = ref.getReference();<br>log.debug(prev.toString());<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;打扫卫生的线程 start...&quot;</span>);<br>bag.setDesc(<span class="hljs-string">&quot;空垃圾袋&quot;</span>);<br><span class="hljs-keyword">while</span> (!ref.compareAndSet(bag, bag, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>)) &#123;<br>&#125;<br>log.debug(bag.toString());<br>&#125;<br>).start();<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>log.debug(<span class="hljs-string">&quot;主线程想换一只新垃圾袋？&quot;</span>);<br>Boolean success = ref.compareAndSet(prev, <span class="hljs-keyword">new</span> GarbageBag(<span class="hljs-string">&quot;空垃圾袋&quot;</span>), <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>log.debug(<span class="hljs-string">&quot;换了么？&quot;</span> + success);<br>log.debug(ref.getReference().toString());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">09.264</span> [main] 主线程 start... <br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">09.270</span> [main] cn.itcast.GarbageBag@5f0fd5a0 装满了垃圾<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">09.293</span> [Thread-<span class="hljs-number">1</span>] 打扫卫生的线程 start... <br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">09.294</span> [Thread-<span class="hljs-number">1</span>] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">10.294</span> [main] 主线程想换一只新垃圾袋？<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">10.294</span> [main] 换了么？<span class="hljs-keyword">false</span> <br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">10.294</span> [main] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋<br></code></pre></td></tr></table></figure><h3 id="6-3-3-原子数组"><a href="#6-3-3-原子数组" class="headerlink" title="6.3.3 原子数组"></a>6.3.3 原子数组</h3><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test39</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//不安全数组</span><br>        demo(<br>                () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>],<br>                (array) -&gt; array.length,<br>                (array, index) -&gt; array[index]++,<br>                array -&gt; System.out.println(Arrays.toString(array))<br>        );<br><span class="hljs-comment">//原子数组</span><br>        demo(<br>                () -&gt; <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>),<br>                (array) -&gt; array.length(),<br>                (array, index) -&gt; array.getAndIncrement(index),<br>                array -&gt; System.out.println(array)<br>        );<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 参数1，提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment">     * 参数2，获取数组长度的方法</span><br><span class="hljs-comment">     * 参数3，自增方法，回传 array, index</span><br><span class="hljs-comment">     * 参数4，打印数组的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// supplier 提供者 无中生有  ()-&gt;结果</span><br>    <span class="hljs-comment">// function 函数   一个参数一个结果   (参数)-&gt;结果  ,  BiFunction (参数1,参数2)-&gt;结果</span><br>    <span class="hljs-comment">// consumer 消费者 一个参数没结果  (参数)-&gt;void,      BiConsumer (参数1,参数2)-&gt;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            Supplier&lt;T&gt; arraySupplier,</span></span><br><span class="hljs-params"><span class="hljs-function">            Function&lt;T, Integer&gt; lengthFun,</span></span><br><span class="hljs-params"><span class="hljs-function">            BiConsumer&lt;T, Integer&gt; putConsumer,</span></span><br><span class="hljs-params"><span class="hljs-function">            Consumer&lt;T&gt; printConsumer)</span> </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        T array = arraySupplier.get();<br>        <span class="hljs-keyword">int</span> length = lengthFun.apply(array);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-comment">// 每个线程对数组作 10000 次操作</span><br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    putConsumer.accept(array, j % length);<br>                &#125;<br>            &#125;));<br>        &#125;<br><br>        ts.forEach(t -&gt; t.start()); <span class="hljs-comment">// 启动所有线程</span><br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);     <span class="hljs-comment">// 等所有线程结束</span><br>        printConsumer.accept(array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>]<br></code></pre></td></tr></table></figure><h3 id="6-3-4-字段更新器"><a href="#6-3-4-字段更新器" class="headerlink" title="6.3.4 字段更新器"></a>6.3.4 字段更新器</h3><ul><li>AtomicReferenceFieldUpdater // 域 字段</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Must be <span class="hljs-keyword">volatile</span> type<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test40&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test40</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student stu = <span class="hljs-keyword">new</span> Student();<br><br>        AtomicReferenceFieldUpdater updater =<br>                AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);<br><br>        System.out.println(updater.compareAndSet(stu, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;张三&quot;</span>));<br>        System.out.println(stu);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> String name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">true</span><br>Student&#123;name=<span class="hljs-string">&#x27;张三&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-5-原子累加器"><a href="#6-3-5-原子累加器" class="headerlink" title="6.3.5 原子累加器"></a>6.3.5 原子累加器</h3><h4 id="6-3-5-1-累加器性能比较"><a href="#6-3-5-1-累加器性能比较" class="headerlink" title="6.3.5.1 累加器性能比较"></a>6.3.5.1 累加器性能比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test41</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(<br>                    () -&gt; <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>),<br>                    (adder) -&gt; adder.getAndIncrement()<br>            );<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(<br>                    () -&gt; <span class="hljs-keyword">new</span> LongAdder(),<br>                    adder -&gt; adder.increment()<br>            );<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    () -&gt; 结果    提供累加器对象</span><br><span class="hljs-comment">    (参数) -&gt;     执行累加操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> </span>&#123;<br>        T adder = adderSupplier.get();<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 4 个线程，每人累加 50 万</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">500000</span>; j++) &#123;<br>                    action.accept(adder);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        ts.forEach(t -&gt; t.start());<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(adder + <span class="hljs-string">&quot; cost:&quot;</span> + (end - start) / <span class="hljs-number">1000_000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1000000</span> cost:<span class="hljs-number">31</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">27</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">28</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">24</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">22</span><br><br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">43</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">9</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">7</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">7</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">7</span> <br></code></pre></td></tr></table></figure><p>性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p><h4 id="6-3-5-2-源码之LongAdder"><a href="#6-3-5-2-源码之LongAdder" class="headerlink" title="6.3.5.2 *源码之LongAdder"></a>6.3.5.2 *源码之LongAdder</h4><p>LongAdder 是并发大师 @author Doug Lea （大哥李）的作品，设计的非常精巧<br>LongAdder 类有几个关键域:</p><p>transient是为了防止序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 累加单元数组, 懒惰初始化</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br><span class="hljs-comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> base;<br><span class="hljs-comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> cellsBusy;<br></code></pre></td></tr></table></figure><h4 id="6-3-5-3-CAS实现锁"><a href="#6-3-5-3-CAS实现锁" class="headerlink" title="6.3.5.3 CAS实现锁"></a>6.3.5.3 CAS实现锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test42&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockCas</span> </span>&#123;<br>    <span class="hljs-comment">// 0 没加锁</span><br>    <span class="hljs-comment">// 1 加锁</span><br>    <span class="hljs-keyword">private</span> AtomicInteger state = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (state.compareAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;unlock...&quot;</span>);<br>        state.set(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LockCas lock = <span class="hljs-keyword">new</span> LockCas();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;lock...&quot;</span>);<br>                sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;lock...&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">07.198</span> c.Test42 [Thread-<span class="hljs-number">0</span>] - begin... <br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">07.202</span> c.Test42 [Thread-<span class="hljs-number">0</span>] - lock... <br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">07.198</span> c.Test42 [Thread-<span class="hljs-number">1</span>] - begin... <br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">08.204</span> c.Test42 [Thread-<span class="hljs-number">0</span>] - unlock... <br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">08.204</span> c.Test42 [Thread-<span class="hljs-number">1</span>] - lock... <br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">08.204</span> c.Test42 [Thread-<span class="hljs-number">1</span>] - unlock...<br></code></pre></td></tr></table></figure><h4 id="6-3-5-4-原理之为伪共享"><a href="#6-3-5-4-原理之为伪共享" class="headerlink" title="6.3.5.4 *原理之为伪共享"></a>6.3.5.4 *原理之为伪共享</h4><p><a href="https://zhuanlan.zhihu.com/p/135462276">CPU中的缓存、缓存一致性、伪共享和缓存行填充 - 破执的文章 - 知乎</a></p><p>其中 Cell 即为累加单元</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 防止缓存行伪共享</span><br><span class="hljs-meta">@sun</span>.misc.Contended<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cell</span> </span>&#123;<br><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> value;<br>Cell(<span class="hljs-keyword">long</span> x) &#123;<br>value = x;<br>&#125;<br><span class="hljs-comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> Boolean <span class="hljs-title">cas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> prev, <span class="hljs-keyword">long</span> next)</span> </span>&#123;<br><span class="hljs-keyword">return</span> UNSAFE.compareAndSwaplong(<span class="hljs-keyword">this</span>, valueOffset, prev, next);<br>&#125;<br><span class="hljs-comment">// 省略不重要代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>得从缓存说起</p><p>缓存与内存的速度比较</p><p><img src="http://image.cryptomartin.top/img/image-20220104165053031.png" alt="image-20220104165053031"></p><p><img src="http://image.cryptomartin.top/img/image-20220104165105291.png" alt="image-20220104165105291"></p><p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。<br>而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long）<br>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中<br>CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效</p><p><img src="http://image.cryptomartin.top/img/image-20220104165532132.png" alt="image-20220104165532132"></p><p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p><ul><li>Core-0 要修改 Cell[0]</li><li>Core-1 要修改 Cell[1]</li></ul><p>无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 <code>Cell[0]=6000, Cell[1]=8000</code> 要累加<code>Cell[0]=6001, Cell[1]=8000</code> ，这时会让 Core-1 的缓存行失效</p><p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效—为什么是128字节，不太懂。总之是填充，让累计单元数组不在同一个缓存行中。</p><p><img src="http://image.cryptomartin.top/img/image-20220104170215432.png" alt="image-20220104170215432"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;<br><span class="hljs-comment">// as 为累加单元数组</span><br><span class="hljs-comment">// b 为基础值</span><br><span class="hljs-comment">// x 为累加值</span><br>Cell[] as;<br><span class="hljs-keyword">long</span> b, v;<br><span class="hljs-keyword">int</span> m;<br>Cell a;<br><span class="hljs-comment">// 进入 if 的两个条件</span><br><span class="hljs-comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span><br><span class="hljs-comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span><br><span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;<br><span class="hljs-comment">// uncontended 表示 cell 没有竞争</span><br>Boolean uncontended = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">if</span> (<br> <span class="hljs-comment">// as 还没有创建</span><br>as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br> <span class="hljs-comment">// 当前线程对应的 cell 还没有</span><br>(a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||<br> <span class="hljs-comment">// cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span><br>!(uncontended = a.cas(v = a.value, v + x))<br> ) &#123;<br><span class="hljs-comment">// 进入 cell 数组创建、cell 创建的流程</span><br>longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20220104171057811.png" alt="image-20220104171057811"></p><p><strong>longAccumulate</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">longAccumulate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, LongBinaryOperator fn,</span></span><br><span class="hljs-params"><span class="hljs-function"> Boolean wasUncontended)</span> </span>&#123;<br><span class="hljs-keyword">int</span> h;<br><span class="hljs-comment">// 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell</span><br><span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 初始化 probe</span><br>ThreadLocalRandom.current();<br><span class="hljs-comment">// h 对应新的 probe 值, 用来对应 cell</span><br>h = getProbe();<br>wasUncontended = <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-comment">// collide 为 true 表示需要扩容</span><br>Boolean collide = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">for</span> (;;) &#123;<br>Cell[] as;<br>Cell a;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">long</span> v;<br><span class="hljs-comment">// 已经有了 cells</span><br><span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 还没有 cell</span><br><span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x</span><br><span class="hljs-comment">// 成功则 break, 否则继续 continue 循环</span><br>&#125;<br><span class="hljs-comment">// 有竞争, 改变线程对应的 cell 来重试 cas else if (!wasUncontended)</span><br> wasUncontended = <span class="hljs-keyword">true</span>;<br><span class="hljs-comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAslong(v, x))))</span><br> <span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas else if (n &gt;= NCPU || cells != as)</span><br> collide = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了 else if (!collide)</span><br> collide = <span class="hljs-keyword">true</span>;<br><span class="hljs-comment">// 加锁 else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;</span><br><span class="hljs-comment">// 加锁成功, 扩容</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">// 改变线程对应的 cell</span><br>h = advanceProbe(h);<br>&#125;<br><span class="hljs-comment">// 还没有 cells, 尝试给 cellsBusy 加锁 else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="hljs-comment">// 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell</span><br><span class="hljs-comment">// 成功则 break;</span><br>&#125;<br><span class="hljs-comment">// 上两种情况失败, 尝试给 base 累加 else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAslong(v, x))))</span><br> <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20220104215525524.png" alt="image-20220104215525524"></p><p><img src="http://image.cryptomartin.top/img/image-20220104215534207.png" alt="image-20220104215534207"></p><p><img src="http://image.cryptomartin.top/img/image-20220104215542435.png" alt="image-20220104215542435"></p><p>获取最终结果通过 sum 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>&#123;<br>Cell[] as = cells;<br>Cell a;<br><span class="hljs-keyword">long</span> sum = base;<br><span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br><span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)<br> sum += a.value;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-4-Unsafe"><a href="#6-4-Unsafe" class="headerlink" title="6.4 Unsafe"></a>6.4 Unsafe</h2><h3 id="6-4-1-概述"><a href="#6-4-1-概述" class="headerlink" title="6.4.1 概述"></a>6.4.1 概述</h3><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestUnsafe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;<br>        Field theUnsafe = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        theUnsafe.setAccessible(<span class="hljs-keyword">true</span>);<br>        Unsafe unsafe= (Unsafe)theUnsafe.get(<span class="hljs-keyword">null</span>);<br><br>        System.out.println(unsafe);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sun.misc.Unsafe@2503dbd3<br></code></pre></td></tr></table></figure><h3 id="6-4-2-Unsafe-CAS-操作"><a href="#6-4-2-Unsafe-CAS-操作" class="headerlink" title="6.4.2 Unsafe CAS 操作"></a>6.4.2 Unsafe CAS 操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestUnsafe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;<br>        Field theUnsafe = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        theUnsafe.setAccessible(<span class="hljs-keyword">true</span>);<br>        Unsafe unsafe = (Unsafe) theUnsafe.get(<span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">// 获得成员变量的偏移量</span><br>        <span class="hljs-keyword">long</span> idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>));<br>        <span class="hljs-keyword">long</span> nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>));<br>        <span class="hljs-comment">// CAS操作</span><br>        Teacher teacher = <span class="hljs-keyword">new</span> Teacher();<br>        unsafe.compareAndSwapInt(teacher, idOffset, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        unsafe.compareAndSwapObject(teacher, nameOffset, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br><br>        <span class="hljs-comment">//验证</span><br>        System.out.println(teacher);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">volatile</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Teacher(id=<span class="hljs-number">1</span>, name=张三)<br></code></pre></td></tr></table></figure><h3 id="6-4-3-Unsafe模拟原子整数"><a href="#6-4-3-Unsafe模拟原子整数" class="headerlink" title="6.4.3 Unsafe模拟原子整数"></a>6.4.3 Unsafe模拟原子整数</h3><p>使用自定义的 AtomicData 实现之前线程安全的原子整数 Account 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicData</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> data;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> DATA_OFFSET;<br><span class="hljs-keyword">static</span> &#123;<br>unsafe = UnsafeAccessor.getUnsafe();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性</span><br>DATA_OFFSET = unsafe.objectFieldOffset(AtomicData.class.getDeclaredField(<span class="hljs-string">&quot;data&quot;</span>));<br>&#125;<br><span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AtomicData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.data = data;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br><span class="hljs-keyword">int</span> oldValue;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-comment">// 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解</span><br>oldValue = data;<br><span class="hljs-comment">// cas 尝试修改 data 为 旧值 + amount，如果期间旧值被别的线程改了，返回 false</span><br><span class="hljs-keyword">if</span> (unsafe.compareAndSwapint(<span class="hljs-keyword">this</span>, DATA_OFFSET, oldValue, oldValue - amount)) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> data;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>account实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Account.demo(<span class="hljs-keyword">new</span> Account() &#123;<br>AtomicData atomicData = <span class="hljs-keyword">new</span> AtomicData(<span class="hljs-number">10000</span>);<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> atomicData.getData();<br>&#125;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>atomicData.decrease(amount);<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="6-5-本章小结"><a href="#6-5-本章小结" class="headerlink" title="6.5 本章小结"></a>6.5 本章小结</h2><ul><li>CAS 与 volatile</li><li>API<ul><li>原子整数</li><li>原子引用</li><li>原子数组</li><li>字段更新器</li><li>原子累加器</li></ul></li><li>Unsafe</li><li>*原理方面<ul><li>LongAdder 源码</li><li>伪共享</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第五章 共享模型之内存</title>
    <link href="/2022/02/01/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98/"/>
    <url>/2022/02/01/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="第五章-共享模型之内存"><a href="#第五章-共享模型之内存" class="headerlink" title="第五章 共享模型之内存"></a>第五章 共享模型之内存</h1><p>上一章讲解的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性</p><p>这一章我们进一步深入学习共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题</p><h2 id="5-1-Java内存模型"><a href="#5-1-Java内存模型" class="headerlink" title="5.1 Java内存模型"></a>5.1 Java内存模型</h2><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。主要是简化复杂的底层的管理。</p><blockquote><p>主存：指所有线程共享的数据，包括静态成员变量，成员变量等<br>工作内存：指每个线程私有的数据，对应局部变量。</p></blockquote><p>JMM 体现在以下几个方面：</p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h2 id="5-2-可见性"><a href="#5-2-可见性" class="headerlink" title="5.2 可见性"></a>5.2 可见性</h2><h3 id="5-2-1-引出问题-退不出的循环"><a href="#5-2-1-引出问题-退不出的循环" class="headerlink" title="5.2.1 引出问题-退不出的循环"></a>5.2.1 引出问题-退不出的循环</h3><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Thread t = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">while</span>(run)&#123;<br><span class="hljs-comment">// ....</span><br>&#125;<br>&#125;<br>);<br>    <br>t.start();<br>sleep(<span class="hljs-number">1</span>);<br>run = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 线程t不会如预想的停下来</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-2-分析问题"><a href="#5-2-2-分析问题" class="headerlink" title="5.2.2 分析问题"></a>5.2.2 分析问题</h3><p>为什么呢？分析一下：</p><ol><li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。<br><img src="http://image.cryptomartin.top/img/image-20220101095311191.png" alt="image-20220101095311191"></li></ol><ol start="2"><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至t线程工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率<br><img src="http://image.cryptomartin.top/img/image-20220101095504243.png" alt="image-20220101095504243"></li></ol><ol start="3"><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li></ol><p><img src="http://image.cryptomartin.top/img/image-20220101095705858.png" alt="image-20220101095705858"></p><h3 id="5-2-3-解决问题"><a href="#5-2-3-解决问题" class="headerlink" title="5.2.3 解决问题"></a>5.2.3 解决问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<br></code></pre></td></tr></table></figure><p><code>volatile</code>（易变关键字）</p><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p><p>也可以用<code>sychronized</code>,但是<code>sychronized</code>会创建monitor，实在属于重量级。而<code>volatile</code>属于轻量级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Thread t = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>sychronized(lock)&#123;<br>                <span class="hljs-keyword">if</span>(!run)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>&#125;<br>&#125;);<br>    <br>t.start();<br>sleep(<span class="hljs-number">1</span>);<br>    sychronized(lock)&#123;<br>        run = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-4-可见性与原子性"><a href="#5-2-4-可见性与原子性" class="headerlink" title="5.2.4 可见性与原子性"></a>5.2.4 可见性与原子性</h3><p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况。</p><p>上例从字节码理解是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic run <span class="hljs-comment">// 线程 t 获取 run true </span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true </span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true </span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true </span><br>putstatic run <span class="hljs-comment">// 线程 main 修改 run 为 false， 仅此一次</span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run false</span><br></code></pre></td></tr></table></figure><p>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到最新值，不能解决指令交错:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0 </span><br>getstatic i <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0 </span><br>    <br>getstatic i <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0 </span><br>iconst_1 <span class="hljs-comment">// 线程1-准备常量1 </span><br>iadd <span class="hljs-comment">// 线程1-自增 线程内i=1 </span><br>putstatic i <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1 </span><br>    <br>iconst_1 <span class="hljs-comment">// 线程2-准备常量1 </span><br>isub <span class="hljs-comment">// 线程2-自减 线程内i=-1 </span><br>putstatic i <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是</p><p>synchronized 是属于重量级操作，性能相对更低</p><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到</p><p>对 run 变量的修改了，想一想为什么？println()调用newLine(),newLine()中使用了synchronized。</p></blockquote><p><img src="http://image.cryptomartin.top/img/image-20220101103206363.png" alt="image-20220101103206363"></p><p><img src="http://image.cryptomartin.top/img/image-20220101103223788.png" alt="image-20220101103223788"></p><h3 id="5-2-5-【模式】模式之两阶段终止"><a href="#5-2-5-【模式】模式之两阶段终止" class="headerlink" title="5.2.5 【模式】模式之两阶段终止"></a>5.2.5 【模式】模式之两阶段终止</h3><p> 利用停止标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//监控类</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTermination2</span> </span>&#123;<br>    <span class="hljs-comment">// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</span><br>    <span class="hljs-comment">// 我们的例子中，即主线程把它修改为 true 对 t1 线程可见</span><br>    <span class="hljs-keyword">private</span> Thread monitor;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">//开启监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">//不断执行</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (stop) &#123;<br>                    <span class="hljs-comment">//如果被打断</span><br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//如果当前线程没有被打断,睡眠1秒</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    <span class="hljs-comment">//没被打断，且没有异常；记录日志</span><br>                    log.debug(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//开启线程</span><br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">//停止监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        stop = <span class="hljs-keyword">true</span>;<br>        monitor.interrupt(); <span class="hljs-comment">//sleep中，打断sleep</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        TwoPhaseTermination2 tpt = <span class="hljs-keyword">new</span> TwoPhaseTermination2();<br>        tpt.start();<br><br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        log.debug(<span class="hljs-string">&quot;停止监控&quot;</span>);<br>        tpt.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">16</span>:<span class="hljs-number">46</span>:<span class="hljs-number">49</span> [Thread-<span class="hljs-number">0</span>] c.TwoPhaseTermination - 执行监控记录<br><span class="hljs-number">16</span>:<span class="hljs-number">46</span>:<span class="hljs-number">50</span> [Thread-<span class="hljs-number">0</span>] c.TwoPhaseTermination - 执行监控记录<br><span class="hljs-number">16</span>:<span class="hljs-number">46</span>:<span class="hljs-number">51</span> [Thread-<span class="hljs-number">0</span>] c.TwoPhaseTermination - 执行监控记录<br><span class="hljs-number">16</span>:<span class="hljs-number">46</span>:<span class="hljs-number">51</span> [main] c.Test3 - 停止监控<br><span class="hljs-number">16</span>:<span class="hljs-number">46</span>:<span class="hljs-number">51</span> [Thread-<span class="hljs-number">0</span>] c.TwoPhaseTermination - 料理后事<br></code></pre></td></tr></table></figure><h3 id="5-2-6-【模式】同步模式之Balking"><a href="#5-2-6-【模式】同步模式之Balking" class="headerlink" title="5.2.6 【模式】同步模式之Balking"></a>5.2.6 【模式】同步模式之Balking</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;<br>        TwoPhaseTermination2 tpt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TwoPhaseTermination2</span>();<br>        tpt.<span class="hljs-built_in">start</span>();<br>        tpt.<span class="hljs-built_in">start</span>();<br><br>        Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">3500</span>);<br>        log.<span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;停止监控&quot;</span>);<br>        tpt.<span class="hljs-built_in">stop</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><p>tpt启动了两次，就会出现线程安全问题。</p><h4 id="5-2-6-1定义"><a href="#5-2-6-1定义" class="headerlink" title="5.2.6.1定义"></a>5.2.6.1定义</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p><h4 id="5-2-6-2-实现"><a href="#5-2-6-2-实现" class="headerlink" title="5.2.6.2 实现"></a>5.2.6.2 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTermination2</span> </span>&#123;<br>    <span class="hljs-comment">// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</span><br>    <span class="hljs-comment">// 我们的例子中，即主线程把它修改为 true 对 t1 线程可见</span><br>    <span class="hljs-keyword">private</span> Thread monitor;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">//判断是否执行过start()方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">//开启监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//        if (starting) &#123; //t1:false,t2:false.对此代码做保护。volatile可不可以用？不行，两个线程都是先读再写，还是会有线程安全问题。保证原子性而不是可见性。</span><br><span class="hljs-comment">//            return;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        starting = true;</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123; <span class="hljs-comment">//t1:false,t2:false.对此代码做保护。</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            starting = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        monitor = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;...&#125;);<br>        <span class="hljs-comment">//开启线程</span><br>        monitor.start();<br>    &#125;<br>    ...<br>&#125;    <br></code></pre></td></tr></table></figure><h4 id="5-2-6-3-应用1-web-开始按钮"><a href="#5-2-6-3-应用1-web-开始按钮" class="headerlink" title="5.2.6.3 应用1-web 开始按钮"></a>5.2.6.3 应用1-web 开始按钮</h4><p>当前端页面多次点击按钮调用 start 时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonitorService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> starting; <br>    <span class="hljs-keyword">private</span> Thread monitorThread;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 缩小同步范围，提升性能</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;该监控线程已启动?(&#123;&#125;)&quot;</span>, starting);<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            starting = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 由于之前的 balking 模式，以下代码只可能被一个线程执行，因此无需互斥</span><br>        monitorThread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (!stop) &#123;<br>                report();<br>                sleep(<span class="hljs-number">2</span>);<br>            &#125;<br>            <span class="hljs-comment">// 这里的监控线程只可能启动一个，因此只需要用 volatile 保证 starting 的可见性</span><br>            log.info(<span class="hljs-string">&quot;监控线程已停止...&quot;</span>);<br>            starting = <span class="hljs-keyword">false</span>;<br>        &#125;);<br><br>        stop = <span class="hljs-keyword">false</span>;<br>        log.info(<span class="hljs-string">&quot;监控线程已启动...&quot;</span>);<br>        monitorThread.start();<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-6-4-应用2-单例模式DCL"><a href="#5-2-6-4-应用2-单例模式DCL" class="headerlink" title="5.2.6.4 应用2-单例模式DCL"></a>5.2.6.4 应用2-单例模式DCL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br>    <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//balking模式，synchronized保证只创建一个。</span><br><span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>        <br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对比一下保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待。</p></blockquote><h2 id="5-3-有序性"><a href="#5-3-有序性" class="headerlink" title="5.3 有序性"></a>5.3 有序性</h2><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j;<br><span class="hljs-comment">// 在某个线程内执行如下赋值操作</span><br>i = ...; <br>j = ...;<br></code></pre></td></tr></table></figure><p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">i = ...; <br>j = ...;<br></code></pre></td></tr></table></figure><p>也可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">j = ...;<br>i = ...;<br></code></pre></td></tr></table></figure><p>这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。为什么要有重排指令这项优化呢？从 CPU</p><p>执行指令的原理来理解一下吧</p><h3 id="5-3-1-原理之指令级并行"><a href="#5-3-1-原理之指令级并行" class="headerlink" title="5.3.1 * 原理之指令级并行"></a>5.3.1 * 原理之指令级并行</h3><p>看《Java 并发编程的艺术》P21-P47</p><h3 id="5-3-2-指令重排导致诡异的结果"><a href="#5-3-2-指令重排导致诡异的结果" class="headerlink" title="5.3.2 指令重排导致诡异的结果"></a>5.3.2 指令重排导致诡异的结果</h3><p><strong>问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>Boolean ready = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(ready) &#123;<br>r.r1 = num + num;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r.r1 = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>num = <span class="hljs-number">2</span>;<br>ready = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？</p><p>有同学这么分析<br>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1<br>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1<br>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</p><p>但我告诉你，结果还有可能是 0 😁😁😁，信不信吧！<br>这种情况下是：线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2<br>相信很多人已经晕了 😵😵😵<br>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化。</p><p><strong>解决方法</strong></p><p>volatile 修饰的变量，可以禁用指令重排</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">volatile</span> Boolean ready = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(ready) &#123;<br>r.r1 = num + num;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r.r1 = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>num = <span class="hljs-number">2</span>;<br>ready = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>问：为什么不加在<code>int num=0;</code>上？</p><p>答：volatile 修饰 ready,在<code>ready=true;</code>之后会有写屏障，会保证它之前的代码不会排到它后面。所以加一个就行。</p></blockquote><h3 id="5-3-3-原理之-volatile"><a href="#5-3-3-原理之-volatile" class="headerlink" title="5.3.3 ***** 原理之 volatile"></a>5.3.3 ***** <strong>原理之</strong> volatile</h3><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence） </p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h4 id="5-3-3-1-如何保证可见性"><a href="#5-3-3-1-如何保证可见性" class="headerlink" title="5.3.3.1 如何保证可见性"></a>5.3.3.1 如何保证可见性</h4><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>num = <span class="hljs-number">2</span>;<br>ready = <span class="hljs-keyword">true</span>;<br><span class="hljs-comment">// ready 是 volatile 赋值带写屏障</span><br><span class="hljs-comment">// 赋值操作之后，加入一个写屏障；写屏障会把num和ready同步到主存中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br><span class="hljs-comment">// 读屏障</span><br><span class="hljs-comment">// ready 是 volatile 读取值带读屏障</span><br><span class="hljs-keyword">if</span>(ready) &#123;<br>r.r1 = num + num;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r.r1 = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20220103101002856.png" alt="image-20220103101002856"></p><h4 id="5-3-3-2-如何保证有序性"><a href="#5-3-3-2-如何保证有序性" class="headerlink" title="5.3.3.2 如何保证有序性"></a>5.3.3.2 如何保证有序性</h4><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后；</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前；</li></ul><p>但不能解决指令交错：</p><ul><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li><li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li></ul><p><img src="http://image.cryptomartin.top/img/image-20220103101558672.png" alt="image-20220103101558672"></p><blockquote><p>volatile只能保证有序性和可见性，不能保证原子性；</p><p>synchronized可以保证有序性、可见性、原子性。synchronized内部仍然会重排序。</p></blockquote><h4 id="5-3-3-3-double-checked-locking-问题"><a href="#5-3-3-3-double-checked-locking-问题" class="headerlink" title="5.3.3.3 double-checked locking 问题"></a>5.3.3.3 double-checked locking 问题</h4><p>以著名的 double-checked locking 单例模式为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// t2</span><br><span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span><br><span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br><span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// t1</span><br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的实现特点是：</p><ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li></ul><p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">3</span>: ifnonnull <span class="hljs-number">37</span><br><span class="hljs-number">6</span>: ldc #<span class="hljs-number">3</span> <span class="hljs-comment">// class cn/itcast/n5/Singleton</span><br><span class="hljs-number">8</span>: dup <span class="hljs-comment">//赋值一份类的引用指针，为了解锁用</span><br><span class="hljs-number">9</span>: astore_0 <br><span class="hljs-number">10</span>: monitorenter <span class="hljs-comment">//创建monitor对象，看看有没有owner,进行竞争</span><br><span class="hljs-number">11</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">14</span>: ifnonnull <span class="hljs-number">27</span><br><span class="hljs-number">17</span>: <span class="hljs-keyword">new</span> #<span class="hljs-number">3</span> <span class="hljs-comment">// class cn/itcast/n5/Singleton</span><br><span class="hljs-number">20</span>: dup <span class="hljs-comment">//赋值引用</span><br><span class="hljs-number">21</span>: invokespecial #<span class="hljs-number">4</span> <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V ;通过引用创建构造方法</span><br><span class="hljs-number">24</span>: putstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton; 将new Singleton()的引用指针赋值给静态变量INSTANCE</span><br><span class="hljs-number">27</span>: aload_0<br><span class="hljs-number">28</span>: monitorexit<br><span class="hljs-number">29</span>: goto <span class="hljs-number">37</span><br><span class="hljs-number">32</span>: astore_1<br><span class="hljs-number">33</span>: aload_0<br><span class="hljs-number">34</span>: monitorexit<br><span class="hljs-number">35</span>: aload_1<br><span class="hljs-number">36</span>: athrow<br><span class="hljs-number">37</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">40</span>: areturn<br></code></pre></td></tr></table></figure><p>其中</p><ul><li>17 表示创建对象，将对象引用入栈 // new Singleton</li><li>20 表示复制一份对象引用 // 引用地址</li><li>21 表示利用一个对象引用，调用构造方法</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><blockquote><p>临界区内部还会进行指令重排序，临界区只保证临界区执行前后的指令不会重排序</p><p>INSTANCE = new Singleton(); </p><p>说人话就是：</p><p>a.JVM为对象分配一块内存M</p><p>b.在内存M上为对象进行初始化</p><p>c.将内存的地址复制给singleton变量</p></blockquote><p><a href="https://juejin.cn/post/6844903920599302152">文章写得很清楚关于为什么要加volatile</a></p><p>也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：</p><p><img src="http://image.cryptomartin.top/img/image-20220103145517349.png" alt="image-20220103145517349"></p><p>关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取INSTANCE 变量的值</p><p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例</p><p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p><blockquote><p>完全把共享变量交给synchronized来管理，不会有 有序性问题的。</p><p>上面例子，共享变量没有完全被synchronized的保护。</p></blockquote><h4 id="5-3-3-4-double-checked-locking-解决-加volatile"><a href="#5-3-3-4-double-checked-locking-解决-加volatile" class="headerlink" title="5.3.3.4 double-checked locking 解决-加volatile"></a>5.3.3.4 double-checked locking 解决-加volatile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span><br><span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br><span class="hljs-comment">// t2</span><br><span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次</span><br><span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// t1</span><br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码上看不出来 volatile 指令的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障</span><br><span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br>    <span class="hljs-number">3</span>: ifnonnull <span class="hljs-number">37</span><br><span class="hljs-number">6</span>: ldc #<span class="hljs-number">3</span> <span class="hljs-comment">// class cn/itcast/n5/Singleton</span><br><span class="hljs-number">8</span>: dup<br><span class="hljs-number">9</span>: astore_0<br><span class="hljs-number">10</span>: monitorenter -----------------------&gt; 保证原子性、可见性<br><span class="hljs-number">11</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">14</span>: ifnonnull <span class="hljs-number">27</span><br><span class="hljs-number">17</span>: <span class="hljs-keyword">new</span> #<span class="hljs-number">3</span> <span class="hljs-comment">// class cn/itcast/n5/Singleton</span><br><span class="hljs-number">20</span>: dup<br><span class="hljs-number">21</span>: invokespecial #<span class="hljs-number">4</span> <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-number">24</span>: putstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障</span><br><span class="hljs-number">27</span>: aload_0<br><span class="hljs-number">28</span>: monitorexit ------------------------&gt; 保证原子性、可见性<br><span class="hljs-number">29</span>: goto <span class="hljs-number">37</span><br><span class="hljs-number">32</span>: astore_1<br><span class="hljs-number">33</span>: aload_0<br><span class="hljs-number">34</span>: monitorexit<br><span class="hljs-number">35</span>: aload_1<br><span class="hljs-number">36</span>: athrow<br><span class="hljs-number">37</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">40</span>: areturn<br></code></pre></td></tr></table></figure><p>如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点：</p><p>可见性</p><ul><li>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中</li><li>而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li></ul><p>有序性</p><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul><p>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性</p><p><img src="http://image.cryptomartin.top/img/image-20220103150835646.png" alt="image-20220103150835646"></p><h3 id="5-3-4-happens-before"><a href="#5-3-4-happens-before" class="headerlink" title="5.3.4 happens-before"></a>5.3.4 happens-before</h3><p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><ul><li>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">static</span> Object m = <span class="hljs-keyword">new</span> Object();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">synchronized</span>(m) &#123;<br>x = <span class="hljs-number">10</span>;<br>&#125;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">synchronized</span>(m) &#123;<br>System.out.println(x);<br>&#125;<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><ul><li>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><ul><li>线程 start 前对变量的写，对该线程开始后对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x; <br>x = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><ul><li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br>t1.join();<br>System.out.println(x);<br></code></pre></td></tr></table></figure><ul><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <br>Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>System.out.println(x);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br>    <br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>sleep(<span class="hljs-number">1</span>);<br>x = <span class="hljs-number">10</span>;<br>t2.interrupt();<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>    <br><span class="hljs-keyword">while</span>(!t2.isInterrupted()) &#123;<br>Thread.yield();<br>&#125;<br>System.out.println(x);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p></li><li><p>具有传递性，如果 <code>x hb-&gt; y</code> 并且 <code>y hb-&gt; z</code> 那么有 <code>x hb-&gt; z</code> ，配合 volatile 的防指令重排，有下面的例子</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> y;<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123; <br> y = <span class="hljs-number">10</span>;<br> x = <span class="hljs-number">20</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> <span class="hljs-comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见</span><br> System.out.println(x); <br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start()<br></code></pre></td></tr></table></figure><h2 id="5-4-习题"><a href="#5-4-习题" class="headerlink" title="5.4 习题"></a>5.4 习题</h2><h3 id="5-4-1-balking-模式习题"><a href="#5-4-1-balking-模式习题" class="headerlink" title="5.4.1 balking 模式习题"></a>5.4.1 balking 模式习题</h3><p>希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestVolatile</span> </span>&#123;<br><span class="hljs-keyword">volatile</span> Boolean initialized = <span class="hljs-keyword">false</span>;<br>    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (initialized) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>doInit();<br>initialized = <span class="hljs-keyword">true</span>;<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInit</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不能。volatile仅保证可见性有序性，不能保证原子性。</p><h3 id="5-4-2-线程安全单例习题"><a href="#5-4-2-线程安全单例习题" class="headerlink" title="5.4.2 线程安全单例习题"></a>5.4.2 线程安全单例习题</h3><p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance）时的线程安全，并思考注释中的问题</p><blockquote><p>饿汉式：类加载就会导致该单实例对象被创建<br>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></blockquote><p>实现1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：为什么加 final?因为怕子类不适当覆盖父类的方法，重写方法破坏单例</span><br><span class="hljs-comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例？实现了序列化接口，将来反序列化也会创建新对象。会破坏单例。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><span class="hljs-comment">// 问题3：为什么设置为私有? 是否能防止反射创建新的实例?防止别的类创建对象；不能，可以暴力反射。</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><span class="hljs-comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?能，静态成员变量是在类加载时完成的，线程安全的。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br><span class="hljs-comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。用方法封装可以实现更多的控制。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//问题2解决。反序列化时会调用readResolve()，重写此方法返回我们创建的单例。</span><br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：枚举单例是如何限制实例个数的--枚举类，静态成员变量。</span><br><span class="hljs-comment">// 问题2：枚举单例在创建时是否有并发问题--在类加载时完成的，线程安全。</span><br><span class="hljs-comment">// 问题3：枚举单例能否被反射破坏单例--不能</span><br><span class="hljs-comment">// 问题4：枚举单例能否被反序列化破坏单例--不能</span><br><span class="hljs-comment">// 问题5：枚举单例属于懒汉式还是饿汉式--饿汉式，类加载时完成</span><br><span class="hljs-comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做--加构造方法</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123; <br> INSTANCE; <br>&#125;<br></code></pre></td></tr></table></figure><p>实现3：懒汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">// 分析这里的线程安全, 并说明有什么缺点--锁粒度大，性能低</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>( INSTANCE != <span class="hljs-keyword">null</span> )&#123;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现4：DCL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><span class="hljs-comment">// 问题1：解释为什么要加 volatile ?--创建对象时，可能指令重排序。加volatile防止synchronized内指令重排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">// 问题2：对比实现3, 说出这样做的意义 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br><span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br><span class="hljs-comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗</span><br><span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// t2 </span><br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现5：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><span class="hljs-comment">// 问题1：属于懒汉式还是饿汉式--懒汉式</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>&#123;<span class="hljs-comment">//静态内部类</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>&#125;<br><span class="hljs-comment">// 问题2：在创建时是否有并发问题--</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-5-本章小结"><a href="#5-5-本章小结" class="headerlink" title="5.5 本章小结"></a>5.5 本章小结</h2><p>本章重点讲解了 JMM 中的</p><ul><li>可见性 - 由 JVM 缓存优化引起</li><li>有序性 - 由 JVM 指令重排序优化引起</li><li>happens-before 规则</li><li>原理方面<ul><li>CPU 指令并行</li><li>volatile</li></ul></li><li>模式方面<ul><li>两阶段终止模式的 volatile 改进</li><li>同步模式之 balking</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四章 共享模型之管程</title>
    <link href="/2021/12/31/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B/"/>
    <url>/2021/12/31/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第四章-共享模型之管程"><a href="#第四章-共享模型之管程" class="headerlink" title="第四章 共享模型之管程"></a>第四章 共享模型之管程</h1><p><strong>本章内容</strong></p><ul><li>共享问题</li><li>synchronized</li><li>线程安全分析</li><li>Monitor</li><li>wait/notify</li><li>线程状态转换</li><li>活跃性</li><li>Lock</li></ul><h2 id="4-1-共享带来的问题以及分析"><a href="#4-1-共享带来的问题以及分析" class="headerlink" title="4.1 共享带来的问题以及分析"></a>4.1 共享带来的问题以及分析</h2><h3 id="4-1-1-线程安全问题"><a href="#4-1-1-线程安全问题" class="headerlink" title="4.1.1 线程安全问题"></a>4.1.1 线程安全问题</h3><p><img src="http://image.cryptomartin.top/img/image-20211220230105719.png" alt="image-20211220230105719"></p><p><img src="http://image.cryptomartin.top/img/image-20211220230304785.png" alt="image-20211220230304785"></p><h3 id="4-1-2-上下文切换-分析"><a href="#4-1-2-上下文切换-分析" class="headerlink" title="4.1.2 上下文切换-分析"></a>4.1.2 上下文切换-分析</h3><p>两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？–不一定是0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            counter++;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            counter--;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>    <br>    t1.start();<br>    t2.start();<br>    t1.join();<br>    t2.join();<br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, counter);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">23</span>:<span class="hljs-number">05</span>:<span class="hljs-number">50</span><span class="hljs-meta"> [main] c.Test17 - 43</span><br></code></pre></td></tr></table></figure><hr><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理解，必须从字节码来进行分析</p><p>例如对于<code>i++</code> 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic i <span class="hljs-comment">// 获取静态变量i的值</span><br>iconst_1 <span class="hljs-comment">// 准备常量1</span><br>iadd <span class="hljs-comment">// 自增</span><br>putstatic i <span class="hljs-comment">// 将修改后的值存入静态变量i</span><br></code></pre></td></tr></table></figure><p>而对应 <code>i--</code> 也是类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic i <span class="hljs-comment">// 获取静态变量i的值</span><br>iconst_1 <span class="hljs-comment">// 准备常量1</span><br>isub <span class="hljs-comment">// 自减</span><br>putstatic i <span class="hljs-comment">// 将修改后的值存入静态变量i</span><br></code></pre></td></tr></table></figure><p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：</p><p><img src="http://image.cryptomartin.top/img/image-20211220231346817.png" alt="image-20211220231346817"></p><p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：</p><p><img src="http://image.cryptomartin.top/img/image-20211220231419050.png" alt="image-20211220231419050"></p><p>但多线程下这 8 行代码可能交错运行：<br>出现负数的情况：</p><p><img src="http://image.cryptomartin.top/img/image-20211220231502024.png" alt="image-20211220231502024"></p><h3 id="4-1-3-临界区与竞态条件"><a href="#4-1-3-临界区与竞态条件" class="headerlink" title="4.1.3 临界区与竞态条件"></a>4.1.3 临界区与竞态条件</h3><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问共享资源<ul><li>多个线程读共享资源其实也没有问题</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区(Critical Section)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<span class="hljs-comment">//共享资源</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区</span></span><br><span class="hljs-function"></span>&#123;<br>counter++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区</span></span><br><span class="hljs-function"></span>&#123;<br>counter--;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>竞态条件</strong></p><p>多个线程在临界区内执行，由于代码的<strong>执行序列不同</strong>而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h2 id="4-2-解决共享带来的问题-synchronized解决方案"><a href="#4-2-解决共享带来的问题-synchronized解决方案" class="headerlink" title="4.2 解决共享带来的问题-synchronized解决方案"></a>4.2 解决共享带来的问题-synchronized解决方案</h2><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p><blockquote><p>注意<br>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li><li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li></ul></blockquote><h3 id="4-2-1-synchronized"><a href="#4-2-1-synchronized" class="headerlink" title="4.2.1 synchronized"></a>4.2.1 synchronized</h3><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) <span class="hljs-comment">// 线程1， 线程2(blocked)</span><br>&#123;<br> 临界区<br>&#125;<br></code></pre></td></tr></table></figure><p>解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test17&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test17</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//必须有一个共享的对象。因为synchronized关键字加锁必须由多个线程共享的对象来完成的。</span><br>    <span class="hljs-keyword">static</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-comment">//加锁</span><br>                <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                    counter++;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-comment">//加锁</span><br>                <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                    counter--;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, counter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>必须有一个共享的对象lock。因为synchronized关键字加锁必须由多个线程共享的对象来完成的。</li></ul><h3 id="4-2-2-synchronized的底层原理分析"><a href="#4-2-2-synchronized的底层原理分析" class="headerlink" title="4.2.2 synchronized的底层原理分析"></a>4.2.2 synchronized的底层原理分析</h3><p><img src="http://image.cryptomartin.top/img/image-20211221110418763.png" alt="image-20211221110418763"></p><p><strong>思考</strong></p><p>synchronized 实际是用<code>对象锁</code>保证了<code>临界区内代码的原子性</code>，临界区内的代码对外是不可分割的，不会被线程切<br>换所打断。</p><p>为了加深理解，请思考下面的问题:</p><ul><li>如果把 <code>synchronized(obj)</code> 放在 for 循环的外面，如何理解？– 原子性</li><li>如果 t1 <code>synchronized(obj1)</code> 而 <code>t2 synchronized(obj2)</code> 会怎样运作？不行。– 锁对象</li><li>如果 t1 <code>synchronized(obj)</code> 而 t2 没有加会怎么样？如何理解？不行– 锁对象</li></ul><h3 id="4-2-3-面向对象改进"><a href="#4-2-3-面向对象改进" class="headerlink" title="4.2.3 面向对象改进"></a>4.2.3 面向对象改进</h3><p>把需要保护的共享变量放入一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test17&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test17</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//创建Room对象</span><br>        Room room = <span class="hljs-keyword">new</span> Room();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-comment">//调用room的increment方法</span><br>                room.increment();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-comment">//调用room对象的decrement方法</span><br>                room.decrement();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, room.getCount());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Room</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            count--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-4-synchronized放在方法上"><a href="#4-2-4-synchronized放在方法上" class="headerlink" title="4.2.4 synchronized放在方法上"></a>4.2.4 synchronized放在方法上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br>&#125;<br>等价于<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br>&#125;<br>等价于<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(Test.class) &#123;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>public synchronized void test()</code>：<code>synchronized</code>加在非静态方法上，锁住的是<code>this对象</code></p></li><li><p><code>public synchronized static void test()</code>:<code>synchronized</code>加在静态方法上，锁住的是<code>类对象</code></p></li><li><p><code>this对象</code>是this所在方法的类对象，只有一个实例对象；<code>类对象</code>是整个类，可以有多个对象。synchronized修饰不加static的方法，锁是加在单个对象上，不同的对象没有竞争关系；修饰加了static的方法，锁是加载类上，这个类所有的对象竞争一把锁。</p></li></ul><h3 id="4-2-5-练习题-”线程八锁“"><a href="#4-2-5-练习题-”线程八锁“" class="headerlink" title="4.2.5 练习题-”线程八锁“"></a>4.2.5 练习题-”线程八锁“</h3><p>其实就是考察 synchronized 锁住的是哪个对象</p><h4 id="情况1：非静态方法加锁"><a href="#情况1：非静态方法加锁" class="headerlink" title="情况1：非静态方法加锁"></a>情况1：非静态方法加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test8Locks&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test8Locks</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Number n1 = <span class="hljs-keyword">new</span> Number();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 两个线程锁住的是同一个对象</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;开始线程&quot;</span>);<br>            n1.a();<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;开始线程&quot;</span>);<br>            n1.b();<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 为非static方法，锁住的是this对象-&gt;Number对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">11:41:27 [Thread-1] c.Test8Locks - 开始线程<br>11:41:27 [Thread-0] c.Test8Locks - 开始线程<br>11:41:27 [Thread-1] c.Number - 2<br>11:41:27 [Thread-0] c.Number - 1<br></code></pre></td></tr></table></figure><p>ps: <code>a()</code> 方法，<code>b()</code>方法加上了<code>synchronized</code></p><p>可能的结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">12或者21<br></code></pre></td></tr></table></figure><h4 id="情况2：添加sleep"><a href="#情况2：添加sleep" class="headerlink" title="情况2：添加sleep"></a>情况2：添加sleep</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Number n1 = <span class="hljs-keyword">new</span> Number();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>n1.a();<br>&#125;<br>).start();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>n1.b();<br>&#125;<br>).start();<br>&#125;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>sleep(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:在情况1的基础上，给<code>a()</code>方法睡眠了1秒钟</p><p>可能的结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1秒后 1 2<br>2 1秒后 1<br></code></pre></td></tr></table></figure><h4 id="情况3：添加一个c方法，不加锁"><a href="#情况3：添加一个c方法，不加锁" class="headerlink" title="情况3：添加一个c方法，不加锁"></a>情况3：添加一个c方法，不加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Number n1 = <span class="hljs-keyword">new</span> Number();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.b(); &#125;).start();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.c(); &#125;).start();<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;3&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps: 在情况3的基础上加了<code>c()</code>方法，没有加<code>synchronized</code></p><p>可能的结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">3 1秒后 12<br>32 1秒后 1<br>23 1秒后 1<br></code></pre></td></tr></table></figure><h4 id="情况4：两个线程调用不同的对象"><a href="#情况4：两个线程调用不同的对象" class="headerlink" title="情况4：两个线程调用不同的对象"></a>情况4：两个线程调用不同的对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Number n1 = <span class="hljs-keyword">new</span> Number();<br> Number n2 = <span class="hljs-keyword">new</span> Number();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:在情况2的基础上，创建一个新的Number对象。两个对象，锁住的对象不是同一个对象</p><p>可能的结果只有一种:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">2 1秒后 1<br></code></pre></td></tr></table></figure><h4 id="情况5：synchronized加在静态方法和非静态方法上"><a href="#情况5：synchronized加在静态方法和非静态方法上" class="headerlink" title="情况5：synchronized加在静态方法和非静态方法上"></a>情况5：synchronized加在静态方法和非静态方法上</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Number n1 = <span class="hljs-keyword">new</span> Number();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.b(); &#125;).start();<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:<code>a()</code>方法为非静态方法；<code>a()</code>方法锁住的是<code>整个Number对象</code>；而<code>b()</code>方法锁住的是<code>n1实例对象</code>;两个锁住的不是同一个对象</p><p>只有一种结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">2 1秒后 1<br></code></pre></td></tr></table></figure><h4 id="情况6：synchronized加在同一个类中的两个静态方法上"><a href="#情况6：synchronized加在同一个类中的两个静态方法上" class="headerlink" title="情况6：synchronized加在同一个类中的两个静态方法上"></a>情况6：synchronized加在同一个类中的两个静态方法上</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Number n1 = <span class="hljs-keyword">new</span> Number();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.b(); &#125;).start();<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps: <code>synchronized</code>加载非静态方法<code>a()</code>方法和<code>b()</code>方法上，则锁住的是同一个类对象<code>Number类对象</code>，类对象整个内存中只有一份。</p><p>可能的结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1秒后 12<br>2 1秒后 1<br></code></pre></td></tr></table></figure><h4 id="情况7：synchronized加在静态方法和非静态方法上，两个线程各自调用两个不同的实例"><a href="#情况7：synchronized加在静态方法和非静态方法上，两个线程各自调用两个不同的实例" class="headerlink" title="情况7：synchronized加在静态方法和非静态方法上，两个线程各自调用两个不同的实例"></a>情况7：synchronized加在静态方法和非静态方法上，两个线程各自调用两个不同的实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Number n1 = <span class="hljs-keyword">new</span> Number();<br> Number n2 = <span class="hljs-keyword">new</span> Number();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:<code>a()</code>方法是静态方法，锁住的是<code>Number类对象</code>；<code>b()</code>方法非静态方法，锁住的是<code>this对象</code>-&gt;<code>n2对象</code>；连个锁住的不是同一个对象</p><p>唯一的结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">2 1秒后 1<br></code></pre></td></tr></table></figure><h4 id="情况8：synchronized加在两个静态方法，两个线程各自调用两个不同的实例"><a href="#情况8：synchronized加在两个静态方法，两个线程各自调用两个不同的实例" class="headerlink" title="情况8：synchronized加在两个静态方法，两个线程各自调用两个不同的实例"></a>情况8：synchronized加在两个静态方法，两个线程各自调用两个不同的实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Number n1 = <span class="hljs-keyword">new</span> Number();<br> Number n2 = <span class="hljs-keyword">new</span> Number();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:<code>a()</code>方法，<code>b()</code>方法都是<code>static</code>,<code>synchronized</code>锁住的是<code>Number类对象</code>，为同一个对象；虽然创建了<code>n1</code>，<code>n2</code>对象，但是<code>线程1</code>调用时，锁住的是<code>Number类对象</code>，只有一个；由此可知，<code>线程2</code>调用时，锁住的是<code>Number类对象</code></p><p>可能的结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1秒后 1 2<br>2 1秒后 1<br></code></pre></td></tr></table></figure><h2 id="4-3-变量的线程安全分析"><a href="#4-3-变量的线程安全分析" class="headerlink" title="4.3 变量的线程安全分析"></a>4.3 变量的线程安全分析</h2><h3 id="4-3-1-线程安全分析"><a href="#4-3-1-线程安全分析" class="headerlink" title="4.3.1 线程安全分析"></a>4.3.1 线程安全分析</h3><p><strong>成员变量和静态变量是否线程安全？</strong></p><ul><li><p>如果没有变量没有在线程间共享，那么变量是安全的</p></li><li><p>如果变量在线程间共享</p><ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h3 id="4-3-2-局部变量是否线程安全？"><a href="#4-3-2-局部变量是否线程安全？" class="headerlink" title="4.3.2 局部变量是否线程安全？"></a>4.3.2 局部变量是否线程安全？</h3><ul><li>局部变量是线程安全的</li><li>但局部变量引用的对象则未必<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><p><strong>局部变量线程安全分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown">public static void test1();<br>descriptor: ()V<br> flags: ACC<span class="hljs-emphasis">_PUBLIC, ACC_</span>STATIC<br> Code:<br> stack=1, locals=1, args<span class="hljs-emphasis">_size=0</span><br><span class="hljs-emphasis"> 0: bipush 10</span><br><span class="hljs-emphasis"> 2: istore_</span>0<br> 3: iinc 0, 1<br> 6: return<br> LineNumberTable:<br> line 10: 0<br> line 11: 3<br> line 12: 6<br> LocalVariableTable:<br> Start Length Slot Name Signature<br> 3 4 0 i I<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20211221150447532.png" alt="image-20211221150447532"></p><blockquote><p>局部变量的引用稍有不同</p></blockquote><p>先看一个成员变量的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafe</span> </span>&#123;<br>    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//共享资源list</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-comment">// &#123; 临界区, 会产生竞态条件</span><br>            method2();<br>            method3();<br>            <span class="hljs-comment">// &#125; 临界区</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THREAD_NUMBER = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LOOP_NUMBER = <span class="hljs-number">200</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ThreadUnsafe test = <span class="hljs-keyword">new</span> ThreadUnsafe();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            test.method1(LOOP_NUMBER);<br>        &#125;<br>        , <span class="hljs-string">&quot;Thread&quot;</span> + i).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;Thread1&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IndexOutOfBoundsException</span>: Index: <span class="hljs-number">0</span>, Size: <span class="hljs-number">0</span> <br> at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.rangeCheck</span>(ArrayList<span class="hljs-selector-class">.java</span>:<span class="hljs-number">657</span>) <br> at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.remove</span>(ArrayList<span class="hljs-selector-class">.java</span>:<span class="hljs-number">496</span>) <br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n6</span><span class="hljs-selector-class">.ThreadUnsafe</span><span class="hljs-selector-class">.method3</span>(TestThreadSafe<span class="hljs-selector-class">.java</span>:<span class="hljs-number">35</span>) <br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n6</span><span class="hljs-selector-class">.ThreadUnsafe</span><span class="hljs-selector-class">.method1</span>(TestThreadSafe<span class="hljs-selector-class">.java</span>:<span class="hljs-number">26</span>) <br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n6</span><span class="hljs-selector-class">.TestThreadSafe</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(TestThreadSafe<span class="hljs-selector-class">.java</span>:<span class="hljs-number">14</span>) <br> at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">748</span>)<br></code></pre></td></tr></table></figure><ul><li>分析</li><li>无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量</li><li>method3 与 method2 分析相同</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211221152126278.png" alt="image-20211221152126278"></p><p>将 list 修改为局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//为局部变量</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么就不会有上述问题了</p><p>分析：</p><ul><li>list 是局部变量，每个线程调用时会创建其不同实例，没有共享</li><li>而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象</li><li>method3 的参数分析与 method2 相同</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211221152337025.png" alt="image-20211221152337025"></p><p>方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？</p><ul><li>情况1：有其它线程调用 method2 和 method3</li><li>情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span>/<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">private</span>/<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadSafe</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            list.remove(<span class="hljs-number">0</span>);<br>        &#125;<br>        ).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:子类<code>ThreadSafeSubClass</code>继承父类<code>ThreadSafe</code>，子类重写<code>method3(ArrayList&lt;String&gt; list)</code>方法;子类重写后，重新启动了一个新的线程，新的线程使用了<code>list</code>来执行一个<code>remove()</code>操作，会出现问题！</p><p>因为：假如<code>线程1</code>创建了一个<code>list</code>，当调用<code>method3(list);</code>时；此时，又有一个<code>新的线程2</code>，访问到了<code>线程1</code>创建的<code>list</code>;这个<code>list</code>对于<code>新的线程2</code>和<code>线程1</code>来说是一个共享的资源，所以会出现线程安全的问题。</p><p>问题分析：这个由于创建了子类，子类的方案不能由我们控制，子类可能另起一个新的线程，访问一些对象，造成了局部变量的引用暴露给其他线程，从而引起线程安全问题。</p><blockquote><p>一些启示：</p><p>方法的访问修饰符private是有意义的，一定程度上可以保护我们的线程安全</p><p>private限制了子类不能覆盖它</p><p>公共方法可以加个final，防止公共方法被子类影响行为，防止子类重写方法，导致线程安全问题</p></blockquote><h3 id="4-3-3-常见的线程安全类"><a href="#4-3-3-常见的线程安全类" class="headerlink" title="4.3.3  常见的线程安全类"></a>4.3.3  常见的线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为</p><ul><li>它们的每个方法是原子的</li><li>但注意它们多个方法的组合不是原子的，见后面分析</li></ul><h4 id="线程安全类方法的组合"><a href="#线程安全类方法的组合" class="headerlink" title="线程安全类方法的组合"></a>线程安全类方法的组合</h4><p>分析下面代码是否线程安全？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Hashtable table = <span class="hljs-keyword">new</span> Hashtable();<br><span class="hljs-comment">// 线程1，线程2</span><br><span class="hljs-keyword">if</span>( table.get(<span class="hljs-string">&quot;key&quot;</span>) == <span class="hljs-keyword">null</span>) &#123;<br> table.put(<span class="hljs-string">&quot;key&quot;</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20211221154636586.png" alt="image-20211221154636586"></p><p><code>Hashtable</code>的多个方法组合，导致<code>put</code>执行了两次，后一个结果把前一个给覆盖了。不是我们预期的效果。</p><h4 id="不可变类的线程安全性"><a href="#不可变类的线程安全性" class="headerlink" title="不可变类的线程安全性"></a>不可变类的线程安全性</h4><p>String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的</p><p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安</p><p>全的呢？<code>replace</code>，<code>substring </code>内部是新创建了一个String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Immutable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Immutable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想增加一个增加的方法呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Immutable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Immutable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Immutable <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Immutable(<span class="hljs-keyword">this</span>.value + v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-4-实例分析"><a href="#4-3-4-实例分析" class="headerlink" title="4.3.4 实例分析"></a>4.3.4 实例分析</h3><h4 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全？不是，HashMap线程不安全</span><br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">// 是否安全？是！不可变类</span><br>    String S1 = <span class="hljs-string">&quot;...&quot;</span>;<br>    <span class="hljs-comment">// 是否安全？是！</span><br>    <span class="hljs-keyword">final</span> String S2 = <span class="hljs-string">&quot;...&quot;</span>;<br>    <span class="hljs-comment">// 是否安全？不是，会被共享。</span><br>    Date D1 = <span class="hljs-keyword">new</span> Date();<br>    <span class="hljs-comment">// 是否安全？不是，final引用值不能变，但日期里的年月日是可以变的。</span><br>    <span class="hljs-keyword">final</span> Date D2 = <span class="hljs-keyword">new</span> Date();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用上述变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全？不安全！因为servlet只有一份，userService是我的成员变量，也只有一份；也是会有多个线程共享访问它。</span><br>    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        userService.update(...);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-comment">// 记录调用次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//属于共享资源</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...要做线程安全的保护！</span><br>        count++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:对提交到同一个servlet类的多个业务请求，共享一个servlet对象（即这个servlet类只被实例化一次）</p><h4 id="例3："><a href="#例3：" class="headerlink" title="例3："></a>例3：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全？不安全！spring里每家额外说明，每个对象都是单例的。单例，即被共享。里面的成员变量也是被共享的。因此有线程安全问题</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> start = <span class="hljs-number">0L</span>;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(* *(..))&quot;)</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        start = System.nanoTime(); <span class="hljs-comment">//开始时间</span><br>    &#125;<br>    <br>    <span class="hljs-meta">@After(&quot;execution(* *(..))&quot;)</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<span class="hljs-comment">//结束时间</span><br>        System.out.println(<span class="hljs-string">&quot;cost time:&quot;</span> + (end-start)); <span class="hljs-comment">//求一个差值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决办法：做成环绕通知。</p><h4 id="例4："><a href="#例4：" class="headerlink" title="例4："></a>例4：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全？线程安全！虽然有一个成员变量userService，但是userService是私有的，也没有其他地方能修改它，因此MyServlet属于不可变，线程安全。</span><br>    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        userService.update(...);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全？线程安全！虽然userDao是成员变量，被共享，但是userDao没有可更改的成员变量/属性--无状态</span><br>    <span class="hljs-keyword">private</span> UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        userDao.update();<br>    &#125;<br>&#125;<br><br> <span class="hljs-comment">// dao是否安全,线程安全！没有成员变量，即使多个线程访问，也没有能修改它的属性/状态。---无状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>        <span class="hljs-comment">// Connection是否安全,线程安全！Connection属于方法内的局部变量，多个线程访问，互不干扰。</span><br>        <span class="hljs-keyword">try</span> (Connection conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>))&#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例5："><a href="#例5：" class="headerlink" title="例5："></a>例5：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全？不安全！</span><br>    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        userService.update(...);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全？不安全！</span><br>    <span class="hljs-keyword">private</span> UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        userDao.update();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全?不安全！</span><br>    <span class="hljs-keyword">private</span> Connection conn = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>        conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// ...</span><br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:需要把<code>Connection</code>做成局部变量！</p><h4 id="例6："><a href="#例6：" class="headerlink" title="例6："></a>例6：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全</span><br>    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        userService.update(...);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<br>        userDao.update();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全</span><br>    <span class="hljs-keyword">private</span> Connection = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>        conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// ...</span><br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:例5和例6区别：<code>UserDao userDao = new UserDaoImpl();</code>例6每次调用都会创建一个新的<code>userDao</code> ,而不是把它当作service的成员变量。</p><p>此方法线程安全！<code>UserDao userDao = new UserDaoImpl();</code> <code>userDao</code>是作为方法内的局部变量存在的，所以：线程1调用<code>update()</code>会创建新的一个<code>userDao</code>,<code>UserDaoImpl</code>中的<code>Connection</code>也是新的；线程2调用<code>update()</code>会创建新的一个<code>userDao</code>,<code>UserDaoImpl</code>中的<code>Connection</code>也是新的！所以线程安全！</p><p>不推荐这种写法！</p><h4 id="例7："><a href="#例7：" class="headerlink" title="例7："></a>例7：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-comment">//抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title">foo</span><span class="hljs-params">(SimpleDateFormat sdf)</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Test().bar();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 是否安全？不安全！</span><br>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        foo(sdf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:有机会把局部变量的对象传递给抽象方法，可能存在子类有不恰当的行为！</p><p>其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为外星方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jav">public void foo(SimpleDateFormat sdf) &#123;<br>    String dateStr = &quot;1999-10-11 00:00:00&quot;;<br>    for (int i = 0; i &lt; 20; i++) &#123;<br>        new Thread(() -&gt; &#123;<br>            try &#123;<br>                sdf.parse(dateStr);<br>            &#125;<br>            catch (ParseException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        ).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就造成，子类新的线程，跟<code>bar()</code>方法的主线程并发访问了同一个<code>SimpleDateFormat</code>对象</p><h2 id="4-4-习题"><a href="#4-4-习题" class="headerlink" title="4.4 习题"></a>4.4 习题</h2><h3 id="4-4-1-买票练习"><a href="#4-4-1-买票练习" class="headerlink" title="4.4.1 买票练习"></a>4.4.1 买票练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.ExerciseSell&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExerciseSell</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        TicketWindow ticketWindow = <span class="hljs-keyword">new</span> TicketWindow(<span class="hljs-number">10000</span>);<br><br><br>        <span class="hljs-comment">// 用来存储买出去多少张票</span><br>        List&lt;Integer&gt; sellCount = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>        <span class="hljs-comment">//所有线程的集合</span><br>        List&lt;Thread&gt; threadList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++) &#123;<br>            Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-comment">// 分析这里的竞态条件</span><br>                <span class="hljs-keyword">int</span> count = ticketWindow.sell(randomAmount());<br>                sellCount.add(count);<br>            &#125;<br>            );<br>            threadList.add(t);<br>            t.start();<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 主线程必须等到所有线程运行结束，才统计数量</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span> (Thread thread : threadList) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                thread.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 买出去的票求和</span><br>        log.debug(<span class="hljs-string">&quot;买出去的票求和:&#123;&#125;&quot;</span>, sellCount.stream().mapToInt(c -&gt; c).sum());<br>        <span class="hljs-comment">// 剩余票数</span><br>        log.debug(<span class="hljs-string">&quot;剩余票数:&#123;&#125;&quot;</span>, ticketWindow.getCount());<br>    &#125;<br><br>    <span class="hljs-comment">// Random 为线程安全</span><br>    <span class="hljs-keyword">static</span> Random random = <span class="hljs-keyword">new</span> Random();<br><br>    <span class="hljs-comment">// 随机 1~5</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomAmount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> random.nextInt(<span class="hljs-number">5</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//售票窗口类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TicketWindow</span> </span>&#123;<br>    <span class="hljs-comment">//余票数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TicketWindow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.count = count;<br>    &#125;<br><br>    <span class="hljs-comment">//获取余票数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-comment">//售票，amount：购买数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sell</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &gt;= amount) &#123;<br>            <span class="hljs-keyword">this</span>.count -= amount;<br>            <span class="hljs-keyword">return</span> amount;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会出线程安全问题！</p><p>解决办法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//售票，amount：购买数量</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sell</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &gt;= amount) &#123;<br>        <span class="hljs-keyword">this</span>.count -= amount;<br>        <span class="hljs-keyword">return</span> amount;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-2-转账练习"><a href="#4-4-2-转账练习" class="headerlink" title="4.4.2 转账练习"></a>4.4.2 转账练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.ExerciseTransfer&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExerciseTransfer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Account a = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">1000</span>);<br>        Account b = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">1000</span>);<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                a.transfer(b, randomAmount());<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                b.transfer(a, randomAmount());<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br><br>        <span class="hljs-comment">// 查看转账2000次后的总金额</span><br>        log.debug(<span class="hljs-string">&quot;total:&#123;&#125;&quot;</span>, (a.getMoney() + b.getMoney()));<br>    &#125;<br><br>    <span class="hljs-comment">// Random 为线程安全</span><br>    <span class="hljs-keyword">static</span> Random random = <span class="hljs-keyword">new</span> Random();<br><br>    <span class="hljs-comment">// 随机 1~100</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomAmount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> random.nextInt(<span class="hljs-number">100</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> money;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Account</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMoney</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *a和b账户余额都需要保护；</span><br><span class="hljs-comment">     * 思路1：`transfer()`方法上加synchronized：这样不行！等价于锁住this对象，它只能保护this.money,无法保护target.money。</span><br><span class="hljs-comment">     * 改进思路：需要锁住this和target两个对象。--&gt; 锁住Account类！因为Account类是this和target共享的类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Account target, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (Account.class)&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.money &gt; amount) &#123;<br>                <span class="hljs-keyword">this</span>.setMoney(<span class="hljs-keyword">this</span>.getMoney() - amount);<br>                target.setMoney(target.getMoney() + amount);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">a和b账户余额都需要保护；<br>思路1：<span class="hljs-code">`transfer()`</span>方法上加synchronized：这样不行！等价于锁住this对象，它只能保护this.money,无法保护target.money。<br>改进思路：需要锁住this和target两个对象。--&gt; 锁住Account类！因为Account类是this和target共享的类<br></code></pre></td></tr></table></figure><h2 id="4-5-管程-Monitor"><a href="#4-5-管程-Monitor" class="headerlink" title="4.5 管程 Monitor"></a>4.5 管程 Monitor</h2><h3 id="4-5-1-Java-对象头"><a href="#4-5-1-Java-对象头" class="headerlink" title="4.5.1 Java 对象头"></a>4.5.1 Java 对象头</h3><p>以 32 位虚拟机为例</p><p>Integer 8+4=12</p><p>int 4Byte</p><p><strong>普通对象</strong></p><p>每个对象都有一个类型，例如<code>Student stu = new Student()</code>为<code>Student</code>类型。</p><p><code>Mark Word</code>：包含很多信息</p><p><code>Klass Word</code>：是一个指针，指向对应的Class类对象。</p><p><img src="http://image.cryptomartin.top/img/image-20211222093252680.png" alt="image-20211222093252680"></p><p><strong>数组对象</strong></p><p><img src="http://image.cryptomartin.top/img/image-20211222094149228.png" alt="image-20211222094149228"></p><p><img src="http://image.cryptomartin.top/img/image-20211222093646949.png" alt="image-20211222093646949"></p><p><strong>正常状态 Mark Word 结构</strong></p><ul><li><p><code>age</code>:垃圾回收时的分代年龄</p></li><li><p><code>biased_lock</code>:代表它是不是偏向锁</p></li><li><p><code>01</code>：代表加锁状态</p></li></ul><p><strong>其他状态Mark Word结构</strong></p><ul><li>会有相应改变</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211222094549510.png" alt="image-20211222094549510"></p><h3 id="4-5-2-Monitor-锁"><a href="#4-5-2-Monitor-锁" class="headerlink" title="4.5.2 Monitor(锁)"></a>4.5.2 Monitor(锁)</h3><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong></p><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p><p><img src="http://image.cryptomartin.top/img/image-20211222095808262.png" alt="image-20211222095808262"></p><ul><li>刚开始 Monitor 中 Owner 为 null</li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner</li><li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入EntryList BLOCKED</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲<br>wait-notify 时会分析</li></ul><blockquote><p>注意：</p><ul><li>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</li><li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li></ul></blockquote><h2 id="4-6-原理之synchronized"><a href="#4-6-原理之synchronized" class="headerlink" title="4.6 * 原理之synchronized"></a>4.6 * 原理之synchronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock=<span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        counter++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br> descriptor: ([Ljava/lang/String;)V<br> flags: ACC_PUBLIC, ACC_STATIC<br> Code:<br> stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// &lt;- lock引用 （synchronized开始）</span><br>         <span class="hljs-number">3</span>: dup<br>         <span class="hljs-number">4</span>: astore_1 <span class="hljs-comment">// lock引用 -&gt; slot 1,临时变量slot1，为了解锁是处理异常</span><br>                  <br>         <span class="hljs-comment">// synchronized (lock)    </span><br>         <span class="hljs-number">5</span>: monitorenter <span class="hljs-comment">// 将 lock对象 MarkWord 置为 Monitor 指针</span><br>         <span class="hljs-number">6</span>: getstatic #<span class="hljs-number">3</span> <span class="hljs-comment">// &lt;- i</span><br>         <span class="hljs-number">9</span>: iconst_1 <span class="hljs-comment">// 准备常数 1</span><br>         <span class="hljs-number">10</span>: iadd <span class="hljs-comment">// +1</span><br>         <span class="hljs-number">11</span>: putstatic #<span class="hljs-number">3</span> <span class="hljs-comment">// -&gt; i</span><br>         <span class="hljs-number">14</span>: aload_1 <span class="hljs-comment">// &lt;- lock引用</span><br>         <span class="hljs-number">15</span>: monitorexit <span class="hljs-comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList;Mark Word 存储Monitor指针，现在需要重新改为原来的信息，原来的信息都存在临时变量slot中。</span><br>         <span class="hljs-number">16</span>: goto <span class="hljs-number">24</span><br>                  <br>          <span class="hljs-comment">//同步代码快发生异常</span><br>         <span class="hljs-number">19</span>: astore_2 <span class="hljs-comment">// e -&gt; slot 2;异常对象给临时变量slot</span><br>         <span class="hljs-number">20</span>: aload_1 <span class="hljs-comment">// &lt;- lock引用</span><br>         <span class="hljs-number">21</span>: monitorexit <span class="hljs-comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span><br>         <span class="hljs-number">22</span>: aload_2 <span class="hljs-comment">// &lt;- slot 2 (e)</span><br>         <span class="hljs-number">23</span>: athrow <span class="hljs-comment">// throw e</span><br>         <span class="hljs-number">24</span>: <span class="hljs-keyword">return</span><br>         Exception table:<br>         from to target type<br>             <span class="hljs-number">6</span> <span class="hljs-number">16</span> <span class="hljs-number">19</span> any <span class="hljs-comment">//发现异常，到19行执行</span><br>             <span class="hljs-number">19</span> <span class="hljs-number">22</span> <span class="hljs-number">19</span> any<br>         LineNumberTable:<br>             line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>             line <span class="hljs-number">9</span>: <span class="hljs-number">6</span><br>             line <span class="hljs-number">10</span>: <span class="hljs-number">14</span><br>             line <span class="hljs-number">11</span>: <span class="hljs-number">24</span><br>         LocalVariableTable:<br>             Start Length Slot Name Signature<br>             <span class="hljs-number">0</span> <span class="hljs-number">25</span> <span class="hljs-number">0</span> args [Ljava/lang/String;<br>         StackMapTable: number_of_entries = <span class="hljs-number">2</span><br>          frame_type = <span class="hljs-number">255</span> <span class="hljs-comment">/* full_frame */</span><br>            offset_delta = <span class="hljs-number">19</span><br>            locals = [ <span class="hljs-class"><span class="hljs-keyword">class</span> &quot;[<span class="hljs-title">Ljava</span>/<span class="hljs-title">lang</span>/<span class="hljs-title">String</span></span>;<span class="hljs-string">&quot;, class java/lang/Object ]</span><br><span class="hljs-string">            stack = [ class java/lang/Throwable ]</span><br><span class="hljs-string">          frame_type = 250 /* chop */</span><br><span class="hljs-string">            offset_delta = 4</span><br></code></pre></td></tr></table></figure><h2 id="4-7-原理之synchronized进阶（重点）"><a href="#4-7-原理之synchronized进阶（重点）" class="headerlink" title="4.7 *原理之synchronized进阶（重点）"></a>4.7 *原理之synchronized进阶（重点）</h2><p>Monitor锁由操作系统提供，使用成本较高，对于程序性能有影响。</p><p><strong>小故事</strong></p><p>故事角色</p><ul><li>老王 - JVM</li><li>小南 - 线程</li><li>小女 - 线程</li><li>房间 - 对象</li><li>房间门上 - 防盗锁 - Monitor</li><li>房间门上 - 小南书包 - 轻量级锁</li><li>房间门上 - 刻上小南大名 - 偏向锁</li><li>批量重刻名 - 一个类的偏向锁撤销到达 20 阈值</li><li>不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown">小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样，<br>即使他离开了，别人也进不了门，他的工作就是安全的。<br><br>但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女<br>晚上用。每次上锁太麻烦了，有没有更简单的办法呢？<br><br>小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因<br>此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是<br>自己的，那么就在门外等，并通知对方下次用锁门的方式。<br><br>后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍<br>然觉得麻烦。<br><br>于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那<br>么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦<br>掉，升级为挂书包的方式。<br><br>同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老<br>家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老<br>王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字<br><br>后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包<br></code></pre></td></tr></table></figure><h3 id="4-7-1-轻量级锁"><a href="#4-7-1-轻量级锁" class="headerlink" title="4.7.1 轻量级锁"></a>4.7.1 轻量级锁</h3><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p><p>轻量级锁对使用者是透明的，即语法仍然是 synchronized</p><p>假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 A</span><br>method2();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 B</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的<code>Mark Word</code></li></ul><p><img src="http://image.cryptomartin.top/img/image-20211222111033712.png" alt="image-20211222111033712"></p><p><code>Object reference</code>存储锁对象指针；<code>lock record 地址 00</code>用来存储加锁对象的<code>Mark Word</code></p><ul><li>让锁记录中 <code>Object reference</code> 指向锁对象，并尝试用 <code>cas</code> 替换 Object 的 <code>Mark Word</code>，将 <code>Mark Word</code> 的值存入锁记录</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211222111455243.png" alt="image-20211222111455243"></p><p>会把锁记录的<code>lcok record 地址 00</code>里的数据跟锁对象<code>Object</code>的<code>Mark Word</code>的数据做交换。</p><p><code>01</code>：表示无锁状态，<code>00</code>:表示轻量级锁的状态</p><ul><li>如果 <code>cas</code> 替换成功，对象头中存储了 锁记录地址和状态 <code>00</code> ，表示由该线程给对象加锁，</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211222111818064.png" alt="image-20211222111818064"></p><ul><li><p>如果 <code>cas</code> 失败，有两种情况</p><ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ul></li></ul><p><img src="http://image.cryptomartin.top/img/image-20211222141226403.png" alt="image-20211222141226403"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 A</span><br>method2();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 B</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>method1()调用method2(),synchronized( obj )又锁住ob对象，会在栈帧中创建新的锁记录，Object reference 指向Objct对象，也是执行cas操作，要把数据和对象投中Markd Word交换，结果失败！ 后两位为00，锁记录的地址指向第一个Lock Record。所以第二次加锁失败，不过这个失败没关系。能知道锁是同一个线程中的（通过lock record 地址 00）另一条锁记录，这种情况较<code>synchronized所重入</code></p><p><strong>解锁</strong></p><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p><p><img src="http://image.cryptomartin.top/img/image-20211222142159490.png" alt="image-20211222142159490"></p><ul><li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象<br>头<ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul><h3 id="4-7-2-锁膨胀"><a href="#4-7-2-锁膨胀" class="headerlink" title="4.7.2 锁膨胀"></a>4.7.2 锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20211222164407916.png" alt="image-20211222164407916"></p><ul><li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul><li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</li><li>然后自己进入 Monitor 的 EntryList BLOCKED</li></ul></li></ul><p><img src="http://image.cryptomartin.top/img/image-20211222164635328.png" alt="image-20211222164635328"></p><ul><li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁<br>流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ul><h3 id="4-7-3-自旋优化"><a href="#4-7-3-自旋优化" class="headerlink" title="4.7.3  自旋优化"></a>4.7.3  自旋优化</h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步<br>块，释放了锁），这时当前线程就可以避免阻塞。</p><p><img src="http://image.cryptomartin.top/img/image-20211222165318793.png" alt="image-20211222165318793"></p><p><img src="http://image.cryptomartin.top/img/image-20211222165342929.png" alt="image-20211222165342929"></p><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会<br>高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li><li>Java 7 之后不能控制是否开启自旋功能</li></ul><h3 id="4-7-4-偏向锁"><a href="#4-7-4-偏向锁" class="headerlink" title="4.7.4 偏向锁"></a>4.7.4 偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现<br>这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 A</span><br>m2();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 B</span><br>m3();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 C</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20211222170358505.png" alt="image-20211222170358505"></p><p><img src="http://image.cryptomartin.top/img/image-20211222170434074.png" alt="image-20211222170434074"></p><h4 id="4-7-4-1-偏向状态"><a href="#4-7-4-1-偏向状态" class="headerlink" title="4.7.4.1 偏向状态"></a>4.7.4.1 偏向状态</h4><p>回忆一下对象头格式</p><p><img src="http://image.cryptomartin.top/img/image-20211222170715668.png" alt="image-20211222170715668"></p><p>一个对象创建时：</p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的thread、epoch、age 都为 0</li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟</li><li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</li></ul><p>1） 测试延迟特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestBiased&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBiased</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        log.debug(ClassLayout.parseInstance(dog).toPrintable());<br>        Thread.sleep(<span class="hljs-number">4000</span>);<br>        log.debug(ClassLayout.parseInstance(<span class="hljs-keyword">new</span> Dog()).toPrintable());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20211222175202103.png" alt="image-20211222175202103"></p><p>2） 测试偏向锁 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestBiased&quot;)</span><br><span class="hljs-comment">// 添加虚拟机参数 -XX:BiasedLockingStartupDelay=0 </span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBiased</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>Dog d = <span class="hljs-keyword">new</span> Dog();<br>ClassLayout classLayout = ClassLayout.parseInstance(d);<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;synchronized 前&quot;</span>);<br>System.out.println(classLayout.toPrintableSimple(<span class="hljs-keyword">true</span>));<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(<span class="hljs-string">&quot;synchronized 中&quot;</span>);<br>System.out.println(classLayout.toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>log.debug(<span class="hljs-string">&quot;synchronized 后&quot;</span>);<br>System.out.println(classLayout.toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">11:08:58.117 c.TestBiased [t1] - synchronized 前<br>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101 <br>11:08:58.121 c.TestBiased [t1] - synchronized 中<br>00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101 <br>11:08:58.121 c.TestBiased [t1] - synchronized 后<br>00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>处于偏向锁的对象解锁后，线程 id 仍存储于对象头中;</p><p> dog对象就给主线程使用了，dog对象就从属于主线程；dog对象的对象头Mark Word始终存储主线程的线程id，除非是其他线程使用了dog对象才会改变。</p></blockquote><p>3）测试禁用</p><p>在上面测试代码运行时在添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</p><p>输出：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">11:13:10.018 c.TestBiased [t1] - synchronized 前<br>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>11:13:10.021 c.TestBiased [t1] - synchronized 中<br>00000000 00000000 00000000 00000000 00100000 00010100 11110011 10001000 <br>11:13:10.021 c.TestBiased [t1] - synchronized 后<br>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001<br></code></pre></td></tr></table></figure><blockquote><p>禁用偏向锁后，对象加锁后使用的是轻量级锁。</p><p>优先级：有偏向锁会采用偏向锁，如果其他线程使用了该对象，会撤销偏向锁变成轻量级锁；如果是轻量级锁，有线程竞争，会进行锁膨胀，成为重量级锁。</p></blockquote><p>4）测试 hashCode</p><p>正常状态对象一开始是没有 hashCode 的，第一次调用才生成</p><p>开启偏向锁，对象在加锁之前调用<code>hashCode()</code>，会禁用这个对象的偏向锁。</p><p>why?看对象头的mark word</p><p><img src="http://image.cryptomartin.top/img/image-20211226170317210.png" alt="image-20211226170317210"></p><p>一个可偏向的对象,调用hashcode，就不可偏向了，因为没地方存储hashcode了。偏向锁的对象头mark word 需要存储54位线程id，而hashcode有31位。mark word 只有64位。</p><p>问：为什么轻量级锁，重量级锁调用<code>hashcode()</code>不会有问题呢？</p><p>答：轻量级锁会将hashcode存储在线程栈帧的锁记录里；重量级锁会将hashcode存储在monitor对象里，解锁时会还原回来。</p><h4 id="4-7-4-2-撤销-调用对象-hashCode"><a href="#4-7-4-2-撤销-调用对象-hashCode" class="headerlink" title="4.7.4.2 撤销 - 调用对象 hashCode"></a>4.7.4.2 撤销 - 调用对象 hashCode</h4><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销</p><ul><li>轻量级锁会在锁记录中记录 hashCode</li><li>重量级锁会在 Monitor 中记录 hashCode</li></ul><p>在调用 hashCode 后使用偏向锁，记得去掉 <code>-XX:-UseBiasedLocking</code>（<code>-XX:-UseBiasedLocking</code>：是禁用偏向锁，我们这是测试调用对象的hashCode()方法）</p><p><code>输出</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mark">11:22:10.386 c.TestBiased [main] - 调用 hashCode:1778535015 <br>11:22:10.391 c.TestBiased [t1] - synchronized 前<br>00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001 <br>11:22:10.393 c.TestBiased [t1] - synchronized 中<br>00000000 00000000 00000000 00000000 00100000 11000011 11110011 01101000 <br>11:22:10.393 c.TestBiased [t1] - synchronized 后<br>00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001<br></code></pre></td></tr></table></figure><h4 id="4-7-4-3-撤销-其它线程使用对象"><a href="#4-7-4-3-撤销-其它线程使用对象" class="headerlink" title="4.7.4.3 撤销 - 其它线程使用对象"></a>4.7.4.3 撤销 - 其它线程使用对象</h4><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Dog d = <span class="hljs-keyword">new</span> Dog();<br>    <br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>        <br><span class="hljs-keyword">synchronized</span> (TestBiased.class) &#123;<br>TestBiased.class.notify();<br>&#125;<br><span class="hljs-comment">// 如果不用 wait/notify 使用 join 必须打开下面的注释</span><br><span class="hljs-comment">// 因为：t1 线程不能结束，否则底层线程可能被 jvm 重用作为 t2 线程，底层线程 id 是一样的</span><br><span class="hljs-comment">/*try &#123;</span><br><span class="hljs-comment">         System.in.read();</span><br><span class="hljs-comment">         &#125; catch (IOException e) &#123;</span><br><span class="hljs-comment">         e.printStackTrace();</span><br><span class="hljs-comment">         &#125;*/</span><br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>    <br>Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span> (TestBiased.class) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>TestBiased.class.wait();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>        <br>log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>t1线程必须和t2线程交错开，否则有交错会升级为重量级锁。</p><p>轻量级锁和偏向锁访问对象都是错开的。</p><p>如何错开？t2锁住类对象，等待。（类锁和对象锁不会产生竞争，二者的加锁方法不会相互影响）</p><p>wait会释放CPU和锁资源。</p><p>Wait() 会使当前线程A释放锁，并被加入到Waiting队列，进入Waiting状态。</p><p>另一个线程B调用Notify()之后，会将线程A从Waiting队列移动到Blocked队列中，即线程A从Waiting状态进入尝试获得锁的Blocked状态。之后B释放锁之后，A才有获得锁的机会。</p></blockquote><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[t1] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101 --偏向锁，包含t1线程id<br>[t2] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101 --t2线程没加锁前<br>[t2] - 00000000 00000000 00000000 00000000 00011111 10110101 11110000 01000000 --t2加锁，加的是轻量级锁，包含t2锁记录指针<br>[t2] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 --t2结束，变成不可偏向。<br></code></pre></td></tr></table></figure><h4 id="4-7-4-4-撤销-调用-wait-notify"><a href="#4-7-4-4-撤销-调用-wait-notify" class="headerlink" title="4.7.4.4 撤销 - 调用 wait/notify"></a>4.7.4.4 撤销 - 调用 wait/notify</h4><p>等待通知机制，只有重量级锁才有，都会把偏向锁/轻量级锁升级成重量级锁。</p><h4 id="4-7-4-5-批量重偏向"><a href="#4-7-4-5-批量重偏向" class="headerlink" title="4.7.4.5 批量重偏向"></a>4.7.4.5 批量重偏向</h4><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p><p>当撤销偏向锁阈值达到 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <br>Vector&lt;Dog&gt; list = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>    <br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>Dog d = <span class="hljs-keyword">new</span> Dog();<br>list.add(d);<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>&#125;<br><span class="hljs-keyword">synchronized</span> (list) &#123;<br>list.notify();<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>    <br>Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span> (list) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>list.wait();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>        <br>log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>Dog d = list.get(i);<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs mark">[t1] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - ===============&gt; <br>[t2] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 0 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 1 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 2 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 2 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 3 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 3 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 4 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 4 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 5 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 5 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 6 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 6 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101<br>[t2] - 7 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 7 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 8 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 8 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 9 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 9 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 10 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 10 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 11 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 11 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 12 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 12 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 13 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 13 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 14 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 14 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 15 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 15 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 16 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 16 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 17 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 17 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 18 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 18 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101<br>[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101<br></code></pre></td></tr></table></figure><p>注意到:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[t2] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 18 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 18 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br></code></pre></td></tr></table></figure><p>第20次(序号19),t1的线程id和t2的线程id：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[t1] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 --t2没加锁之前，仍偏向t1<br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 --撤销次数达到20次，重新偏向t2<br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 --批量偏向<br></code></pre></td></tr></table></figure><h4 id="4-7-4-6-批量撤销"><a href="#4-7-4-6-批量撤销" class="headerlink" title="4.7.4.6 批量撤销"></a>4.7.4.6 批量撤销</h4><p><code>intx BiasedLockingBulkRebiasThreshold  = 20</code>  默认偏向锁批量重偏向阈值</p><p><code>intx BiasedLockingBulkRevokeThreshold = 40</code>  默认偏向锁批量撤销阈值</p><p>当撤销偏向锁阈值达到 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Thread t1,t2,t3;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Vector&lt;Dog&gt; list = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br><span class="hljs-keyword">int</span> loopNumber = <span class="hljs-number">39</span>;<br>t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>Dog d = <span class="hljs-keyword">new</span> Dog();<br>list.add(d);<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>&#125;<br>LockSupport.unpark(t2);<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>LockSupport.park();<br>log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>Dog d = list.get(i);<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>LockSupport.unpark(t3);<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br>t3 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>LockSupport.park();<br>log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>Dog d = list.get(i);<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t3&quot;</span>);<br>t3.start();<br>t3.join();<br>log.debug(ClassLayout.parseInstance(<span class="hljs-keyword">new</span> Dog()).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>LockSupport.unpark</code>：停止当前线程，唤醒目标线程</p><ul><li><code>t1</code>线程中，0-39中的循环给每个d对象加上了偏向锁，使每个d对象保存了<code>t1</code>线程ID。</li><li><code>t2</code>线程中，0-18中的循环，撤销偏向锁，获得对象锁后为轻量级锁, 使每个d对象变成了不可偏向状态。19-39中的循环，<code>JVM</code>批量重偏向使该对象保存了<code>t2</code>线程ID</li><li><code>t3</code>线程中，0-18中的循环，每个d对象仍是不可偏向状态，获得对象锁后仍为轻量级锁。19-39中，撤销偏向锁，获得对象锁后为轻量级锁，使整个类的每个d对象变成了不可偏向状态。</li><li><code>t2</code>中的0-18中的循环和<code>t3</code>中19-39中的循环，一共撤销了40次偏向。此后Dog类之前创建的对象，或是新创建的对象都是不可偏向的。</li></ul><blockquote><p><a href="https://www.cnblogs.com/LemonFive/p/11246086.html">盘一盘 synchronized （一）—— 从打印Java对象头说起</a></p><p><a href="https://www.cnblogs.com/LemonFive/p/11248248.html">盘一盘 synchronized （二）—— 偏向锁批量重偏向与批量撤销</a></p></blockquote><h3 id="4-7-5-锁消除"><a href="#4-7-5-锁消除" class="headerlink" title="4.7.5 锁消除"></a>4.7.5 锁消除</h3><p><strong>锁消除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Fork(1)</span><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-meta">@Warmup(iterations=3)</span><br><span class="hljs-meta">@Measurement(iterations=5)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBenchmark</span> </span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-meta">@Benchmark</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>x++;<br>&#125;<br><span class="hljs-meta">@Benchmark</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>Object o = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">synchronized</span> (o) &#123;<br>x++;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行<code>java -jar benchmarks.jar</code></p><p><img src="http://image.cryptomartin.top/img/image-20211228151936221.png" alt="image-20211228151936221"></p><p>得分没什么区别，为什么呢？</p><p>因为有即时编译器JIT，热点的代码(反复执行)，JIT进行优化，其中的一个手段就是看局部变量能不能优化。发现局部变量逃离不了方法的范围，这种情况加局部变量就不能被共享，所以加锁没有意义。JIT就会把锁优化掉，真正执行是没有这个锁的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Benchmark</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>Object o = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">synchronized</span> (o) &#123;<br>x++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况，锁消除是打开的。</p><p><code>java -XX:-EliminateLocks -jar benchmarks.jar</code>:关闭锁消除</p><p><img src="http://image.cryptomartin.top/img/image-20211228152530932.png" alt="image-20211228152530932"></p><p>没进行JIT锁消除优化，性能差了10几倍。</p><p><strong>锁粗化</strong></p><p>对相同对象多次加锁，导致线程发生多次重入，可以使用锁粗化方式来优化，这不同于之前讲的细分锁的粒度。</p><h2 id="4-8-wait-notify"><a href="#4-8-wait-notify" class="headerlink" title="4.8 wait/notify"></a>4.8 wait/notify</h2><h3 id="4-8-1-小故事-为什么需要-wait"><a href="#4-8-1-小故事-为什么需要-wait" class="headerlink" title="4.8.1 小故事 - 为什么需要 wait"></a>4.8.1 小故事 - 为什么需要 wait</h3><p><img src="http://image.cryptomartin.top/img/image-20211228153111052.png" alt="image-20211228153111052"></p><p><img src="http://image.cryptomartin.top/img/image-20211228153126873.png" alt="image-20211228153126873"></p><h3 id="4-8-2-原理之wait-notify"><a href="#4-8-2-原理之wait-notify" class="headerlink" title="4.8.2 *原理之wait/notify"></a>4.8.2 *原理之wait/notify</h3><p><img src="http://image.cryptomartin.top/img/image-20211228161830111.png" alt="image-20211228161830111"></p><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li></ul><h3 id="4-8-3-API介绍"><a href="#4-8-3-API介绍" class="headerlink" title="4.8.3 API介绍"></a>4.8.3 API介绍</h3><ul><li><code>obj.wait()</code> 让进入 object 监视器的线程到 waitSet 等待</li><li><code>obj.notify()</code> 在 object 上正在 waitSet 等待的线程中挑一个唤醒</li><li><code>obj.notifyAll()</code> 让 object 上正在 waitSet 等待的线程全部唤醒</li></ul><p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            log.debug(<span class="hljs-string">&quot;执行....&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                obj.wait(); <span class="hljs-comment">// 让线程在obj上一直等待下去</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;其它代码....&quot;</span>);<br>        &#125;<br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            log.debug(<span class="hljs-string">&quot;执行....&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                obj.wait(); <span class="hljs-comment">// 让线程在obj上一直等待下去</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;其它代码....&quot;</span>);<br>        &#125;<br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    <span class="hljs-comment">// 主线程两秒后执行</span><br>    sleep(<span class="hljs-number">2</span>);<br>    log.debug(<span class="hljs-string">&quot;唤醒 obj 上其它线程&quot;</span>);<br><br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>        <span class="hljs-comment">//obj.notify(); // 唤醒obj上一个线程</span><br>        obj.notifyAll(); <span class="hljs-comment">// 唤醒obj上所有等待线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>notify()</code> 的一种结果:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:29:50 [t1] c.TestWaitNotify - 执行....<br>16:29:50 [t2] c.TestWaitNotify - 执行....<br>16:29:52 [main] c.TestWaitNotify - 唤醒 obj 上其它线程<br>16:29:52 [t1] c.TestWaitNotify - 其它代码....<br></code></pre></td></tr></table></figure><p><code>notifyAll()</code> 的结果:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:31:25 [t1] c.TestWaitNotify - 执行....<br>16:31:25 [t2] c.TestWaitNotify - 执行....<br>16:31:27 [main] c.TestWaitNotify - 唤醒 obj 上其它线程<br>16:31:27 [t2] c.TestWaitNotify - 其它代码....<br>16:31:27 [t1] c.TestWaitNotify - 其它代码....<br></code></pre></td></tr></table></figure><ul><li><code>wait()</code> 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止</li><li><code>wait(long n)</code> 有时限的等待, 到 n 毫秒后结束等待，或是被 notify</li></ul><h3 id="4-8-4-wait-notify-的正确使用方法"><a href="#4-8-4-wait-notify-的正确使用方法" class="headerlink" title="4.8.4 wait/notify 的正确使用方法"></a>4.8.4 wait/notify 的正确使用方法</h3><p>先看看</p><p><strong>sleep(long n) 和 wait(long n) 的区别</strong></p><ul><li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li></ul><ol start="2"><li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li><li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 </li><li>共同点：它们状态 TIMED_WAITING</li></ol><h4 id="4-8-4-1-step1-sleep"><a href="#4-8-4-1-step1-sleep" class="headerlink" title="4.8.4.1 step1 sleep"></a>4.8.4.1 step1 sleep</h4><p>思考下面的解决方案好不好，为什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestCorrectPostureStep1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCorrectPostureStep1</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasCigarette = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//没有烟</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasTakeout = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (!hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>                    sleep(<span class="hljs-number">2</span>);<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;其它人&quot;</span>).start();<br>        &#125;<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">// 这里能不能加 synchronized (room)？不能！获得不了锁</span><br>            hasCigarette = <span class="hljs-keyword">true</span>;<br>            log.debug(<span class="hljs-string">&quot;烟到了噢！&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;送烟的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:57:41 [其它人] c.TestCorrectPostureStep1 - 可以开始干活了<br>16:57:41 [小南] c.TestCorrectPostureStep1 - 有烟没？[false]<br>16:57:41 [小南] c.TestCorrectPostureStep1 - 没烟，先歇会！<br>16:57:42 [送烟的] c.TestCorrectPostureStep1 - 烟到了噢！<br>16:57:43 [小南] c.TestCorrectPostureStep1 - 有烟没？[true]<br>16:57:43 [小南] c.TestCorrectPostureStep1 - 可以开始干活了<br>16:57:43 [其它人] c.TestCorrectPostureStep1 - 可以开始干活了<br>16:57:43 [其它人] c.TestCorrectPostureStep1 - 可以开始干活了<br>16:57:43 [其它人] c.TestCorrectPostureStep1 - 可以开始干活了<br>16:57:43 [其它人] c.TestCorrectPostureStep1 - 可以开始干活了<br></code></pre></td></tr></table></figure><ul><li>其它干活的线程，都要一直阻塞，效率太低</li><li>小南线程必须睡足 2s 后才能醒来，就算烟提前送到，也无法立刻醒来</li><li>加了 synchronized (room) 后，就好比小南在里面反锁了门睡觉，烟根本没法送进门，main 加synchronized 就好像 main 线程是翻窗户进来的</li><li>解决方法，使用 wait - notify 机制</li></ul><h4 id="4-8-4-2-step2-wait-notify"><a href="#4-8-4-2-step2-wait-notify" class="headerlink" title="4.8.4.2 step2 wait/notify"></a>4.8.4.2 step2 wait/notify</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestCorrectPostureStep2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCorrectPostureStep2</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasCigarette = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//没有烟</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasTakeout = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (!hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<span class="hljs-comment">//别的线程调用interrupt(),向下执行</span><br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;其它人&quot;</span>).start();<br>        &#125;<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">// 这里能不能加 synchronized (room)？不能！获得不了锁</span><br>            <span class="hljs-keyword">synchronized</span> (room)&#123;<br>                hasCigarette = <span class="hljs-keyword">true</span>;<br>                log.debug(<span class="hljs-string">&quot;烟到了噢！&quot;</span>);<br>                room.notify();<br>            &#125;<br><br>        &#125;, <span class="hljs-string">&quot;送烟的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> <span class="hljs-selector-attr">[小南]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 有烟没？<span class="hljs-selector-attr">[false]</span><br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> <span class="hljs-selector-attr">[小南]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 没烟，先歇会！<br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> <span class="hljs-selector-attr">[其它人]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 可以开始干活了<br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> <span class="hljs-selector-attr">[其它人]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 可以开始干活了<br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> <span class="hljs-selector-attr">[其它人]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 可以开始干活了<br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> <span class="hljs-selector-attr">[其它人]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 可以开始干活了<br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> <span class="hljs-selector-attr">[其它人]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 可以开始干活了<br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">34</span> <span class="hljs-selector-attr">[送烟的]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 烟到了噢！<br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">34</span> <span class="hljs-selector-attr">[小南]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 有烟没？<span class="hljs-selector-attr">[true]</span><br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">34</span> <span class="hljs-selector-attr">[小南]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 可以开始干活了<br></code></pre></td></tr></table></figure><ul><li>解决了其它干活的线程阻塞的问题</li><li>但如果有其它线程也在等待条件呢？会不会错误地叫醒其他线程？</li></ul><h4 id="4-8-4-3-step3-notify"><a href="#4-8-4-3-step3-notify" class="headerlink" title="4.8.4.3 step3 notify"></a>4.8.4.3 step3 notify</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestCorrectPostureStep3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCorrectPostureStep3</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasCigarette = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//没有烟</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasTakeout = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">//虚假唤醒</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (!hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<span class="hljs-comment">//别的线程调用interrupt(),向下执行</span><br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                Thread thread = Thread.currentThread();<br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);<br>                <span class="hljs-keyword">if</span> (!hasTakeout) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);<br>                <span class="hljs-keyword">if</span> (hasTakeout) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                hasTakeout = <span class="hljs-keyword">true</span>;<br>                log.debug(<span class="hljs-string">&quot;外卖到了噢！&quot;</span>);<br>                room.notify();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">17:48:14 [小南] c.TestCorrectPostureStep3 - 有烟没？[false]<br>17:48:14 [小南] c.TestCorrectPostureStep3 - 没烟，先歇会！<br>17:48:14 [小女] c.TestCorrectPostureStep3 - 外卖送到没？[false]<br>17:48:14 [小女] c.TestCorrectPostureStep3 - 没外卖，先歇会！<br>17:48:15 [送外卖的] c.TestCorrectPostureStep3 - 外卖到了噢！<br>17:48:15 [小南] c.TestCorrectPostureStep3 - 有烟没？[false]<br>17:48:15 [小南] c.TestCorrectPostureStep3 - 没干成活...<br></code></pre></td></tr></table></figure><ul><li>notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程，称之为【虚假唤醒】</li><li>解决方法，改为 notifyAll–&gt;小南还是没干成活</li></ul><h4 id="4-8-4-4-step4-notifyall"><a href="#4-8-4-4-step4-notifyall" class="headerlink" title="4.8.4.4 step4 notifyall"></a>4.8.4.4 step4 notifyall</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">sleep(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (room) &#123;<br>        hasTakeout = <span class="hljs-keyword">true</span>;<br>        log.debug(<span class="hljs-string">&quot;外卖到了噢！&quot;</span>);<br>        room.notifyAll();<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">17:55:48 [小南] c.TestCorrectPostureStep4 - 有烟没？[false]<br>17:55:48 [小南] c.TestCorrectPostureStep4 - 没烟，先歇会！<br>17:55:48 [小女] c.TestCorrectPostureStep4 - 外卖送到没？[false]<br>17:55:48 [小女] c.TestCorrectPostureStep4 - 没外卖，先歇会！<br>17:55:49 [送外卖的] c.TestCorrectPostureStep4 - 外卖到了噢！<br>17:55:49 [小女] c.TestCorrectPostureStep4 - 外卖送到没？[true]<br>17:55:49 [小女] c.TestCorrectPostureStep4 - 可以开始干活了<br>17:55:49 [小南] c.TestCorrectPostureStep4 - 有烟没？[false]<br>17:55:49 [小南] c.TestCorrectPostureStep4 - 没干成活...<br></code></pre></td></tr></table></figure><ul><li>用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新判断的机会了</li><li>解决方法，用 while + wait，当条件不成立，再次 wait</li></ul><h4 id="4-8-4-5-step-while-wait"><a href="#4-8-4-5-step-while-wait" class="headerlink" title="4.8.4.5 step while+wait"></a>4.8.4.5 step while+wait</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (room) &#123;<br>log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br><span class="hljs-keyword">while</span> (!hasCigarette) &#123;<br><span class="hljs-comment">//if改成while,就可以一直判断。</span><br>log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>room.wait();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">//别的线程调用interrupt(),向下执行</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br>log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br><span class="hljs-keyword">if</span> (hasCigarette) &#123;<br>log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">18:01:16 [小南] c.TestCorrectPostureStep5 - 有烟没？[false]<br>18:01:16 [小南] c.TestCorrectPostureStep5 - 没烟，先歇会！<br>18:01:16 [小女] c.TestCorrectPostureStep5 - 外卖送到没？[false]<br>18:01:16 [小女] c.TestCorrectPostureStep5 - 没外卖，先歇会！<br>18:01:17 [送外卖的] c.TestCorrectPostureStep5 - 外卖到了噢！<br>18:01:17 [小女] c.TestCorrectPostureStep5 - 外卖送到没？[true]<br>18:01:17 [小女] c.TestCorrectPostureStep5 - 可以开始干活了<br>18:01:17 [小南] c.TestCorrectPostureStep5 - 没烟，先歇会！<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) &#123;<br><span class="hljs-keyword">while</span>(条件不成立) &#123;<br>lock.wait();<br>&#125;<br><span class="hljs-comment">// 干活</span><br>&#125;<br><span class="hljs-comment">//另一个线程</span><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>lock.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-8-5-【模式】同步模式之保护性暂停"><a href="#4-8-5-【模式】同步模式之保护性暂停" class="headerlink" title="4.8.5 【模式】同步模式之保护性暂停"></a>4.8.5 【模式】同步模式之保护性暂停</h3><h4 id="4-8-5-1-定义"><a href="#4-8-5-1-定义" class="headerlink" title="4.8.5.1 定义"></a>4.8.5.1 定义</h4><p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果</p><p>要点</p><ul><li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li><li>因为要等待另一方的结果，因此归类到同步模式</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211228181410426.png" alt="image-20211228181410426"></p><h4 id="4-8-5-2-实现"><a href="#4-8-5-2-实现" class="headerlink" title="4.8.5.2 实现"></a>4.8.5.2 实现</h4><p>synchronized (this)：</p><p>当使用 synchronized 加锁 class 时，无论共享一个对象还是创建多个对象，它们用的都是同一把锁，而使用 synchronized 加锁 this 时，只有同一个对象会使用同一把锁，不同对象之间的锁是不同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test20&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test20</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        GuardedObject guardedObject = <span class="hljs-keyword">new</span> GuardedObject();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">//等待结果</span><br>            log.debug(<span class="hljs-string">&quot;等待结果&quot;</span>);<br>            List&lt;String&gt; list = (List&lt;String&gt;) guardedObject.getResponse();<br>            log.debug(<span class="hljs-string">&quot;结果大小：&#123;&#125;&quot;</span>, list.size());<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;执行下载...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                List&lt;String&gt; list = Downloader.download();<br>                guardedObject.setResponse(list);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObject</span> </span>&#123;<br>    <span class="hljs-comment">//结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">//获取结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">//没有结果</span><br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//产生结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResponse</span><span class="hljs-params">(Object response)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123; <span class="hljs-comment">//this-&gt;实例对象。实例对象不同，锁不同！</span><br>            <span class="hljs-keyword">this</span>.response = response;<br>            <span class="hljs-keyword">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13</span>:<span class="hljs-number">14</span>:<span class="hljs-number">22</span> [t2] c.Test20 - 执行下载...<br><span class="hljs-number">13</span>:<span class="hljs-number">14</span>:<span class="hljs-number">22</span> [t1] c.Test20 - 等待结果<br><span class="hljs-number">13</span>:<span class="hljs-number">14</span>:<span class="hljs-number">23</span> [t1] c.Test20 - 结果大小：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><blockquote><p>为什么不用<code>join()</code>? </p><p>答：1.必须等待线程结束，保护性暂停执行完后，可以继续干其他事情；2. <code>join()</code>方法只能设置位全局的，不能局部。</p></blockquote><h4 id="4-8-5-3-带超时版-GuardedObject"><a href="#4-8-5-3-带超时版-GuardedObject" class="headerlink" title="4.8.5.3 带超时版 GuardedObject"></a>4.8.5.3 带超时版 GuardedObject</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//结果</span><br><span class="hljs-keyword">private</span> Object response;<br><br><span class="hljs-comment">//获取结果</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-comment">//记录一个开始时间</span><br>        <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.wait(timeout);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>注：this.wait(timeout);//每次等2秒后自己唤醒，不断循环;本质没什么区别</p><p>小知识 object.wait 和 object.wait(long timeout)</p><p>相同点：<br>都会在拥有锁的时候立即释放锁，线程会被系统挂起，失去cpu时间片，得不到调度。<br>不同点：<br>后者线程会在指定timeout的时间过去之后被唤醒</p></blockquote><p>改进思路：在等待前，记录一个什么时候等待的时刻(开始时间<code>begin</code>),<code>this.wait(n);</code>应该有个等待时间n，不能让线程无线等待；等待时间结束后，应该有个经历时间<code>passTime</code>，查看经历了多长时间。如果经历的时间<code>passTime</code>已经超过了参数<code>timeout</code>，就退出循环。</p><p>问题：<code>this.wait(?);</code>应该等多久？</p><p>答：写<code>this.wait(timeout);</code>，会有问题：如果被虚假唤醒，最大等待时间还有剩余，不需要每次等待 最大等待时间。应该设置每轮等待时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取结果</span><br>   <span class="hljs-comment">//timeout：最大等待时间 假设2000</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>           <span class="hljs-comment">//记录一个开始时间</span><br>           <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>           <span class="hljs-comment">//经历的时间</span><br>           <span class="hljs-keyword">long</span> passTime = <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>               <span class="hljs-comment">//推出无线循环的条件，经历时间大于等于最大等待时间</span><br>               <span class="hljs-keyword">if</span> (passTime&gt;=timeout)&#123;<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-keyword">this</span>.wait(timeout);<span class="hljs-comment">//1.虚假唤醒 15:00:01;  第二次进入循环3.this还需要等待2秒吗？不需要，最大时间是2秒，过了1秒，应该最多等1秒！</span><br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace();<br>               &#125;<br>               <span class="hljs-comment">//求得经历的时间</span><br>               passTime = System.currentTimeMillis()-begin; <span class="hljs-comment">//2. 15:00:01 passTime=1s</span><br>           &#125;<br>           <span class="hljs-keyword">return</span> response;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>改进：设置每一轮等待时间<code>waitTime</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//结果</span><br><span class="hljs-keyword">private</span> Object response;<br><span class="hljs-comment">//获取结果</span><br><span class="hljs-comment">//timeout：最大等待时间</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-comment">//记录一个开始时间</span><br><span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br><span class="hljs-comment">//经历的时间</span><br><span class="hljs-keyword">long</span> passTime = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">//这一轮应该等待时间waitTime</span><br><span class="hljs-keyword">long</span> waitTime = timeout - passTime;<br><span class="hljs-comment">//推出无线循环的条件，经历时间大于等于最大等待时间</span><br><span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">this</span>.wait(waitTime);<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//求得经历的时间</span><br>passTime = System.currentTimeMillis() - begin;<br>&#125;<br><span class="hljs-keyword">return</span> response;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试超时，仅等待2秒</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test20&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test20</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        GuardedObject guardedObject = <span class="hljs-keyword">new</span> GuardedObject();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;t1开始执行&quot;</span>);<br>            Object response = guardedObject.getResponse(<span class="hljs-number">2000</span>);<br>            log.debug(<span class="hljs-string">&quot;结果是：&#123;&#125;&quot;</span>,response);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;t2开始执行&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">3</span>);<br>            guardedObject.setResponse(<span class="hljs-keyword">null</span>);<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//增强超时效果</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObject</span> </span>&#123;<br>    <span class="hljs-comment">//结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">//获取结果</span><br>    <span class="hljs-comment">//timeout：最大等待时间</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">//记录一个开始时间</span><br>            <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>            <span class="hljs-comment">//经历的时间</span><br>            <span class="hljs-keyword">long</span> passTime = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//这一轮应该等待时间waitTime</span><br>                <span class="hljs-keyword">long</span> waitTime = timeout - passTime;<br>                <span class="hljs-comment">//推出无线循环的条件，经历时间大于等于最大等待时间</span><br>                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">this</span>.wait(waitTime);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-comment">//求得经历的时间</span><br>                passTime = System.currentTimeMillis() - begin;<br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//产生结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResponse</span><span class="hljs-params">(Object response)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123; <span class="hljs-comment">//this-&gt;实例对象。实例对象不同，锁不同！</span><br>            <span class="hljs-keyword">this</span>.response = response;<br>            <span class="hljs-keyword">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">45</span>:<span class="hljs-number">13</span> [t1] c.Test20 - t1开始执行<br><span class="hljs-number">15</span>:<span class="hljs-number">45</span>:<span class="hljs-number">13</span> [t2] c.Test20 - t2开始执行<br><span class="hljs-number">15</span>:<span class="hljs-number">45</span>:<span class="hljs-number">15</span> [t1] c.Test20 - 结果是：<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p><strong>测试超时，设置this.wait(timeout);花费3秒！</strong></p><p>等待1秒+最大等待时间2秒=3秒</p><p><code>输出</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">54</span>:<span class="hljs-number">38</span> [t2] c.Test20 - t2开始执行<br><span class="hljs-number">15</span>:<span class="hljs-number">54</span>:<span class="hljs-number">38</span> [t1] c.Test20 - t1开始执行<br><span class="hljs-number">15</span>:<span class="hljs-number">54</span>:<span class="hljs-number">41</span> [t1] c.Test20 - 结果是：<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h4 id="4-8-5-4-原理之join"><a href="#4-8-5-4-原理之join" class="headerlink" title="4.8.5.4 *原理之join"></a>4.8.5.4 *原理之join</h4><p><code>join()</code>方法应用了保护性暂停的模式。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">long</span> base = System.currentTimeMillis(); <span class="hljs-comment">//记录了一个开始时间</span><br>    <span class="hljs-keyword">long</span> now = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录一个经历时间</span><br><br>    <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            <span class="hljs-keyword">long</span> delay = millis - now; <span class="hljs-comment">//最大超时时间-经历时间=本轮等待时间</span><br>            <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            wait(delay);<br>            now = System.currentTimeMillis() - base; <span class="hljs-comment">//结束等待后，求得经历时间</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-8-5-5-多任务版-GuardedObject"><a href="#4-8-5-5-多任务版-GuardedObject" class="headerlink" title="4.8.5.5 多任务版 GuardedObject"></a>4.8.5.5 多任务版 GuardedObject</h4><p>图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员</p><p>如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理</p><p><img src="http://image.cryptomartin.top/img/image-20211229202432101.png" alt="image-20211229202432101"></p><p>新增 id 用来标识 Guarded Object</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObject</span> </span>&#123;<br><span class="hljs-comment">// 标识 Guarded Object</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GuardedObject</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> id;<br>&#125;<br><span class="hljs-comment">// 结果</span><br><span class="hljs-keyword">private</span> Object response;<br><span class="hljs-comment">// 获取结果</span><br><span class="hljs-comment">// timeout 表示要等待多久 2000</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-comment">// 开始时间 15:00:00</span><br><span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br><span class="hljs-comment">// 经历的时间</span><br><span class="hljs-keyword">long</span> passedTime = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// 这一轮循环应该等待的时间</span><br><span class="hljs-keyword">long</span> waitTime = timeout - passedTime;<br><span class="hljs-comment">// 经历的时间超过了最大等待时间时，退出循环</span><br><span class="hljs-keyword">if</span> (timeout - passedTime &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">this</span>.wait(waitTime);<br><span class="hljs-comment">// 虚假唤醒 15:00:01</span><br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">// 求得经历时间</span><br>passedTime = System.currentTimeMillis() - begin;<br><span class="hljs-comment">// 15:00:02 1s</span><br>&#125;<br><span class="hljs-keyword">return</span> response;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 产生结果</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">complete</span><span class="hljs-params">(Object response)</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-comment">// 给结果成员变量赋值</span><br><span class="hljs-keyword">this</span>.response = response;<br><span class="hljs-keyword">this</span>.notifyAll();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>中间解耦类(通用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mailboxes</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="hljs-keyword">new</span> Hashtable&lt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> id = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 产生唯一 id</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">generateId</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> id++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title">getGuardedObject</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br><span class="hljs-keyword">return</span> boxes.remove(id);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title">createGuardedObject</span><span class="hljs-params">()</span> </span>&#123;<br>GuardedObject go = <span class="hljs-keyword">new</span> GuardedObject(generateId());<br>boxes.put(go.getId(), go);<br><span class="hljs-keyword">return</span> go;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title">getIds</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> boxes.keySet();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>业务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 收信</span><br>GuardedObject guardedObject = Mailboxes.createGuardedObject();<br>log.debug(<span class="hljs-string">&quot;开始收信 id:&#123;&#125;&quot;</span>, guardedObject.getId());<br>Object mail = guardedObject.get(<span class="hljs-number">5000</span>);<br>log.debug(<span class="hljs-string">&quot;收到信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, guardedObject.getId(), mail);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br><span class="hljs-keyword">private</span> String mail;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Postman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String mail)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.mail = mail;<br>&#125;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>GuardedObject guardedObject = Mailboxes.getGuardedObject(id);<br>log.debug(<span class="hljs-string">&quot;送信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, id, mail);<br>guardedObject.complete(mail);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-keyword">new</span> People().start();<br>&#125;<br>Sleeper.sleep(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;<br><span class="hljs-keyword">new</span> Postman(id, <span class="hljs-string">&quot;内容&quot;</span> + id).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">10:35:05.689 c.People [Thread-1] - 开始收信 id:3<br>10:35:05.689 c.People [Thread-2] - 开始收信 id:1<br>10:35:05.689 c.People [Thread-0] - 开始收信 id:2<br>10:35:06.688 c.Postman [Thread-4] - 送信 id:2, 内容:内容2<br>10:35:06.688 c.Postman [Thread-5] - 送信 id:1, 内容:内容1<br>10:35:06.688 c.People [Thread-0] - 收到信 id:2, 内容:内容2<br>10:35:06.688 c.People [Thread-2] - 收到信 id:1, 内容:内容1<br>10:35:06.688 c.Postman [Thread-3] - 送信 id:3, 内容:内容3<br>10:35:06.689 c.People [Thread-1] - 收到信 id:3, 内容:内容3<br></code></pre></td></tr></table></figure><h3 id="4-8-6-【模式】异步模式之生产者-消费者"><a href="#4-8-6-【模式】异步模式之生产者-消费者" class="headerlink" title="4.8.6 【模式】异步模式之生产者/消费者"></a>4.8.6 【模式】异步模式之生产者/消费者</h3><h4 id="4-8-6-1-定义"><a href="#4-8-6-1-定义" class="headerlink" title="4.8.6.1 定义"></a>4.8.6.1 定义</h4><p>要点</p><ul><li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应</li><li>消费队列可以用来平衡生产和消费的线程资源</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211229203108502.png" alt="image-20211229203108502"></p><h4 id="4-8-6-2-实现"><a href="#4-8-6-2-实现" class="headerlink" title="4.8.6.2 实现"></a>4.8.6.2 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test21&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test21</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MessageQueue queue = <span class="hljs-keyword">new</span> MessageQueue(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> id = i;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                queue.put(<span class="hljs-keyword">new</span> Message(id, <span class="hljs-string">&quot;值&quot;</span> + id));<br>            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                sleep(<span class="hljs-number">1</span>);<br>                Message message = queue.take();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;消费者&quot;</span>).start();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 消息队列类 ， java 线程之间通信</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.MessageQueue&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageQueue</span> </span>&#123;<br>    <span class="hljs-comment">// 消息的队列集合</span><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// 队列容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capcity;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capcity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.capcity = capcity;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 检查队列是否为空</span><br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列为空, 消费者线程等待&quot;</span>);<br>                    list.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 从队列头部获取消息并返回</span><br>            Message message = list.removeFirst();<br>            log.debug(<span class="hljs-string">&quot;已消费消息 &#123;&#125;&quot;</span>, message);<br>            list.notifyAll();<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 存入消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Message message)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-comment">// 检查对象是否已满</span><br>            <span class="hljs-keyword">while</span> (list.size() == capcity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列已满, 生产者线程等待&quot;</span>);<br>                    list.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将消息加入队列尾部</span><br>            list.addLast(message);<br>            log.debug(<span class="hljs-string">&quot;已生产消息 &#123;&#125;&quot;</span>, message);<br>            list.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> Object value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Message&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, value=&quot;</span> + value +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">20:54:31 [生产者0] c.MessageQueue - 已生产消息 Message&#123;id=0, value=值0&#125;<br>20:54:31 [生产者1] c.MessageQueue - 已生产消息 Message&#123;id=1, value=值1&#125;<br>20:54:31 [生产者2] c.MessageQueue - 队列已满, 生产者线程等待<br>20:54:32 [消费者] c.MessageQueue - 已消费消息 Message&#123;id=0, value=值0&#125;<br>20:54:32 [生产者2] c.MessageQueue - 已生产消息 Message&#123;id=2, value=值2&#125;<br>20:54:33 [消费者] c.MessageQueue - 已消费消息 Message&#123;id=1, value=值1&#125;<br>20:54:34 [消费者] c.MessageQueue - 已消费消息 Message&#123;id=2, value=值2&#125;<br>20:54:35 [消费者] c.MessageQueue - 队列为空, 消费者线程等待<br></code></pre></td></tr></table></figure><h2 id="4-9-Park-Unpark"><a href="#4-9-Park-Unpark" class="headerlink" title="4.9 Park/Unpark"></a>4.9 Park/Unpark</h2><h3 id="4-9-1-基本使用"><a href="#4-9-1-基本使用" class="headerlink" title="4.9.1 基本使用"></a>4.9.1 基本使用</h3><p>它们是 <code>LockSupport</code> 类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 暂停当前线程</span><br>LockSupport.park(); <br><br><span class="hljs-comment">// 恢复某个线程的运行</span><br>LockSupport.unpark(暂停线程对象)<br></code></pre></td></tr></table></figure><p><strong>先 park 再 unpark</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>sleep(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>LockSupport.park();<br>log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);<br>&#125;<br>,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br>sleep(<span class="hljs-number">2</span>);<br>log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>LockSupport.unpark(t1);<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">52.585</span> c.TestParkUnpark [t1] - start... <br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">53.589</span> c.TestParkUnpark [t1] - park... <br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">54.583</span> c.TestParkUnpark [main] - unpark... <br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">54.583</span> c.TestParkUnpark [t1] - resume...<br></code></pre></td></tr></table></figure><p><strong>先 unpark 再 park</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>sleep(<span class="hljs-number">2</span>);<br>log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>LockSupport.park();<br>log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br>sleep(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>LockSupport.unpark(t1);<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">50.765</span> c.TestParkUnpark [t1] - start... <br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">51.764</span> c.TestParkUnpark [main] - unpark... <br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">52.769</span> c.TestParkUnpark [t1] - park... <br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">52.769</span> c.TestParkUnpark [t1] - resume...<br></code></pre></td></tr></table></figure><h3 id="4-9-2-特点"><a href="#4-9-2-特点" class="headerlink" title="4.9.2 特点"></a>4.9.2 特点</h3><p>与 Object 的 wait &amp; notify 相比</p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li><li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li></ul><h3 id="4-9-3-原理之park-amp-unpark"><a href="#4-9-3-原理之park-amp-unpark" class="headerlink" title="4.9.3 * 原理之park&amp;unpark"></a>4.9.3 * 原理之park&amp;unpark</h3><p>每个线程都有自己的一个 Parker 对象，由三部分组成 <code>_counter</code> ， <code>_cond</code> 和 <code>_mutex</code> 打个比喻</p><ul><li>线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中的备用干粮（0 为耗尽，1 为充足）</li><li>调用 park 就是要看需不需要停下来歇息<ul><li>如果备用干粮耗尽，那么钻进帐篷歇息</li><li>如果备用干粮充足，那么不需停留，继续前进</li></ul></li><li>调用 unpark，就好比令干粮充足<ul><li>如果这时线程还在帐篷，就唤醒让他继续前进</li><li>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进<ul><li>因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮</li></ul></li></ul></li></ul><p><img src="http://image.cryptomartin.top/img/image-20211230142714631.png" alt="image-20211230142714631"></p><ol><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁</li><li>线程进入 _cond 条件变量阻塞</li><li>设置 _counter = 0</li></ol><p><img src="http://image.cryptomartin.top/img/image-20211230142906331.png" alt="image-20211230142906331"></p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0</li><li>Thread_0 恢复运行</li><li>设置 _counter 为 0</li></ol><p><strong>调用unpark再调用park</strong></p><p><img src="http://image.cryptomartin.top/img/image-20211230143136595.png" alt="image-20211230143136595"></p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</li><li>设置 _counter 为 0</li></ol><h2 id="4-10-重新理解线程状态转换"><a href="#4-10-重新理解线程状态转换" class="headerlink" title="4.10 重新理解线程状态转换"></a>4.10 重新理解线程状态转换</h2><p><img src="http://image.cryptomartin.top/img/image-20211230143657808.png" alt="image-20211230143657808"></p><p>假设有线程 <code>Thread t</code></p><h3 id="4-10-1-情况1-NEW-–-gt-RUNNABLE"><a href="#4-10-1-情况1-NEW-–-gt-RUNNABLE" class="headerlink" title="4.10.1 情况1 NEW –&gt; RUNNABLE"></a>4.10.1 情况1 NEW –&gt; RUNNABLE</h3><p>当线程调用 <code>t.start()</code> 方法时，由 <code>NEW --&gt; RUNNABLE</code></p><p>RUNNABLE包含：</p><ul><li>可运行状态：可以获得CPU时间片的状态</li><li>运行状态：已经获得时间片，正在CPU执行的状态</li><li>阻塞状态：调用操作系统的阻塞IO的API，它会陷入阻塞，但在Java层面看不出来，依旧是RUNNABLE状态</li></ul><h3 id="4-10-2-情况2-RUNNABLE-lt-–-gt-WAITING"><a href="#4-10-2-情况2-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="4.10.2 情况2 RUNNABLE &lt;–&gt;WAITING"></a>4.10.2 情况2 RUNNABLE &lt;–&gt;WAITING</h3><p>t 线程用 <code>synchronized(obj) </code>获取了对象锁后</p><ul><li>调用 <code>obj.wait() </code>方法时，t 线程从 <code>RUNNABLE --&gt; WAITING</code></li><li>调用 <code>obj.notify()</code> ， <code>obj.notifyAll() </code>，<code> t.interrupt()</code> 时<ul><li>竞争锁成功，t 线程从 <code>WAITING --&gt; RUNNABLE</code></li><li>竞争锁失败，t 线程从 <code>WAITING --&gt; BLOCKED</code></li></ul></li></ul><blockquote><p>在entryList中排队竞争锁，这时线程是处于BLOCKED状态</p></blockquote><h3 id="4-10-3-情况3-RUNNABLE-lt-–-gt-WAITING"><a href="#4-10-3-情况3-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="4.10.3 情况3 RUNNABLE &lt;–&gt;WAITING"></a>4.10.3 情况3 RUNNABLE &lt;–&gt;WAITING</h3><ul><li>当前线程调用 <code>t.join()</code> 方法时，当前线程从 <code>RUNNABLE --&gt; WAITING</code><ul><li>注意是当前线程在t 线程对象的监视器上等待</li></ul></li><li>t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 <code>WAITING --&gt; RUNNABLE</code></li></ul><h3 id="4-10-4-情况4-RUNNABLE-lt-–-gt-WAITING"><a href="#4-10-4-情况4-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="4.10.4 情况4 RUNNABLE &lt;–&gt;WAITING"></a>4.10.4 情况4 RUNNABLE &lt;–&gt;WAITING</h3><ul><li><p>当前线程调用 <code>LockSupport.park()</code> 方法会让当前线程从 <code>RUNNABLE --&gt; WAITING</code></p></li><li><p>调用 <code>LockSupport.unpark</code>(目标线程) 或调用了线程 的 <code>interrupt()</code> ，会让目标线程从 <code>WAITING --&gt; RUNNABLE</code></p></li></ul><h3 id="4-10-5-情况5-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#4-10-5-情况5-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="4.10.5 情况5 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>4.10.5 情况5 RUNNABLE &lt;–&gt; TIMED_WAITING</h3><p>t 线程用 <code>synchronized(obj)</code> 获取了对象锁后</p><ul><li>调用 <code>obj.wait(long n)</code> 方法时，t 线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li><li>t 线程等待时间超过了 n 毫秒，或调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt()</code> 时<ul><li>竞争锁成功，t 线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li><li>竞争锁失败，t 线程从 <code>TIMED_WAITING --&gt; BLOCKED</code></li></ul></li></ul><h3 id="4-10-6-情况6-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#4-10-6-情况6-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="4.10.6 情况6 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>4.10.6 情况6 RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 <code>t.join(long n)</code> 方法时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code><ul><li>注意是当前线程在t 线程对象的监视器上等待</li></ul></li><li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从<code>TIMED_WAITING --&gt; RUNNABLE</code></li></ul><h3 id="4-10-7-情况7-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#4-10-7-情况7-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="4.10.7 情况7 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>4.10.7 情况7 RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 <code>Thread.sleep(long n)</code> ，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li><li>当前线程等待时间超过了 n 毫秒，当前线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li></ul><h3 id="4-10-8-情况8-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#4-10-8-情况8-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="4.10.8 情况8 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>4.10.8 情况8 RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis)</code> 时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li><li>调用 <code>LockSupport.unpark</code>(目标线程) 或调用了线程 的 <code>interrupt()</code> ，或是等待超时，会让目标线程从<code>TIMED_WAITING--&gt; RUNNABLE</code></li></ul><h3 id="4-10-9-情况9-RUNNABLE-lt-–-gt-BLOCKED"><a href="#4-10-9-情况9-RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="4.10.9 情况9 RUNNABLE &lt;–&gt; BLOCKED"></a>4.10.9 情况9 RUNNABLE &lt;–&gt; BLOCKED</h3><ul><li>t 线程用 <code>synchronized(obj)</code> 获取了对象锁时如果竞争失败，从 <code>RUNNABLE --&gt; BLOCKED</code></li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 <code>BLOCKED</code> 的线程重新竞争，如果其中 t 线程竞争成功，从 <code>BLOCKED --&gt; RUNNABLE</code> ，其它失败的线程仍然 <code>BLOCKED</code></li></ul><h3 id="4-10-10-RUNNABLE-lt-–-gt-TERMINATED"><a href="#4-10-10-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="4.10.10 RUNNABLE &lt;–&gt; TERMINATED"></a>4.10.10 RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线程所有代码运行完毕，进入 <code>TERMINATED</code></p><h2 id="4-11-多把锁"><a href="#4-11-多把锁" class="headerlink" title="4.11 多把锁"></a>4.11 多把锁</h2><p><strong>多把不相干的锁</strong></p><p>一间大屋子有两个功能：睡觉、学习，互不相干。<br>现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低<br>解决方法是：准备多个房间（多个对象锁）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>log.debug(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>Sleeper.sleep(<span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>log.debug(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>Sleeper.sleep(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">BigRoom bigRoom = <span class="hljs-keyword">new</span> BigRoom();<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>bigRoom.compute();<br>&#125;<br>,<span class="hljs-string">&quot;小南&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>bigRoom.sleep();<br>&#125;<br>,<span class="hljs-string">&quot;小女&quot;</span>).start();<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">12</span>:<span class="hljs-number">13</span>:<span class="hljs-number">54.471</span> [小南] c.BigRoom - study <span class="hljs-number">1</span> 小时<br><span class="hljs-number">12</span>:<span class="hljs-number">13</span>:<span class="hljs-number">55.476</span> [小女] c.BigRoom - sleeping <span class="hljs-number">2</span> 小时<br></code></pre></td></tr></table></figure><ul><li>两个线程都需要锁住<code>BigRoom</code>,导致一个线程陷入阻塞状态等待。</li></ul><p>改进,锁住不同的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object studyRoom = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object bedRoom = <span class="hljs-keyword">new</span> Object();<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (bedRoom) &#123;<br>log.debug(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>Sleeper.sleep(<span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (studyRoom) &#123;<br>log.debug(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>Sleeper.sleep(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">12</span>:<span class="hljs-number">15</span>:<span class="hljs-number">35.069</span> [小南] c.BigRoom - study <span class="hljs-number">1</span> 小时<br><span class="hljs-number">12</span>:<span class="hljs-number">15</span>:<span class="hljs-number">35.069</span> [小女] c.BigRoom - sleeping <span class="hljs-number">2</span> 小时<br></code></pre></td></tr></table></figure><p>将锁的粒度细分</p><ul><li>好处，是可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><h2 id="4-12-活跃性"><a href="#4-12-活跃性" class="headerlink" title="4.12 活跃性"></a>4.12 活跃性</h2><p>活跃性包括：死锁，活锁，饥饿</p><h3 id="4-12-1-死锁"><a href="#4-12-1-死锁" class="headerlink" title="4.12.1 死锁"></a>4.12.1 死锁</h3><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁<br><code>t1 线程</code> 获得 <code>A对象</code> 锁，接下来想获取 <code>B对象</code> 的锁<br><code>t2 线程</code> 获得 <code>B对象</code> 锁，接下来想获取 <code>A对象</code> 的锁 </p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">Object A = <span class="hljs-keyword">new</span> Object();<br>Object B = <span class="hljs-keyword">new</span> Object();<br><br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span> (A) &#123;<br>log.debug(<span class="hljs-string">&quot;lock A&quot;</span>);<br>sleep(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">synchronized</span> (B) &#123;<br>log.debug(<span class="hljs-string">&quot;lock B&quot;</span>);<br>log.debug(<span class="hljs-string">&quot;操作...&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span> (B) &#123;<br>log.debug(<span class="hljs-string">&quot;lock B&quot;</span>);<br>sleep(<span class="hljs-number">0.5</span>);<br><span class="hljs-keyword">synchronized</span> (A) &#123;<br>log.debug(<span class="hljs-string">&quot;lock A&quot;</span>);<br>log.debug(<span class="hljs-string">&quot;操作...&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>);<br>t1.start();<br>t2.start();<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">12</span>:<span class="hljs-number">22</span>:<span class="hljs-number">06.962</span> [t2] c.TestDeadLock - lock B <br><span class="hljs-number">12</span>:<span class="hljs-number">22</span>:<span class="hljs-number">06.962</span> [t1] c.TestDeadLock - lock A<br></code></pre></td></tr></table></figure><h3 id="4-12-2-定位死锁"><a href="#4-12-2-定位死锁" class="headerlink" title="4.12.2 定位死锁"></a>4.12.2 定位死锁</h3><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</p><p><img src="http://image.cryptomartin.top/img/image-20211230154805628.png" alt="image-20211230154805628"></p><p>进程id：11068</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;jstack 11068 //查看进程的线程信息<br>&gt;jconsole //线程 检测死锁<br></code></pre></td></tr></table></figure><h3 id="4-12-3-哲学家就餐问题"><a href="#4-12-3-哲学家就餐问题" class="headerlink" title="4.12.3 哲学家就餐问题"></a>4.12.3 哲学家就餐问题</h3><p><img src="http://image.cryptomartin.top/img/image-20211230163613155.png" alt="image-20211230163613155"></p><p>有五位哲学家，围坐在圆桌旁。</p><ul><li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</li><li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。</li><li>如果筷子被身边的人拿着，自己就得等待</li></ul><p>筷子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chopstick</span> </span>&#123;<br>String name;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chopstick</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>哲学家类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>Chopstick left;<br>Chopstick right;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;<br><span class="hljs-keyword">super</span>(name);<br><span class="hljs-keyword">this</span>.left = left;<br><span class="hljs-keyword">this</span>.right = right;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);<br>Sleeper.sleep(<span class="hljs-number">1</span>);<br>&#125;<br>    <br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-comment">// 获得左手筷子</span><br><span class="hljs-keyword">synchronized</span> (left) &#123;<br><span class="hljs-comment">// 获得右手筷子</span><br><span class="hljs-keyword">synchronized</span> (right) &#123;<br><span class="hljs-comment">// 吃饭</span><br>eat();<br>&#125;<br><span class="hljs-comment">// 放下右手筷子</span><br>&#125;<br><span class="hljs-comment">// 放下左手筷子</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就餐：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Chopstick c1 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;1&quot;</span>);<br>Chopstick c2 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;2&quot;</span>);<br>Chopstick c3 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;3&quot;</span>);<br>Chopstick c4 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;4&quot;</span>);<br>Chopstick c5 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;5&quot;</span>);<br><span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();<br><span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();<br><span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();<br><span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();<br><span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();<br></code></pre></td></tr></table></figure><p>执行不多会，就执行不下去了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">15.575</span> [苏格拉底] c.Philosopher - eating... <br><span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">15.575</span> [亚里士多德] c.Philosopher - eating... <br><span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">16.580</span> [阿基米德] c.Philosopher - eating... <br><span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">17.580</span> [阿基米德] c.Philosopher - eating... <br><span class="hljs-comment">// 卡在这里, 不向下运行</span><br></code></pre></td></tr></table></figure><p>可以使用 jconsole 检测死锁.</p><p>这种线程没有按预期结束，执行不下去的情况，归类为【活跃性】问题，除了死锁以外，还有活锁和饥饿者两种情况</p><h3 id="4-12-4-活锁"><a href="#4-12-4-活锁" class="headerlink" title="4.12.4 活锁"></a>4.12.4 活锁</h3><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLiveLock</span> </span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-comment">// 期望减到 0 退出循环</span><br><span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>sleep(<span class="hljs-number">0.2</span>);<br>count--;<br>log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-comment">// 期望超过 20 退出循环</span><br><span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>sleep(<span class="hljs-number">0.2</span>);<br>count++;<br>log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-12-5-饥饿"><a href="#4-12-5-饥饿" class="headerlink" title="4.12.5 饥饿"></a>4.12.5 饥饿</h3><p>很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不易演示，讲读写锁时会涉及饥饿问题</p><p><img src="http://image.cryptomartin.top/img/image-20211230164818269.png" alt="image-20211230164818269"></p><p>顺序加锁解锁方案：</p><p><img src="http://image.cryptomartin.top/img/image-20211230164840682.png" alt="image-20211230164840682"></p><p>每个线程都按锁AB的顺序来进行加锁！但会出现饥饿问题</p><h2 id="4-13-ReentrantLock"><a href="#4-13-ReentrantLock" class="headerlink" title="4.13 ReentrantLock"></a>4.13 ReentrantLock</h2><p>相对于 synchronized 它具备如下特点</p><ul><li><p>可中断：A线程拥有锁，B线程可以把锁取消掉</p></li><li><p>可以设置超时时间：规定时间内，得不到锁，就放弃锁了，去做其他事。</p></li><li><p>可以设置为公平锁：防止线程饥饿。FIFO</p></li><li><p>支持多个条件变量：相当于synchronized 的waitSet,waitSet相当于一个条件变量。细分条件</p></li></ul><p>与 synchronized 一样，都支持可重入</p><p>基本语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁</span><br>reentrantLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 临界区</span><br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 释放锁</span><br>reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-13-1-可重入特性"><a href="#4-13-1-可重入特性" class="headerlink" title="4.13.1 可重入特性"></a>4.13.1 可重入特性</h3><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</p><p>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>method1();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;execute method1&quot;</span>);<br>method2();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;execute method2&quot;</span>);<br>method3();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;execute method3&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">17</span>:<span class="hljs-number">59</span>:<span class="hljs-number">11.862</span> [main] c.TestReentrant - execute method1 <br><span class="hljs-number">17</span>:<span class="hljs-number">59</span>:<span class="hljs-number">11.865</span> [main] c.TestReentrant - execute method2 <br><span class="hljs-number">17</span>:<span class="hljs-number">59</span>:<span class="hljs-number">11.865</span> [main] c.TestReentrant - execute method3<br></code></pre></td></tr></table></figure><h3 id="4-13-2-可打断特性-lockInterruptibly"><a href="#4-13-2-可打断特性-lockInterruptibly" class="headerlink" title="4.13.2 可打断特性 -lockInterruptibly"></a>4.13.2 可打断特性 -lockInterruptibly</h3><p>被动防止没有获得锁的线程 无限制等待下去。</p><p>lock -&gt; 调用后一直阻塞到获得锁</p><p>lockInterruptibly -&gt; 调用后一直阻塞到获得锁 但是接受中断信号(题主用过Thread#sleep吧)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>lock.lockInterruptibly();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>log.debug(<span class="hljs-string">&quot;等锁的过程中被打断&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><br><span class="hljs-keyword">try</span> &#123;<br>sleep(<span class="hljs-number">1</span>);<br>t1.interrupt();<br>log.debug(<span class="hljs-string">&quot;执行打断&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">02</span>:<span class="hljs-number">40.520</span> [main] c.TestInterrupt - 获得了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">02</span>:<span class="hljs-number">40.524</span> [t1] c.TestInterrupt - 启动... <br><span class="hljs-number">18</span>:<span class="hljs-number">02</span>:<span class="hljs-number">41.530</span> [main] c.TestInterrupt - 执行打断<br>java.lang.InterruptedException <br> at <br>java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchr<br>onizer.java:<span class="hljs-number">898</span>) <br> at <br>java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron<br>izer.java:<span class="hljs-number">1222</span>) <br> at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="hljs-number">335</span>) <br> at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$<span class="hljs-number">0</span>(TestInterrupt.java:<span class="hljs-number">17</span>) <br> at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>) <br><span class="hljs-number">18</span>:<span class="hljs-number">02</span>:<span class="hljs-number">41.532</span> [t1] c.TestInterrupt - 等锁的过程中被打断<br></code></pre></td></tr></table></figure><ul><li>注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><br><span class="hljs-keyword">try</span> &#123;<br>sleep(<span class="hljs-number">1</span>);<br>t1.interrupt();<br>log.debug(<span class="hljs-string">&quot;执行打断&quot;</span>);<br>sleep(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>log.debug(<span class="hljs-string">&quot;释放了锁&quot;</span>);<br>lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">56.261</span> [main] c.TestInterrupt - 获得了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">56.265</span> [t1] c.TestInterrupt - 启动... <br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">57.266</span> [main] c.TestInterrupt - 执行打断 <span class="hljs-comment">// 这时 t1 并没有被真正打断, 而是仍继续等待锁</span><br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">58.267</span> [main] c.TestInterrupt - 释放了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">58.267</span> [t1] c.TestInterrupt - 获得了锁<br></code></pre></td></tr></table></figure><h3 id="4-13-3-锁超时-trylock"><a href="#4-13-3-锁超时-trylock" class="headerlink" title="4.13.3 锁超时-trylock"></a>4.13.3 锁超时-trylock</h3><p>主动方式避免死等。</p><p><strong>立即失败</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br><span class="hljs-keyword">if</span> (!lock.tryLock()) &#123;<br>log.debug(<span class="hljs-string">&quot;获取立刻失败，返回&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><span class="hljs-keyword">try</span> &#123;<br>sleep(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">15</span>:<span class="hljs-number">02.918</span> [main] c.TestTimeout - 获得了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">15</span>:<span class="hljs-number">02.921</span> [t1] c.TestTimeout - 启动... <br><span class="hljs-number">18</span>:<span class="hljs-number">15</span>:<span class="hljs-number">02.921</span> [t1] c.TestTimeout - 获取立刻失败，返回<br></code></pre></td></tr></table></figure><p><strong>超时失败</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>log.debug(<span class="hljs-string">&quot;获取等待 1s 后失败，返回&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><span class="hljs-keyword">try</span> &#123;<br>sleep(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">19</span>:<span class="hljs-number">40.537</span> [main] c.TestTimeout - 获得了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">19</span>:<span class="hljs-number">40.544</span> [t1] c.TestTimeout - 启动... <br><span class="hljs-number">18</span>:<span class="hljs-number">19</span>:<span class="hljs-number">41.547</span> [t1] c.TestTimeout - 获取等待 1s 后失败，返回<br></code></pre></td></tr></table></figure><p><strong>使用 tryLock 解决哲学家就餐问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chopstick</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> </span>&#123;<br>String name;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chopstick</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>Chopstick left;<br>Chopstick right;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;<br><span class="hljs-keyword">super</span>(name);<br><span class="hljs-keyword">this</span>.left = left;<br><span class="hljs-keyword">this</span>.right = right;<br>&#125;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-comment">// 尝试获得左手筷子</span><br><span class="hljs-keyword">if</span> (left.tryLock()) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 尝试获得右手筷子</span><br><span class="hljs-keyword">if</span> (right.tryLock()) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>eat();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>right.unlock();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>left.unlock(); <span class="hljs-comment">//尝试获得右手筷子失败</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);<br>Sleeper.sleep(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-13-4-公平锁"><a href="#4-13-4-公平锁" class="headerlink" title="4.13.4 公平锁"></a>4.13.4 公平锁</h3><p>ReentrantLock 默认是不公平</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">false</span>);<br>lock.lock();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t&quot;</span> + i).start();<br>&#125;<br><span class="hljs-comment">// 1s 之后去争抢锁</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; start...&quot;</span>);<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;强行插入&quot;</span>).start();<br>lock.unlock();<br></code></pre></td></tr></table></figure><p>强行插入，有机会在中间输出</p><blockquote><p><strong>注意</strong>：该实验不一定总能复现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">t39 running... <br>t40 running... <br>t41 running... <br>t42 running... <br>t43 running... <br>强行插入 start... <br>强行插入 running... <br>t44 running... <br>t45 running... <br>t46 running... <br>t47 running... <br>t49 running..<br></code></pre></td></tr></table></figure><p>改为公平锁后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><p>强行插入，总是在最后输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">t465 running... <br>t464 running... <br>t477 running... <br>t442 running... <br>t468 running... <br>t493 running... <br>t482 running... <br>t485 running... <br>t481 running... <br>强行插入 running...<br></code></pre></td></tr></table></figure><p>公平锁一般没有必要，会降低并发度，后面分析原理时会讲解</p><h3 id="4-13-5-条件变量"><a href="#4-13-5-条件变量" class="headerlink" title="4.13.5 条件变量"></a>4.13.5 条件变量</h3><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待<br>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li></ul><p>使用要点：</p><ul><li>await 前需要获得锁</li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-keyword">static</span> Condition waitCigaretteQueue = lock.newCondition();<br><span class="hljs-keyword">static</span> Condition waitbreakfastQueue = lock.newCondition();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Boolean hasCigrette = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Boolean hasBreakfast = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>lock.lock();<br><span class="hljs-keyword">while</span> (!hasCigrette) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>waitCigaretteQueue.await();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>log.debug(<span class="hljs-string">&quot;等到了它的烟&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>).start();<br>    <br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>lock.lock();<br><span class="hljs-keyword">while</span> (!hasBreakfast) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>waitbreakfastQueue.await();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>log.debug(<span class="hljs-string">&quot;等到了它的早餐&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>).start();<br>sleep(<span class="hljs-number">1</span>);<br>sendBreakfast();<br>sleep(<span class="hljs-number">1</span>);<br>sendCigarette();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendCigarette</span><span class="hljs-params">()</span> </span>&#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;送烟来了&quot;</span>);<br>hasCigrette = <span class="hljs-keyword">true</span>;<br>waitCigaretteQueue.signal();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendBreakfast</span><span class="hljs-params">()</span> </span>&#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;送早餐来了&quot;</span>);<br>hasBreakfast = <span class="hljs-keyword">true</span>;<br>waitbreakfastQueue.signal();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">27.680</span> [main] c.TestCondition - 送早餐来了<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">27.682</span> [Thread-<span class="hljs-number">1</span>] c.TestCondition - 等到了它的早餐<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">28.683</span> [main] c.TestCondition - 送烟来了<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">28.683</span> [Thread-<span class="hljs-number">0</span>] c.TestCondition - 等到了它的烟<br></code></pre></td></tr></table></figure><h2 id="4-14-【模式】同步模式之顺序控制"><a href="#4-14-【模式】同步模式之顺序控制" class="headerlink" title="4.14 【模式】同步模式之顺序控制"></a>4.14 【模式】同步模式之顺序控制</h2><h3 id="4-14-1-固定运行顺序"><a href="#4-14-1-固定运行顺序" class="headerlink" title="4.14.1 固定运行顺序"></a>4.14.1 固定运行顺序</h3><p>比如，必须先打印 2 后 1</p><h4 id="4-14-1-1-wait-notify-版"><a href="#4-14-1-1-wait-notify-版" class="headerlink" title="4.14.1.1 wait notify 版"></a>4.14.1.1 wait notify 版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test25&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test25</span> </span>&#123;<br>    <span class="hljs-comment">//锁对象</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-comment">//标记线程t2是否打印2？</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> t2runned = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//线程t1</span><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">while</span> (!t2runned)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">//线程t2</span><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                t2runned=<span class="hljs-keyword">true</span>;<br>                lock.notify();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">28</span>:<span class="hljs-number">47</span> [t2] c.Test25 - <span class="hljs-number">2</span><br><span class="hljs-number">11</span>:<span class="hljs-number">28</span>:<span class="hljs-number">47</span> [t1] c.Test25 - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="4-14-1-2-Park-Unpark-版"><a href="#4-14-1-2-Park-Unpark-版" class="headerlink" title="4.14.1.2  Park Unpark 版"></a>4.14.1.2  Park Unpark 版</h4><p>park 和 unpark 方法比较灵活，他俩谁先调用，谁后调用无所谓。并且是以线程为单位进行『暂停』和『恢复』，不需要『同步对象』和『运行标记』</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test26&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test26</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;);<br><br>        Thread t2= <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>            LockSupport.unpark(t1);<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-14-2-交替输出"><a href="#4-14-2-交替输出" class="headerlink" title="4.14.2 交替输出"></a>4.14.2 交替输出</h3><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现</p><h4 id="4-14-2-1-wait-notify-版"><a href="#4-14-2-1-wait-notify-版" class="headerlink" title="4.14.2.1 wait notify 版"></a>4.14.2.1 wait notify 版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test27&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test27</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        WaitNotify wn = <span class="hljs-keyword">new</span> WaitNotify(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br><br>        Thread a = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            wn.print(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        &#125;);<br><br>        Thread b = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            wn.print(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        &#125;);<br><br>        Thread c = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            wn.print(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>        &#125;);<br><br>        a.start();<br>        b.start();<br>        c.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    等待标记   下一次标记</span><br><span class="hljs-comment">a     1         2</span><br><span class="hljs-comment">b     2         3</span><br><span class="hljs-comment">c     3         1</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotify</span> </span>&#123;<br>    <span class="hljs-comment">//标记轮到哪个</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flag;<br>    <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WaitNotify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.flag = flag;<br>        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> waitFlag, <span class="hljs-keyword">int</span> nextFlag)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= loopNumber; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">while</span> (flag != waitFlag) &#123;<span class="hljs-comment">//判断是不是轮到waitFlag,如果没轮到就等待</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//如果轮到自己，就打印;并且修改 flag的值为nextFlag;唤醒其他线程</span><br>                System.out.print(str);<br>                flag = nextFlag;<br>                <span class="hljs-keyword">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-14-2-2-await-signal-版"><a href="#4-14-2-2-await-signal-版" class="headerlink" title="4.14.2.2 await signal 版"></a>4.14.2.2 await signal 版</h4><p>条件变量（Condition Variable）的一般用法是：线程 A 等待某个条件并挂起，直到线程 B 设置了这个条件，并通知条件变量，然后线程 A 被唤醒。经典的「生产者-消费者」问题就可以用条件变量来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test30&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test30</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        AwaitSignal as = <span class="hljs-keyword">new</span> AwaitSignal(<span class="hljs-number">5</span>);<br><br>        Condition aCondition = as.newCondition();<br>        Condition bCondition = as.newCondition();<br>        Condition cCondition = as.newCondition();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            as.print(<span class="hljs-string">&quot;a&quot;</span>, aCondition, bCondition);<br>        &#125;, <span class="hljs-string">&quot;a&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            as.print(<span class="hljs-string">&quot;b&quot;</span>, bCondition, cCondition);<br>        &#125;, <span class="hljs-string">&quot;b&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            as.print(<span class="hljs-string">&quot;c&quot;</span>, cCondition, aCondition);<br>        &#125;, <span class="hljs-string">&quot;c&quot;</span>).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        as.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            aCondition.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            as.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> </span>&#123;<br>    <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AwaitSignal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, Condition current, Condition next)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            lock();<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                current.await(); <span class="hljs-comment">//所有线程进入等待，释放锁</span><br>                <span class="hljs-comment">//被唤醒后，打印</span><br>                System.out.print(str);<br>                <span class="hljs-comment">//唤醒下一个线程</span><br>                next.signal();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-14-2-3-park-unpark-版"><a href="#4-14-2-3-park-unpark-版" class="headerlink" title="4.14.2.3 park unpark 版"></a>4.14.2.3 park unpark 版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test31&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test31</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Thread t1;<br>    <span class="hljs-keyword">static</span> Thread t2;<br>    <span class="hljs-keyword">static</span> Thread t3;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ParkUnPark parkUnPark = <span class="hljs-keyword">new</span> ParkUnPark(<span class="hljs-number">5</span>);<br>        t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            parkUnPark.print(<span class="hljs-string">&quot;a&quot;</span>, t2);<br>        &#125;);<br><br>        t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            parkUnPark.print(<span class="hljs-string">&quot;b&quot;</span>, t3);<br>        &#125;);<br><br>        t3 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            parkUnPark.print(<span class="hljs-string">&quot;c&quot;</span>, t1);<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>        LockSupport.unpark(t1);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkUnPark</span> </span>&#123;<br>    <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> looNumber;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParkUnPark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> looNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.looNumber = looNumber;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, Thread next)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; looNumber; i++) &#123;<br>            LockSupport.park();<span class="hljs-comment">//当前线程等待</span><br>            <span class="hljs-comment">//当前线程打印字符</span><br>            System.out.print(str);<br>            <span class="hljs-comment">//唤醒下一个线程</span><br>            LockSupport.unpark(next);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-15-本章小结"><a href="#4-15-本章小结" class="headerlink" title="4.15 本章小结"></a>4.15 本章小结</h2><p>本章我们需要重点掌握的是：</p><ul><li>分析多线程访问共享资源时，哪些代码片段属于临界区</li><li>使用 synchronized 互斥解决临界区的线程安全问题<ul><li>掌握 synchronized 锁对象语法</li><li>掌握 synchronzied 加载成员方法和静态方法语法</li><li>掌握 wait/notify 同步方法</li></ul></li><li>使用 lock 互斥解决临界区的线程安全问题<ul><li>掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量</li></ul></li><li>学会分析变量的线程安全性、掌握常见线程安全类的使用</li><li>了解线程活跃性问题：死锁、活锁、饥饿</li><li>应用方面<ul><li>互斥：使用 synchronized 或 Lock 达到共享资源互斥效果</li><li>同步：使用 wait/notify 或 Lock 的条件变量来达到线程间通信效果</li></ul></li><li>原理方面<ul><li>monitor、synchronized 、wait/notify 原理</li><li>synchronized 进阶原理</li><li>park &amp; unpark 原理</li></ul></li><li>模式方面<ul><li>同步模式之保护性暂停</li><li>异步模式之生产者消费者</li><li>同步模式之顺序控制</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 JVM的内存结构</title>
    <link href="/2021/12/24/%E7%AC%AC%E4%B8%80%E7%AB%A0-JVM%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/2021/12/24/%E7%AC%AC%E4%B8%80%E7%AB%A0-JVM%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-JVM的内存结构"><a href="#第一章-JVM的内存结构" class="headerlink" title="第一章 JVM的内存结构"></a>第一章 JVM的内存结构</h1><p><strong>本章内容</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li></ul><h2 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h2><p>所处位置</p><p><img src="http://image.cryptomartin.top/img/image-20211222083645693.png" alt="image-20211222083645693"></p><h3 id="1-1-1-定义"><a href="#1-1-1-定义" class="headerlink" title="1.1.1 定义"></a>1.1.1 定义</h3><p>Program Counter Register 程序计数器（寄存器）</p><ul><li><p>作用：记住下一条JVM指令的执行地址。</p></li><li><p>特点</p><ul><li>是线程私有的（每个线程都有自己的程序计数器）</li><li>不会存在内存溢出</li></ul></li></ul><p>物理上，是通过寄存器实现的。</p><h3 id="1-1-2-作用"><a href="#1-1-2-作用" class="headerlink" title="1.1.2 作用"></a>1.1.2 作用</h3><p><img src="http://image.cryptomartin.top/img/image-20211222084432356.png" alt="image-20211222084432356"></p><blockquote><p>1.java源代码不能直接被执行，得经过编译。编译成左侧的二进制的字节码，叫作JVM指令。</p><p>2.JVM指令直接交给CPU，还不能执行；必须经过解释器，解释成机器码，然后再交给CPU执行。</p></blockquote><p>作用：记住下一条JVM指令的执行地址。</p><ul><li><p>图中的数字，可以理解为JVM指令对应的内存地址，当这些JVM指令被加载到虚拟机内存后，会有一个地址信息，JVM根据地址信息可以找到JVM指令，来执行它。</p></li><li><p>当这些指令被加载JVM内存以后，JVM会有这些地址信息。根据地址信息找到第一条，当第一条<code>0: getstatic #20</code>执行，与此同时，会把下一条执行的地址<code>3</code>放入程序计数器；等第一条执行完以后，<code>解释器</code>会到<code>程序计数器</code>中找到下一条执行的指令地址<code>3</code>，在<code>3</code>指令执行的同时，会把<code>4</code>地址放入程序计数器。重复！</p></li></ul><h2 id="1-2-虚拟机栈"><a href="#1-2-虚拟机栈" class="headerlink" title="1.2 虚拟机栈"></a>1.2 虚拟机栈</h2><p><img src="http://image.cryptomartin.top/img/image-20211222204215587.png" alt="image-20211222204215587"></p><p>虚拟机栈，就是线程运行需要的内存空间。</p><p>栈帧，就是每个方法运行需要的内存空间。一个栈帧就对应一次方法的调用。</p><p>一个栈由多个栈帧组成。</p><h3 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1 定义"></a>1.2.1 定义</h3><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><ul><li>每个线程运行时所需要的内存，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p>问题辨析：</p><ol><li><p>垃圾回收是否涉及栈内存？不涉及，栈帧内存每次方法结束后，都会被弹出栈，会被自动回收，不需要垃圾回收管理。</p></li><li><p>栈内存分配越大越好吗？不是。栈越大，线程数会少。一般采用系统默认的栈内存1024kb就好了。</p></li><li><p>方法内的局部变量是否线程安全？</p><ul><li><p>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的</p></li><li><p>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</p></li></ul></li></ol><p><img src="http://image.cryptomartin.top/img/image-20211222225101335.png" alt="image-20211222225101335"></p><h3 id="1-2-2-栈溢出"><a href="#1-2-2-栈溢出" class="headerlink" title="1.2.2 栈溢出"></a>1.2.2 栈溢出</h3><p>什么情况下会导致栈溢出？</p><ul><li>栈帧过多导致栈内存溢出 （递归/对象相互引用…）</li><li>栈帧过大导致栈内存溢出</li></ul><h3 id="1-2-3-线程运行诊断"><a href="#1-2-3-线程运行诊断" class="headerlink" title="1.2.3 线程运行诊断"></a>1.2.3 线程运行诊断</h3><p>案例1： cpu 占用过多</p><p>定位</p><ul><li>用top定位哪个进程对cpu的占用过高，但定位不到是哪个线程导致问题</li><li>ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高）</li><li>jstack 进程id<ul><li>可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号（线程id 转为十六进制查看）</li></ul></li></ul><p>案例2：程序运行很长时间没有结果</p><p>可能发生死锁。可以使用案例1方法查看。</p><h2 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h2><p><img src="http://image.cryptomartin.top/img/image-20211222233156739.png" alt="image-20211222233156739"></p><p>本地方法：不是由java编写的代码。有时候需要通过调用操作系统，这时候需要c或者c++编写的本地方法来与操作系统底层API交流。</p><p>本地方法栈：给本地方法的调用提供内存空间</p><p>例如：<code>object</code>类里的<code>clone()</code>方法</p><p><img src="http://image.cryptomartin.top/img/image-20211222234406180.png" alt="image-20211222234406180"></p><h2 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4 堆"></a>1.4 堆</h2><p><img src="http://image.cryptomartin.top/img/image-20211222234505594.png" alt="image-20211222234505594"></p><p>堆和方法区是线程共享的区域；其他内存结构是线程私有的。</p><h3 id="1-4-1-定义"><a href="#1-4-1-定义" class="headerlink" title="1.4.1 定义"></a>1.4.1 定义</h3><p>Heap 堆</p><ul><li>通过 new 关键字，创建对象都会使用堆内存</li></ul><p>特点</p><ul><li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul><h3 id="1-4-2-堆内存溢出"><a href="#1-4-2-堆内存溢出" class="headerlink" title="1.4.2 堆内存溢出"></a>1.4.2 堆内存溢出</h3><p><code>java.lang.OutOfMemoryError: Java heap space</code></p><p><code>-Xmx8m</code>:设置堆内存大小</p><h3 id="1-4-3-堆内存诊断"><a href="#1-4-3-堆内存诊断" class="headerlink" title="1.4.3 堆内存诊断"></a>1.4.3 堆内存诊断</h3><ol><li><p>jps 工具<br>查看当前系统中有哪些 java 进程</p></li><li><p>jmap 工具<br>查看堆内存占用情况 jmap - heap 进程id</p></li><li><p>jconsole 工具<br>图形界面的，多功能的监测工具，可以连续监测</p></li></ol><h3 id="1-4-4-案例"><a href="#1-4-4-案例" class="headerlink" title="1.4.4 案例"></a>1.4.4 案例</h3><ul><li>垃圾回收后，内存占用仍然很高</li></ul><p><code>jvisualvm</code>:可以查看堆Dump,分析查找问题</p><h2 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h2><p><img src="http://image.cryptomartin.top/img/image-20211223152803582.png" alt="image-20211223152803582"> </p><h3 id="1-5-1-定义"><a href="#1-5-1-定义" class="headerlink" title="1.5.1 定义"></a>1.5.1 定义</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the &quot;text&quot; segment in an operating system process. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods (§2.9) used in class and instance initialization and interface initialization.<br><br>The method area is created on virtual machine start-up. Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it. This specification does not mandate the location of the method area or the policies used to manage compiled code. The method area may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger method area becomes unnecessary. The memory for the method area does not need to be contiguous.<br><br>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the method area, as well as, in the case of a varying-size method area, control over the maximum and minimum method area size.<br><br>The following exceptional condition is associated with the method area:<br><span class="hljs-bullet">-</span> If memory in the method area cannot be made available to satisfy an allocation request, the Java Virtual Machine throws an OutOfMemoryError.<br></code></pre></td></tr></table></figure><h3 id="1-5-2-组成"><a href="#1-5-2-组成" class="headerlink" title="1.5.2 组成"></a>1.5.2 组成</h3><p><img src="http://image.cryptomartin.top/img/image-20211223153516263.png" alt="image-20211223153516263"></p><p><strong>JVM内存结构1.6</strong></p><ul><li><p>有堆，Method area。</p></li><li><p><code>Method area</code> 是概念上的东西，1.6版本用<code>永久代</code>的方法作为实现。</p></li><li><p><code>永久代</code>包含:存储类的信息(field，method,构造器等等)，类加载器；还有一块运行时常量池，运行池常量池里有个重要的东西<code>StringTable</code>字符串表。</p></li></ul><p><img src="http://image.cryptomartin.top/img/image-20211223154117117.png" alt="image-20211223154117117"></p><p><strong>JVM内存结构1.8</strong></p><ul><li><code>Method area</code>还是概念上的东西</li><li>方法区的实现叫作<code>Metaspace</code>元空间，<code>Metaspace</code>里存储类，类加载器，常量池的信息。</li><li>方法区不占用堆内存了，不是由JVM来管理方法区的内存结构了；方法区被转移到<code>本地内存</code>当中！<code>本地内存</code>-&gt;<code>操作系统内存</code></li><li><code>StringTable</code>字符串表在堆里面</li></ul><h3 id="1-5-3-方法区内存溢出"><a href="#1-5-3-方法区内存溢出" class="headerlink" title="1.5.3 方法区内存溢出"></a>1.5.3 方法区内存溢出</h3><ul><li><p>1.8 以前会导致永久代内存溢出</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 演示永久代内存溢出 java.lang.OutOfMemoryError: PermGen space <br><span class="hljs-bullet">*</span> -XX:MaxPermSize=8m<br></code></pre></td></tr></table></figure></li><li><p>1.8 之后会导致元空间内存溢出</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace <br><span class="hljs-bullet">*</span> -XX:MaxMetaspaceSize=8m<br></code></pre></td></tr></table></figure></li></ul><p><strong>场景</strong></p><ul><li>Spring</li><li>mybatis</li></ul><p>字节码的动态生成。 </p><h3 id="1-5-4-运行时常量池"><a href="#1-5-4-运行时常量池" class="headerlink" title="1.5.4 运行时常量池"></a>1.5.4 运行时常量池</h3><p><code>javap -v HelloWorld.class</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//类的基本信息<br>Classfile /E:/JavaProject/cocurrent/Java<span class="hljs-emphasis">_concurrent/src/main/java/com/sunk/jvm/t1/t5/HelloWorld.class</span><br><span class="hljs-emphasis">  Last modified 2021-12-23; size 444 bytes</span><br><span class="hljs-emphasis">  MD5 checksum b00ce07193edf9b24a43ce9f1cc4d75a</span><br><span class="hljs-emphasis">  Compiled from &quot;HelloWorld.java&quot;</span><br><span class="hljs-emphasis">public class com.sunk.jvm.t1.t5.HelloWorld</span><br><span class="hljs-emphasis">  minor version: 0</span><br><span class="hljs-emphasis">  major version: 52</span><br><span class="hljs-emphasis">  flags: ACC_</span>PUBLIC, ACC<span class="hljs-emphasis">_SUPER</span><br><span class="hljs-emphasis">//常量池</span><br><span class="hljs-emphasis">Constant pool:</span><br><span class="hljs-emphasis">   #1 = Methodref          #6.#15         // java/lang/Object.&quot;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">init</span>&gt;</span></span>&quot;:()V</span><br><span class="hljs-emphasis">   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="hljs-emphasis">   #3 = String             #18            // hello world</span><br><span class="hljs-emphasis">   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="hljs-emphasis">   #5 = Class              #21            // com/sunk/jvm/t1/t5/HelloWorld</span><br><span class="hljs-emphasis">   #6 = Class              #22            // java/lang/Object</span><br><span class="hljs-emphasis">   #7 = Utf8               <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">init</span>&gt;</span></span></span><br><span class="hljs-emphasis">   #8 = Utf8               ()V</span><br><span class="hljs-emphasis">   #9 = Utf8               Code</span><br><span class="hljs-emphasis">  #10 = Utf8               LineNumberTable</span><br><span class="hljs-emphasis">  #11 = Utf8               main</span><br><span class="hljs-emphasis">  #12 = Utf8               ([Ljava/lang/String;)V</span><br><span class="hljs-emphasis">  #13 = Utf8               SourceFile</span><br><span class="hljs-emphasis">  #14 = Utf8               HelloWorld.java</span><br><span class="hljs-emphasis">  #15 = NameAndType        #7:#8          // &quot;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">init</span>&gt;</span></span>&quot;:()V</span><br><span class="hljs-emphasis">  #16 = Class              #23            // java/lang/System</span><br><span class="hljs-emphasis">  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;</span><br><span class="hljs-emphasis">  #18 = Utf8               hello world</span><br><span class="hljs-emphasis">  #19 = Class              #26            // java/io/PrintStream</span><br><span class="hljs-emphasis">  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V</span><br><span class="hljs-emphasis">  #21 = Utf8               com/sunk/jvm/t1/t5/HelloWorld</span><br><span class="hljs-emphasis">  #22 = Utf8               java/lang/Object</span><br><span class="hljs-emphasis">  #23 = Utf8               java/lang/System</span><br><span class="hljs-emphasis">  #24 = Utf8               out</span><br><span class="hljs-emphasis">  #25 = Utf8               Ljava/io/PrintStream;</span><br><span class="hljs-emphasis">  #26 = Utf8               java/io/PrintStream</span><br><span class="hljs-emphasis">  #27 = Utf8               println</span><br><span class="hljs-emphasis">  #28 = Utf8               (Ljava/lang/String;)V</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">//类的方法定义</span><br><span class="hljs-emphasis">&#123;</span><br><span class="hljs-emphasis">  public com.sunk.jvm.t1.t5.HelloWorld(); //构造方法</span><br><span class="hljs-emphasis">    descriptor: ()V</span><br><span class="hljs-emphasis">    flags: ACC_</span>PUBLIC<br><span class="hljs-code">    Code:</span><br><span class="hljs-code">      stack=1, locals=1, args_size=1</span><br><span class="hljs-code">         0: aload_0</span><br><span class="hljs-code">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-code">         4: return</span><br><span class="hljs-code">      LineNumberTable:</span><br><span class="hljs-code">        line 8: 0</span><br><span class="hljs-code"></span><br>  public static void main(java.lang.String[]); //main方法<br><span class="hljs-code">    descriptor: ([Ljava/lang/String;)V</span><br><span class="hljs-code">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="hljs-code">    Code:</span><br><span class="hljs-code">      stack=2, locals=1, args_size=1</span><br><span class="hljs-code">        //从这开始；虚拟机指令</span><br><span class="hljs-code">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;  //#2要去查常量池的表</span><br><span class="hljs-code">         3: ldc           #3                  // String hello world</span><br><span class="hljs-code">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="hljs-code">         8: return</span><br><span class="hljs-code">      LineNumberTable:</span><br><span class="hljs-code">        line 10: 0</span><br><span class="hljs-code">        line 11: 8</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code">SourceFile: &quot;HelloWorld.java&quot;</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><ul><li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li><li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为内存中的真实地址。程序运行时，常量池会放入本地内存中，变成运行时常量池。<code>#1</code>,<code>#2</code>也会变成内存中的地址。</li></ul><h3 id="1-5-5-StringTable"><a href="#1-5-5-StringTable" class="headerlink" title="1.5.5 StringTable"></a>1.5.5 StringTable</h3><ul><li><p>常量池中的字符串仅是符号，第一次用到时才变为对象</p></li><li><p>利用串池的机制，来避免重复创建字符串对象</p></li><li><p>字符串变量拼接的原理是 StringBuilder （1.8）</p></li><li><p>字符串常量拼接的原理是编译期优化</p></li><li><p>可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池</p><ul><li><p>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池;无论有没有，都 会把串池中的对象返回</p></li><li><p>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池； 会把串池中的对象返回</p></li></ul></li></ul><p>先看几道面试题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>String s3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>String s4 = s1 + s2;<br>String s5 = <span class="hljs-string">&quot;ab&quot;</span>;<br>String s6 = s4.intern();<br><br><span class="hljs-comment">// 问</span><br>System.out.println(s3 == s4);<br>System.out.println(s3 == s5);<br>System.out.println(s3 == s6);<br><br>String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>);<br>String x1 = <span class="hljs-string">&quot;cd&quot;</span>;<br>x2.intern();<br><br><span class="hljs-comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢 </span><br>System.out.println(x1 == x2);<br></code></pre></td></tr></table></figure><h4 id="1-5-5-1-常量池与串池的关系"><a href="#1-5-5-1-常量池与串池的关系" class="headerlink" title="1.5.5.1 常量池与串池的关系"></a>1.5.5.1 常量池与串池的关系</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_22</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>        String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译<code>javap -v Demo1_22.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java">Classfile /E:/JavaProject/cocurrent/Java_concurrent/src/main/java/com/sunk/jvm/t1/Demo1_22.class<br>  Last modified <span class="hljs-number">2021</span>-<span class="hljs-number">12</span>-<span class="hljs-number">24</span>; size <span class="hljs-number">320</span> bytes<br>  MD5 checksum 4cc52650a9c6199ee5039970ac0450c0<br>  Compiled from <span class="hljs-string">&quot;Demo1_22.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">sunk</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">t1</span>.<span class="hljs-title">Demo1_22</span></span><br><span class="hljs-class">  <span class="hljs-title">minor</span> <span class="hljs-title">version</span>: 0</span><br><span class="hljs-class">  <span class="hljs-title">major</span> <span class="hljs-title">version</span>: 52</span><br><span class="hljs-class">  <span class="hljs-title">flags</span>: <span class="hljs-title">ACC_PUBLIC</span>, <span class="hljs-title">ACC_SUPER</span></span><br><span class="hljs-class"><span class="hljs-title">Constant</span> <span class="hljs-title">pool</span>:</span><br><span class="hljs-class">   #1 </span>= Methodref          #<span class="hljs-number">6.</span>#<span class="hljs-number">15</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = String             #<span class="hljs-number">16</span>            <span class="hljs-comment">// a</span><br>   #<span class="hljs-number">3</span> = String             #<span class="hljs-number">17</span>            <span class="hljs-comment">// b</span><br>   #<span class="hljs-number">4</span> = String             #<span class="hljs-number">18</span>            <span class="hljs-comment">// ab</span><br>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">19</span>            <span class="hljs-comment">// com/sunk/jvm/t1/Demo1_22</span><br>   #<span class="hljs-number">6</span> = Class              #<span class="hljs-number">20</span>            <span class="hljs-comment">// java/lang/Object</span><br>   #<span class="hljs-number">7</span> = Utf8               &lt;init&gt;<br>   #<span class="hljs-number">8</span> = Utf8               ()V<br>   #<span class="hljs-number">9</span> = Utf8               Code<br>  #<span class="hljs-number">10</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">11</span> = Utf8               main<br>  #<span class="hljs-number">12</span> = Utf8               ([Ljava/lang/String;)V<br>  #<span class="hljs-number">13</span> = Utf8               SourceFile<br>  #<span class="hljs-number">14</span> = Utf8               Demo1_22.java<br>  #<span class="hljs-number">15</span> = NameAndType        #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">16</span> = Utf8               a<br>  #<span class="hljs-number">17</span> = Utf8               b<br>  #<span class="hljs-number">18</span> = Utf8               ab<br>  #<span class="hljs-number">19</span> = Utf8               com/sunk/jvm/t1/Demo1_22<br>  #<span class="hljs-number">20</span> = Utf8               java/lang/Object<br>&#123;<br>  <span class="hljs-keyword">public</span> com.sunk.jvm.t1.Demo1_22();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br>         <span class="hljs-number">2</span>: astore_1<br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br>         <span class="hljs-number">5</span>: astore_2<br>         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>         <span class="hljs-number">8</span>: astore_3<br>         <span class="hljs-number">9</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">10</span>: <span class="hljs-number">3</span><br>        line <span class="hljs-number">11</span>: <span class="hljs-number">6</span><br>        line <span class="hljs-number">12</span>: <span class="hljs-number">9</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">10</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>            <span class="hljs-number">3</span>       <span class="hljs-number">7</span>     <span class="hljs-number">1</span>    s1   Ljava/lang/String;<br>            <span class="hljs-number">6</span>       <span class="hljs-number">4</span>     <span class="hljs-number">2</span>    s2   Ljava/lang/String;<br>            <span class="hljs-number">9</span>       <span class="hljs-number">1</span>     <span class="hljs-number">3</span>    s3   Ljava/lang/String;<br><br>&#125;<br>SourceFile: <span class="hljs-string">&quot;Demo1_22.java&quot;</span><br><br></code></pre></td></tr></table></figure><ul><li> 常量池中的信息，都会被加载到运行时常量池中，这时 a b ab 都是常量池中的符号，还没有变为 java字符串对象</li><li> <code>ldc</code> #2 会把 a符号变为 “a”字符串对象</li><li> 变为 “a”字符串对象后，会到 <code>StringTable</code>中去找有没有取值相同的key（”a”）；如果没有则放入串池。</li><li> 执行完<code>String s1 = &quot;a&quot;;</code>，串池就有 “a”字符串对象  </li><li> 用到才会创建，用不到不会提前创建</li><li> StringTable[“a”,”b”,”ab”] hashtable 结构，不能扩容</li><li> 每个字符串对象，在串池中都是唯一的。</li></ul><h4 id="1-5-5-2-字符串变量拼接"><a href="#1-5-5-2-字符串变量拼接" class="headerlink" title="1.5.5.2 字符串变量拼接"></a>1.5.5.2 字符串变量拼接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_22</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>        String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>        String s4 = s1 + s2;<span class="hljs-comment">//new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString() </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>String s4 = s1 + s2;//new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString() new String(&quot;ab&quot;) </code></p><p>图解：</p><p><img src="http://image.cryptomartin.top/img/image-20211224112919717.png" alt="image-20211224112919717"></p><p><code>StringBuilder</code>的<code>toString</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Create a copy, don&#x27;t share the array</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(value, <span class="hljs-number">0</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据拼接好的值，又创建了新的字符串对象！相当于创建”ab”的字符串对象，存入s4</li></ul><p><strong>问：s3==s4？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>    String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>    String s4 = s1 + s2;<br><br>    System.out.println(s3 == s4 );<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>答案为false。虽然s3的“ab”和s4的“ab”值一样，但s3的”ab”是在串池中的，s4的new String(“ab”)是在堆里面的。</li></ul><h4 id="1-5-5-3-编译期优化"><a href="#1-5-5-3-编译期优化" class="headerlink" title="1.5.5.3 编译期优化"></a>1.5.5.3 编译期优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>    String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>    String s4 = s1 + s2;<br>    String s5 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后：</p><p><img src="http://image.cryptomartin.top/img/image-20211224162436968.png" alt="image-20211224162436968"></p><p>直接找拼接好的 “ab”。串池中已经有了“ab”字符串对象，不会再创建新的“ab”字符串对象了</p><p>问：s3==s5？true</p><p><img src="http://image.cryptomartin.top/img/image-20211224162735236.png" alt="image-20211224162735236"></p><p><strong>原理</strong></p><p><code>String s5 = &quot;a&quot; + &quot;b&quot;;</code>javac在编译期间的优化，结果在编译期间确定为<code>&quot;ab&quot;</code>，已经确定的结果。</p><p><code>String s4 = s1 + s2;</code>,<code>s1</code>,<code>s2</code>是变量，在运行时，引用的值可能被修改，结果是不能确定的；所以在运行期间，用<code>StringBuilder</code>来动态拼接。</p><h4 id="1-5-5-4-intern-放入串池"><a href="#1-5-5-4-intern-放入串池" class="headerlink" title="1.5.5.4 intern,放入串池"></a>1.5.5.4 intern,放入串池</h4><blockquote><p><code>intern()</code>将这个字符串对象尝试放入串池，如果有，则不会放入串池，如果没有则放入串池；无论有没有，都会把串池中的对象返回。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo23</span> </span>&#123;<br>    <span class="hljs-comment">//StringTable:[&quot;a&quot;,&quot;b&quot;]，无&quot;ab&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">// StringBuilder 动态拼接 new String(&quot;ab&quot;)</span><br><br>        <span class="hljs-comment">//堆有 new String(&quot;a&quot;)对象  new String(&quot;b&quot;)对象  new String(&quot;ab&quot;)对象</span><br>        <span class="hljs-comment">//问：我们可以把动态创建的 new String(&quot;ab&quot;)对象里的&quot;ab&quot; 放入串池吗？</span><br>        <span class="hljs-comment">//答：可以，用intern</span><br>        System.out.println(<span class="hljs-string">&quot;s是否等于&#x27;ab&#x27;：&quot;</span>+(s==<span class="hljs-string">&quot;ab&quot;</span>));<br>        String s2 = s.intern();<span class="hljs-comment">//将这个字符串对象尝试放入串池，如果有，则不会放入串池。</span><br>        System.out.println(<span class="hljs-string">&quot;使用s.intern()后，s2是否等于&#x27;ab&#x27;:&quot;</span> + (s2 == <span class="hljs-string">&quot;ab&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">s是否等于&#x27;ab&#x27;：false<br>使用s.intern()后，s2是否等于&#x27;ab&#x27;:true<br></code></pre></td></tr></table></figure><p>如果在s2之前打印s==”ab”,那么使用intern之后，s==”ab”都为false; 所以屏蔽<code>//System.out.println(&quot;s是否等于&#39;ab&#39;：&quot; + (s == &quot;ab&quot;));</code>,这时候，s==”ab”为true，s使用了串池的值”ab”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo23</span> </span>&#123;<br>    <span class="hljs-comment">//StringTable:[&quot;a&quot;,&quot;b&quot;]，无&quot;ab&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">// StringBuilder 动态拼接 new String(&quot;ab&quot;)</span><br><br>        <span class="hljs-comment">//堆有 new String(&quot;a&quot;)对象  new String(&quot;b&quot;)对象  new String(&quot;ab&quot;)对象</span><br>        <span class="hljs-comment">//问：我们可以把动态创建的 new String(&quot;ab&quot;)对象里的&quot;ab&quot; 放入串池吗？</span><br>        <span class="hljs-comment">//答：可以，用intern</span><br>        <span class="hljs-comment">//System.out.println(&quot;s是否等于&#x27;ab&#x27;：&quot; + (s == &quot;ab&quot;));</span><br>        String s2 = s.intern();<span class="hljs-comment">//将这个字符串对象尝试放入串池，如果有，则不会放入串池，会把串池中的对象返回。</span><br>        System.out.println(<span class="hljs-string">&quot;使用s.intern()后，s2是否等于&#x27;ab&#x27;:&quot;</span> + (s2 == <span class="hljs-string">&quot;ab&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;s是否等于&#x27;ab&#x27;：&quot;</span> + (s == <span class="hljs-string">&quot;ab&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">使用s.intern()后，s2是否等于&#x27;ab&#x27;:true<br>s是否等于&#x27;ab&#x27;：true<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo23</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String x = <span class="hljs-string">&quot;ab&quot;</span>;<span class="hljs-comment">//&quot;ab&quot;在串池中</span><br>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">//&quot;ab&quot;在堆里</span><br>        <br>        <span class="hljs-comment">//将这个字符串对象尝试放入串池，如果有，则不会放入串池，如果没有则放入串池；无论有没有，都会把串池中的对象返回。</span><br>        String s2 = s.intern();<span class="hljs-comment">//s2是串池中的&quot;ab&quot;；s是堆里创建出的&quot;ab&quot;</span><br>        System.out.println(<span class="hljs-string">&quot;s2 == x:&quot;</span>+(s2 == x));<br>        System.out.println(<span class="hljs-string">&quot;s == x:&quot;</span>+(s == x));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">s2 == x:true<br>s == x:false<br></code></pre></td></tr></table></figure><h4 id="1-5-5-5-回答最初的问题"><a href="#1-5-5-5-回答最初的问题" class="headerlink" title="1.5.5.5 回答最初的问题"></a>1.5.5.5 回答最初的问题</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> s1 = <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-keyword">String</span> s2 = <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-keyword">String</span> s3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-keyword">String</span> s4 = s1 + s2;<br><span class="hljs-keyword">String</span> s5 = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-keyword">String</span> s6 = s4.<span class="hljs-built_in">intern</span>();<br><br><span class="hljs-comment">// 问</span><br>System.out.<span class="hljs-built_in">println</span>(s3 == s4);<br>System.out.<span class="hljs-built_in">println</span>(s3 == s5);<br>System.out.<span class="hljs-built_in">println</span>(s3 == s6);<br><br><span class="hljs-keyword">String</span> x2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;d&quot;</span>);<br><span class="hljs-keyword">String</span> x1 = <span class="hljs-string">&quot;cd&quot;</span>;<br>x2.<span class="hljs-built_in">intern</span>();<br><br><span class="hljs-comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢 </span><br>System.out.<span class="hljs-built_in">println</span>(x1 == x2);<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">false<br>true<br>true<br>false<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> x2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;d&quot;</span>);<br>x2.<span class="hljs-built_in">intern</span>();<br><span class="hljs-keyword">String</span> x1 = <span class="hljs-string">&quot;cd&quot;</span>;<br><span class="hljs-comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢 </span><br>System.out.<span class="hljs-built_in">println</span>(x1 == x2);<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">true<br></code></pre></td></tr></table></figure><ul><li><code>String x2 = new String(&quot;c&quot;) + new String(&quot;d&quot;);</code>堆中创建字符串对象”cd”</li><li><code>x2.intern();</code>，串池中没有<code>&quot;cd&quot;</code>，则将”cd”加入串池中；</li><li><code>String x1 = &quot;cd&quot;;</code>串池中已经有”cd”，引用串池中已有的”cd”对象。</li><li>JDK1.6:false.</li></ul><h3 id="1-5-6-StringTable的位置"><a href="#1-5-6-StringTable的位置" class="headerlink" title="1.5.6 StringTable的位置"></a>1.5.6 StringTable的位置</h3><p>见 1.5.2 组成</p><h3 id="1-5-7-StringTable-垃圾回收"><a href="#1-5-7-StringTable-垃圾回收" class="headerlink" title="1.5.7 StringTable 垃圾回收"></a>1.5.7 StringTable 垃圾回收</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示 StringTable 垃圾回收</span><br><span class="hljs-comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_7</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123; <span class="hljs-comment">// j=100, j=10000</span><br>                String.valueOf(j).intern();<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;504K(2560K)] 2048K-&gt;781K(9728K), 0.0011268 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br><br></code></pre></td></tr></table></figure><h3 id="1-5-8-StringTable-性能调优"><a href="#1-5-8-StringTable-性能调优" class="headerlink" title="1.5.8 StringTable 性能调优"></a>1.5.8 StringTable 性能调优</h3><ul><li>调整 -XX:StringTableSize=桶个数</li><li>考虑将字符串对象是否入池</li></ul><h2 id="1-6-直接内存-操作系统内存"><a href="#1-6-直接内存-操作系统内存" class="headerlink" title="1.6 直接内存-操作系统内存"></a>1.6 直接内存-操作系统内存</h2><h3 id="1-6-1-定义"><a href="#1-6-1-定义" class="headerlink" title="1.6.1 定义"></a>1.6.1 定义</h3><p>Direct Memory</p><ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211224223955718.png" alt="image-20211224223955718"></p><p>有两块缓冲区:系统缓冲区，java缓冲区</p><p>所以比较慢</p><hr><p><img src="http://image.cryptomartin.top/img/image-20211224224225735.png" alt="image-20211224224225735"></p><ul><li><p>系统出的direct memory ，java可以直接访问。系统和java都可以用直接内存。</p></li><li><p>少了一层缓冲区。</p></li></ul><h3 id="1-6-2-分配和回收原理"><a href="#1-6-2-分配和回收原理" class="headerlink" title="1.6.2 分配和回收原理"></a>1.6.2 分配和回收原理</h3><ul><li>使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法</li><li>ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存</li></ul><p><code>-XX:+DisableExplicatGC</code> ：禁用显式GC，<code>System.gc()</code>；对于直接内存的回收有影响！长时间得不到释放。</p><p>如何解决？直接用Unsafe对象，调用 freeMemory 方法手动释放直接内存。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>JVM学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JVM引言</title>
    <link href="/2021/12/22/%E5%AD%A6%E4%B9%A0JVM%E5%BC%95%E8%A8%80/"/>
    <url>/2021/12/22/%E5%AD%A6%E4%B9%A0JVM%E5%BC%95%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="学习JVM引言"><a href="#学习JVM引言" class="headerlink" title="学习JVM引言"></a>学习JVM引言</h1><h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>Java Virtual Machine - java 程序的运行环境（java 二进制字节码的运行环境）</p><h3 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收功能</li><li>数组下标越界检查</li><li>多态</li></ul><h3 id="比较："><a href="#比较：" class="headerlink" title="比较："></a>比较：</h3><p>jvm jre jdk</p><p><img src="http://image.cryptomartin.top/img/image-20211222072056047.png" alt="image-20211222072056047"></p><p>JVM：屏蔽Java代码与底层的操作系统的差异</p><p>JRE：JVM基础上加上基础类库，就是JRE。基础类库是什么？jang.lang.*,集合类，线程类，日期类，IO类</p><p>JDK：JRE基础上加上编译工具，就是JDK。编译工具有javac，javap等</p><h2 id="学习JVM有什么用？"><a href="#学习JVM有什么用？" class="headerlink" title="学习JVM有什么用？"></a>学习JVM有什么用？</h2><ul><li>面试</li><li>理解底层原理的实现原理</li><li>中高级程序员的必备技能</li></ul><h2 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h2><p><img src="http://image.cryptomartin.top/img/image-20211222073020952.png" alt="image-20211222073020952"></p><blockquote><p><a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines">维基百科参考</a></p></blockquote><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="http://image.cryptomartin.top/img/image-20211222073238466.png" alt="image-20211222073238466"></p><blockquote><p><a href="https://www.javainterviewpoint.com/java-virtual-machine-architecture-in-java/">参考资料</a></p></blockquote><p>一个类从Java源代码编译为二进制字节码以后，经过类加载器，才能被加载到JVM中运行；</p><p>类都是放在<code>Method Area方法区</code>中，类将来创建的实例对象放在<code>Heap堆</code>中，而<code>Heap堆</code>里面的对象调用<code>方法</code>时,又会用到<code>JVM Stacks虚拟机栈</code>，<code>PC Register程序计数器</code>,<code>Native Method Stacks 本地方法栈</code>;</p><p><code>方法</code> 执行时，每行代码是由<code>执行引擎</code>中的<code>Interpret解释器</code>逐行进行一个执行；<code>方法里的热点代码</code>,即被频繁调用的代码，会由一个<code>JIT Compiler即时编译器</code>对<code>方法里的热点代码</code>做一个编译，也可以理解为做优化后的执行。</p><p><code>GC垃圾回收</code>会对<code>Heap堆</code>里面不再被引用的对象进行一个垃圾回收。</p><p>还有一些Java代码不方便实现的功能，必须调用底层操作系统的功能，跟操作系统交互需要一个<code>本地方法接口</code></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>JVM学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章 Java线程</title>
    <link href="/2021/12/20/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/12/20/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-Java线程"><a href="#第三章-Java线程" class="headerlink" title="第三章 Java线程"></a>第三章 Java线程</h1><p><strong>本章内容</strong>：</p><ul><li>创建和运行线程</li><li>查看线程</li><li>线程 API</li><li>线程状态</li></ul><h2 id="3-1-创建和运行线程"><a href="#3-1-创建和运行线程" class="headerlink" title="3.1 创建和运行线程"></a>3.1 创建和运行线程</h2><blockquote><p>每个程序一启动，都有一个主程序线程，称之为主线程。默认已经有一个主线程在运行了。</p></blockquote><h3 id="方法一，直接使用Thread"><a href="#方法一，直接使用Thread" class="headerlink" title="方法一，直接使用Thread"></a>方法一，直接使用Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程对象</span><br>Thread t = <span class="hljs-keyword">new</span> Thread() &#123;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 要执行的任务</span><br> &#125;<br>&#125;;<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//构造方法的参数是给线程指定名字，推荐</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//setName给线程指定名称</span><br>        <span class="hljs-comment">//t.setName(&quot;t1&quot;);</span><br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>        log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:42:09 [main] c.Test1 - running<br>16:42:09 [t1] c.Test1 - running<br></code></pre></td></tr></table></figure><h3 id="方法二，使用Runnable配合Thread"><a href="#方法二，使用Runnable配合Thread" class="headerlink" title="方法二，使用Runnable配合Thread"></a>方法二，使用Runnable配合Thread</h3><p>把【线程】和【任务】（要执行的代码）分开</p><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务（线程要执行的代码）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 要执行的任务</span><br>&#125;<br>&#125;;<br><span class="hljs-comment">// 创建线程对象，把runnable对象放入线程中</span><br>Thread t = <span class="hljs-keyword">new</span> Thread( runnable );<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建可运行的任务对象</span><br>        Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//创建线程对象,这边IDE提示：不建议显示创建线程，请使用线程池。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;t2&quot;</span>);<br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:54:14 [t2] c.Test2 - running<br></code></pre></td></tr></table></figure><p>Java8后可以使用lambda简化代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建可运行的任务对象</span><br>        Runnable runnable = () -&gt; log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>        <span class="hljs-comment">//创建线程对象,这边IDE提示：不建议显示创建线程，请使用线程池。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;t2&quot;</span>);<br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="***** 原理之 Thread 与 Runnable 的关系"></a>***** <strong>原理之</strong> <strong>Thread</strong> <strong>与</strong> <strong>Runnable</strong> 的关系</h3><blockquote><p>Test1是用了哪个run方法？</p></blockquote><p><img src="http://image.cryptomartin.top/img/image-20211218171132351.png" alt="image-20211218171132351"></p><blockquote><p>方法1是重写了父类的run方法，以子类的run方法为准。</p></blockquote><hr><blockquote><p>Test2是用了哪个run方法？</p></blockquote><p><img src="http://image.cryptomartin.top/img/image-20211218170423475.png" alt="image-20211218170423475"></p><p><img src="http://image.cryptomartin.top/img/image-20211218170523199.png" alt="image-20211218170523199"></p><p><img src="http://image.cryptomartin.top/img/image-20211218170708785.png" alt="image-20211218170708785"></p><p><img src="http://image.cryptomartin.top/img/image-20211218170923368.png" alt="image-20211218170923368"></p><blockquote><p>如果有Runnable对象，Thread优先采用Runnable对象的run方法。</p></blockquote><p><strong>小结</strong></p><ul><li>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合</li><li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><blockquote><p>更推荐Runnable的方法！！！优先组合关系，不是继承关系。</p></blockquote><h3 id="方法三，FutureTask配置Thread"><a href="#方法三，FutureTask配置Thread" class="headerlink" title="方法三，FutureTask配置Thread"></a>方法三，FutureTask配置Thread</h3><p><img src="http://image.cryptomartin.top/img/image-20211218172101398.png" alt="image-20211218172101398"></p><p><img src="http://image.cryptomartin.top/img/image-20211218172237257.png" alt="image-20211218172237257"></p><p><img src="http://image.cryptomartin.top/img/image-20211218172311299.png" alt="image-20211218172311299"></p><p>Future中的get方法可以返回任务执行的结果；Runnable是void没有返回结果。</p><hr><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        FutureTask&lt;Integer&gt; task =<span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>                <span class="hljs-comment">//让当前线程睡眠1s</span><br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//FutureTask实现了Runnable接口，所以可以放入Thread。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(task,<span class="hljs-string">&quot;t1&quot;</span>);<br>        t.start();<br><br>        <span class="hljs-comment">//主线程阻塞，等待结果FutureTask结果返回；FutureTask实现了任务及异步结果的集合功能</span><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,task.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">17:32:24 [t1] c.Test2 - running...<br>17:32:26 [main] c.Test2 - 100<br></code></pre></td></tr></table></figure><h2 id="3-2-观察多个线程同时运行"><a href="#3-2-观察多个线程同时运行" class="headerlink" title="3.2 观察多个线程同时运行"></a>3.2 观察多个线程同时运行</h2><p>主要是理解</p><ul><li>交替执行</li><li>谁先谁后，不由我们控制</li></ul><h2 id="3-3-查看进程线程的方法"><a href="#3-3-查看进程线程的方法" class="headerlink" title="3.3 查看进程线程的方法"></a>3.3 查看进程线程的方法</h2><p><strong>windows</strong></p><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li><code>tasklist</code> 查看进程</li><li><code>taskkill</code> 杀死进程</li></ul><p><strong>linux</strong></p><ul><li><code>ps -fe</code> 查看所有进程</li><li><code>ps -fT -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>top</code> 按大写 H 切换是否显示线程</li><li><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li></ul><h2 id="3-4-原理之线程运行"><a href="#3-4-原理之线程运行" class="headerlink" title="3.4 * 原理之线程运行"></a>3.4 * 原理之线程运行</h2><h3 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h3><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</p><ul><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法，互不干扰</li></ul><p>线程运行原理-栈帧图解：</p><p><img src="http://image.cryptomartin.top/img/image-20211218224550413.png" alt="image-20211218224550413"></p><h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul><h2 id="3-5-常见方法"><a href="#3-5-常见方法" class="headerlink" title="3.5 常见方法"></a>3.5 常见方法</h2><p><img src="http://image.cryptomartin.top/img/image-20211218230238918.png" alt="image-20211218230238918"></p><p><img src="http://image.cryptomartin.top/img/image-20211218230301086.png" alt="image-20211218230301086"></p><p><img src="http://image.cryptomartin.top/img/image-20211218230316126.png" alt="image-20211218230316126"></p><h3 id="3-5-1-Start与run"><a href="#3-5-1-Start与run" class="headerlink" title="3.5.1 Start与run"></a>3.5.1 Start与run</h3><p><strong>调用run方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>            log.debug(<span class="hljs-string">&quot;t1 Thread is running...&quot;</span>);<br>        &#125;<br>    &#125;;<br>    t1.run();<br>    log.debug(<span class="hljs-string">&quot;main Thread is running...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">23:16:48 [main] c.Test4 - t1 Thread is running...<br>23:16:48 [main] c.Test4 - main Thread is running...<br></code></pre></td></tr></table></figure><p>程序仍在 main 线程运行。</p><p><strong>调用start方法</strong></p><p>将上述代码中的<code>t1.run()</code>改为<code>t1.start()</code>，输出</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">23:21:01 [t1] c.Test4 - t1 Thread is running...<br>23:21:01 [main] c.Test4 - main Thread is running...<br></code></pre></td></tr></table></figure><p>程序在 t1 线程运行。</p><p><strong>小结</strong></p><ul><li>直接调用 <code>run()</code> 是在主线程中执行了 <code>run()</code>，没有启动新的线程</li><li>使用 <code>start()</code> 是启动新的线程，通过新的线程间接执行 <code>run()</code>方法 中的代码</li></ul><h3 id="3-5-2-sleep与yield"><a href="#3-5-2-sleep与yield" class="headerlink" title="3.5.2 sleep与yield"></a>3.5.2 sleep与yield</h3><p><strong>sleep</strong></p><ol><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 <code>InterruptedException</code>异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】</li><li>睡眠结束后的线程未必会立刻得到执行(需要分配到cpu时间片)</li><li>建议用 TimeUnit 的 <code>sleep()</code> 代替 Thread 的 <code>sleep()</code>来获得更好的可读性</li></ol><p>ps:<code>sleep()</code>方法写在哪个线程中，那个线程就进入睡眠。</p><p><strong>yield(让出的意思)</strong></p><ol><li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)</li></ol><p>阻塞状态与就绪状态线程区别：</p><ul><li>就绪状态，还是有机会被任务调度器调度的，任务调度器会分时间片给就绪状态的线程。</li><li>阻塞状态，任务调度器不会分时间片给阻塞状态的线程，只有睡眠时间到了，醒过来后，任务调度器才会时间片分给醒来的线程。</li></ul><p> <strong>小结</strong></p><p>yield让出cpu使用权，但是cpu可能会再分配时间片给该线程；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片</p><h3 id="3-5-3-线程优先级"><a href="#3-5-3-线程优先级" class="headerlink" title="3.5.3 线程优先级"></a>3.5.3 线程优先级</h3><ul><li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li><li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><h3 id="3-3-4-join"><a href="#3-3-4-join" class="headerlink" title="3.3.4 join"></a>3.3.4 join</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test10&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        test1();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>            r = <span class="hljs-number">10</span>;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">//t1.join();</span><br>        log.debug(<span class="hljs-string">&quot;结果为:&#123;&#125;&quot;</span>, r);<br>        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">11:58:20 [main] c.Test10 - 开始<br>11:58:20 [t1] c.Test10 - 开始<br>11:58:20 [main] c.Test10 - 结果为:0<br>11:58:20 [main] c.Test10 - 结束<br>11:58:21 [t1] c.Test10 - 结束<br></code></pre></td></tr></table></figure><p>分析</p><ul><li>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 <code>r=10</code></li><li>而主线程一开始就要打印 r 的结果，所以只能打印出 <code>r=0</code></li></ul><p>解决方法</p><ul><li>用 <code>sleep()</code> 行不行？为什么？</li><li>用 <code>join()</code>，加在 <code>t1.start()</code> 之后即可</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211219120326852.png" alt="image-20211219120326852"></p><p>以<code>调用方角度</code>来讲，如果:</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211219120527024.png" alt="image-20211219120527024"></p><blockquote><p><code>t1 thread</code>调用<code>join()</code>方法之后，<code>main thread</code>跟<code>t1 thread</code>是同步的，<code>main thread</code>必须等待<code>t1 thread</code>执行完成后，才能继续执行。</p></blockquote><p><strong>join()方法等待多个线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r1 = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r2 = <span class="hljs-number">0</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       test2();<br>   &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>           sleep(<span class="hljs-number">1</span>);<br>           r1 = <span class="hljs-number">10</span>;<br>       &#125;);<br>       Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>           sleep(<span class="hljs-number">2</span>);<br>           r2 = <span class="hljs-number">20</span>;<br>       &#125;);<br>       t1.start();<br>       t2.start();<br>       <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>       log.debug(<span class="hljs-string">&quot;join begin&quot;</span>);<br>       t2.join();<br>       log.debug(<span class="hljs-string">&quot;t2 join end&quot;</span>);<br>       t1.join();<br>       log.debug(<span class="hljs-string">&quot;t1 join end&quot;</span>);<br>       <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>       log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);<br>   &#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">14:16:35 [main] c.TestJoin - join begin<br>14:16:37 [main] c.TestJoin - t2 join end<br>14:16:37 [main] c.TestJoin - t1 join end<br>14:16:37 [main] c.TestJoin - r1: 10 r2: 20 cost: 2003<br></code></pre></td></tr></table></figure><p>分析如下</p><ul><li>第一个 join：等待 t1 时, t2 并没有停止, 而在运行</li><li>第二个 join：1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s</li></ul><p>如果颠倒两个 join 呢？</p><p>答：结果还是一样</p><p><strong>join(long n):最多等待n毫秒</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r1 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r2 = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    test3();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        sleep(<span class="hljs-number">2</span>);<br>        r1 = <span class="hljs-number">10</span>;<br>    &#125;);<br><br>    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>    t1.start();<br><br>    <span class="hljs-comment">// 线程执行结束会导致 join 结束</span><br>    log.debug(<span class="hljs-string">&quot;join begin&quot;</span>);<br>    t1.join(<span class="hljs-number">1500</span>);<br>    <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>    log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">14:24:33 [main] c.TestJoin - join begin<br>14:24:35 [main] c.TestJoin - r1: 0 r2: 0 cost: 1508<br></code></pre></td></tr></table></figure><blockquote><p>没等够时间，就按时间到期结束；如果等待时间还没万，但线程结束了，就不再等待了。</p></blockquote><h3 id="3-5-5-interrupt-方法详解"><a href="#3-5-5-interrupt-方法详解" class="headerlink" title="3.5.5 interrupt 方法详解"></a>3.5.5 interrupt 方法详解</h3><h4 id="interrupt可以打断-sleep，wait，join-的线程"><a href="#interrupt可以打断-sleep，wait，join-的线程" class="headerlink" title="interrupt可以打断 sleep，wait，join 的线程"></a>interrupt可以打断 sleep，wait，join 的线程</h4><p>阻塞</p><p>打断 sleep 的线程, 会清空打断状态，以 sleep 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>sleep(<span class="hljs-number">1</span>);<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>sleep(<span class="hljs-number">0.5</span>);<br>t1.interrupt();<br>log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">java.lang.InterruptedException: sleep interrupted<br> at java.lang.Thread.sleep(Native Method)<br> at java.lang.Thread.sleep(Thread.java:340)<br> at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)<br> at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)<br> at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)<br> at java.lang.Thread.run(Thread.java:745)<br>21:18:10.374 [main] c.TestInterrupt - 打断状态: false<br></code></pre></td></tr></table></figure><p><strong>打断正常运行的线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>Thread current = Thread.currentThread();<br>Boolean interrupted = current.isInterrupted();<br><span class="hljs-keyword">if</span>(interrupted) &#123;<br>log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br>sleep(<span class="hljs-number">0.5</span>);<br>t2.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">20:57:37.964 [t2] c.TestInterrupt - 打断状态: true<br></code></pre></td></tr></table></figure><p><strong>小结</strong></p><ul><li><p>如果位于特殊的阻塞状态，比如调用wait()、wait(long)或者join()或者sleep()等方法，中断标志位将会被清除，并且收到一个InterruptedException</p></li><li><p>打断正常运行的线程，调用<code>interrupt()</code>方法只是给线程打上一个中断标志位，并不会马上打断该线程。我们可以根据中断标志位来做一些操作。</p></li></ul><h4 id="【模式】模式之两阶段终止"><a href="#【模式】模式之两阶段终止" class="headerlink" title="【模式】模式之两阶段终止"></a>【模式】模式之两阶段终止</h4><p><code>Two Phase Termination</code><br>是在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。</p><p><strong>1.错误思路</strong></p><ul><li>使用线程对象的 stop() 方法停止线程<ul><li>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，<br>其它线程将永远无法获取锁</li></ul></li><li>使用 System.exit(int) 方法停止线程<ul><li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li></ul></li></ul><p><strong>2.两阶段终止模式</strong></p><p><img src="http://image.cryptomartin.top/img/image-20211220155929525.png" alt="image-20211220155929525"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        TwoPhaseTermination tpt = <span class="hljs-keyword">new</span> TwoPhaseTermination();<br>        tpt.start();<br><br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        tpt.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//监控类</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTermination</span> </span>&#123;<br>    <span class="hljs-comment">//创建监控线程，作为成员变量</span><br>    <span class="hljs-keyword">private</span> Thread monitor;<br><br>    <span class="hljs-comment">//开启监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">//不断执行</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-comment">//查看当前线程的中断标记</span><br>                Thread currentThread = Thread.currentThread();<br>                <span class="hljs-comment">//判断当前线程是否被打断</span><br>                <span class="hljs-keyword">if</span> (currentThread.isInterrupted()) &#123;<br>                    <span class="hljs-comment">//如果被打断</span><br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//如果当前线程没有被打断,睡眠1秒</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    <span class="hljs-comment">//没被打断，且没有异常；记录日志</span><br>                    log.debug(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                    <span class="hljs-comment">//在睡眠中被打断，会清除打断标记，打断标记此时为false;需要将中断标记置为真;重新设置打断标记为true</span><br>                    currentThread.interrupt();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//开启线程</span><br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">//停止监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:25:32 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>16:25:33 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>16:25:34 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>java.lang.InterruptedException: sleep interrupted<br><span class="hljs-code">at java.lang.Thread.sleep(Native Method)</span><br><span class="hljs-code">at com.sunk.test.TwoPhaseTermination.lambda$start$0(Test3.java:41)</span><br><span class="hljs-code">at java.lang.Thread.run(Thread.java:748)</span><br><span class="hljs-code">16:25:35 [Thread-0] c.TwoPhaseTermination - 料理后事</span><br></code></pre></td></tr></table></figure><p><strong>isInterrupted()与interrupted()区别</strong></p><ul><li><code>isInterrupted()</code>：判断当前线程是否被打断；不会清除打断标记</li><li><code>interrupted()</code>:判断当前线程是否被打断；会清除打断标记，如果打断标记为<code>true</code>，调用此方法后，变为<code>false</code></li></ul><h4 id="interrupted打断park线程"><a href="#interrupted打断park线程" class="headerlink" title="interrupted打断park线程"></a>interrupted打断park线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test14&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test14</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        test3();<br>    &#125;<br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>            log.debug(<span class="hljs-string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());<br>            <span class="hljs-comment">//打断标记为true，park就失效了。</span><br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        sleep(<span class="hljs-number">0.5</span>);<br>        t1.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:38:28 [t1] c.Test14 - park...<br>16:38:28 [t1] c.Test14 - unpark...<br>16:38:28 [t1] c.Test14 - 打断状态：true<br>16:38:28 [t1] c.Test14 - unpark...<br></code></pre></td></tr></table></figure><blockquote><p>如果打断标记已经是 true, 则 park 会失效</p></blockquote><h2 id="3-6-不推荐的方法"><a href="#3-6-不推荐的方法" class="headerlink" title="3.6 不推荐的方法"></a>3.6 不推荐的方法</h2><p><img src="http://image.cryptomartin.top/img/image-20211220164128203.png" alt="image-20211220164128203"></p><h2 id="3-7-守护线程"><a href="#3-7-守护线程" class="headerlink" title="3.7 守护线程"></a>3.7 守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做<code>守护线程</code>，<strong>只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test15&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test15</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;t1线程结束&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-comment">//设置t1线程为守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束</span><br>        t1.setDaemon(<span class="hljs-keyword">true</span>);<br>        t1.start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;主线程结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">19:06:21 [main] c.Test15 - 主线程结束<br></code></pre></td></tr></table></figure><blockquote><p>注意:</p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等<br>待它们处理完当前请求</li></ul></blockquote><h2 id="3-8-线程的五种状态"><a href="#3-8-线程的五种状态" class="headerlink" title="3.8 线程的五种状态"></a>3.8 线程的五种状态</h2><p>五种状态的划分主要是从操作系统的层面进行划分的</p><p><img src="http://image.cryptomartin.top/img/20200307093417-638644.png" alt="1583507073055"></p><ol><li><p>初始状态，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联</p></li><li><p>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</p></li><li><p>运行状态，指线程获取了CPU时间片，正在运行</p><ul><li>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</li></ul></li><li><p>阻塞状态</p><ul><li><p>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】</p></li><li><p>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p></li><li><p>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</p></li></ul></li><li><p>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ol><h2 id="3-9-线程的六种状态"><a href="#3-9-线程的六种状态" class="headerlink" title="3.9 线程的六种状态"></a>3.9 线程的六种状态</h2><p>这是从 Java API 层面来描述的，我们主要研究的就是这种。状态转换详情图：<a href="https://www.jianshu.com/p/ec94ed32895f">地址</a><br>根据 Thread.State 枚举，分为六种状态 </p><p><img src="http://image.cryptomartin.top/img/20200307093352-614933.png" alt="1583507709834"></p><ul><li>NEW 跟五种状态里的初始状态是一个意思</li><li> RUNNABLE 是当调用了 <code>start()</code> 方法之后的状态，注意，Java API 层面的 <code>RUNNABLE</code> 状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【io阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li><li><code>BLOCKED</code> ， <code>WAITING</code> ， <code>TIMED_WAITING</code> 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节<br> 详述</li></ul><h2 id="3-10-习题-统筹规划"><a href="#3-10-习题-统筹规划" class="headerlink" title="3.10 习题-统筹规划"></a>3.10 习题-统筹规划</h2><p><img src="http://image.cryptomartin.top/img/image-20211220194112708.png" alt="image-20211220194112708"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test16&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test16</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;洗水壶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            log.debug(<span class="hljs-string">&quot;烧开水，花费15分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">15</span>);<br>        &#125;, <span class="hljs-string">&quot;老王&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;洗茶壶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            log.debug(<span class="hljs-string">&quot;洗茶杯，花费2分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>            log.debug(<span class="hljs-string">&quot;拿茶叶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//小王模拟泡茶，等待开水烧开。</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                t1.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;可以泡茶了！&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;小王&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">19:38:37 [老王] c.Test16 - 洗水壶，花费1分钟<br>19:38:37 [小王] c.Test16 - 洗茶壶，花费1分钟<br>19:38:38 [老王] c.Test16 - 烧开水，花费15分钟<br>19:38:38 [小王] c.Test16 - 洗茶杯，花费2分钟<br>19:38:40 [小王] c.Test16 - 拿茶叶，花费1分钟<br>19:38:53 [小王] c.Test16 - 可以泡茶了！<br></code></pre></td></tr></table></figure><p>ps:秒代替分钟。</p><p>执行到<code>19:38:38 [老王] c.Test16 - 烧开水，花费15分钟</code>，会等待15秒，然后会执行<code>19:38:53 [小王] c.Test16 - 可以泡茶了！</code></p><h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><p>本章的重点在于掌握</p><ul><li><p>线程创建</p></li><li><p>线程重要 api，如 start，run，sleep，join，interrupt 等</p></li><li><p>线程状态</p></li><li><p>应用方面</p><ul><li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li><li>提高效率：并行计算，缩短运算时间</li><li>同步等待：join</li><li>统筹规划：合理使用线程，得到最优效果</li></ul></li><li><p>原理方面</p><ul><li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li><li>Thread 两种创建方式 的源码</li></ul></li><li><p>模式方面</p><ul><li>两阶段终止模式</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 七牛云外链图片无法显示</title>
    <link href="/2021/12/16/Hexo%20%E5%A4%96%E9%93%BE%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/"/>
    <url>/2021/12/16/Hexo%20%E5%A4%96%E9%93%BE%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-七牛云外链图片无法显示"><a href="#Hexo-七牛云外链图片无法显示" class="headerlink" title="Hexo 七牛云外链图片无法显示"></a>Hexo 七牛云外链图片无法显示</h1><h2 id="1-起因"><a href="#1-起因" class="headerlink" title="1. 起因"></a>1. 起因</h2><p>打算好好做Hexo博客，结果太折腾了。七牛云的图床，在Hexo博客结果不能显示，网上的方法用了很多都失败了，自己查了一下错误。</p><p>大概原因是：<code>github请求的协议是用HTTPS，而七牛云是HTTP，协议不兼容导致</code></p><p><img src="http://image.cryptomartin.top/img/image-20211216185546365.png" alt="image-20211216185546365"></p><h2 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h2><p><code>在七牛云打开强制HTTPS</code></p><p><img src="http://image.cryptomartin.top/img/image-20211216190015768.png" alt="image-20211216190015768"></p><p><img src="http://image.cryptomartin.top/img/image-20211216190203695.png" alt="image-20211216190203695"></p><h2 id="3-结果"><a href="#3-结果" class="headerlink" title="3. 结果"></a>3. 结果</h2><p>等待5分钟左右，就有七牛云发邮件，提示成功开启<code>强制HTTPS</code></p><p><img src="http://image.cryptomartin.top/img/image-20211216190318735.png" alt="image-20211216190318735"></p><p>Hexo成功显示七牛云外链图片：</p><p><img src="http://image.cryptomartin.top/img/image-20211216190503464.png" alt="image-20211216190503464"></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 进程与线程</title>
    <link href="/2021/12/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/12/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 进程与线程</h1><p><strong>本章内容</strong></p><ul><li>进程和线程的概念</li><li>并行和并发的概念</li><li>线程基本应用</li></ul><h2 id="2-1-进程与线程概念"><a href="#2-1-进程与线程概念" class="headerlink" title="2.1 进程与线程概念"></a>2.1 进程与线程概念</h2><h3 id="2-1-1-进程"><a href="#2-1-1-进程" class="headerlink" title="2.1.1 进程"></a>2.1.1 进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在<br>指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器<br>等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><p>简单说就是：</p><blockquote><p>进程：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程.</p></blockquote><h3 id="2-1-2-线程"><a href="#2-1-2-线程" class="headerlink" title="2.1.2 线程"></a>2.1.2 线程</h3><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作<br>为线程的容器</li></ul><blockquote><p>线程是进程当中的一条执行流程.</p></blockquote><blockquote><p>线程 = 进程 - 共享资源</p></blockquote><h3 id="2-1-3-进程与线程对比"><a href="#2-1-3-进程与线程对比" class="headerlink" title="2.1.3 进程与线程对比"></a>2.1.3 进程与线程对比</h3><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li><li>进程间通信较为复杂<ul><li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h2 id="2-2-并发与并行的概念"><a href="#2-2-并发与并行的概念" class="headerlink" title="2.2 并发与并行的概念"></a>2.2 并发与并行的概念</h2><p>单核 cpu 下，线程实际还是 <code>串行执行</code> 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows<br>下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感<br>觉是 同时运行的 。总结为一句话就是： <code>微观串行，宏观并行</code> ，<br>一般会将这种 线程轮流使用 CPU 的做法称为并发， concurrent</p><p><img src="http://image.cryptomartin.top/img/image-20211216152119986.png" alt="image-20211216152119986"></p><p>多核 cpu下，每个 核（core） 都可以调度运行线程，这时候线程可以是并行的。</p><p><img src="http://image.cryptomartin.top/img/image-20211216152309525.png" alt="image-20211216152309525"></p><blockquote><p>并发：一段时间内运行多个进程</p><p>并行：一个时间点运行多个进程，一般要求有多个CPU</p></blockquote><h2 id="2-3-应用"><a href="#2-3-应用" class="headerlink" title="2.3 应用"></a>2.3 应用</h2><h3 id="2-3-1-应用之异步调用（案例1）"><a href="#2-3-1-应用之异步调用（案例1）" class="headerlink" title="2.3.1 应用之异步调用（案例1）"></a>2.3.1 应用之异步调用（案例1）</h3><p>以调用方角度来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><h4 id="1-设计"><a href="#1-设计" class="headerlink" title="1) 设计"></a>1) 设计</h4><p>多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，这么cpu只能等5秒，啥都不能做。</p><h4 id="2-结论"><a href="#2-结论" class="headerlink" title="2) 结论"></a>2) 结论</h4><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li><li>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><h3 id="2-3-2-应用之提高效率（案例1）"><a href="#2-3-2-应用之提高效率（案例1）" class="headerlink" title="2.3.2 应用之提高效率（案例1）"></a>2.3.2 应用之提高效率（案例1）</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">计算 <span class="hljs-number">1</span> 花费 <span class="hljs-number">10</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">计算 2</span> 花费 <span class="hljs-number">11</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">计算 3</span> 花费 <span class="hljs-number">9</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">汇总需要 1</span> ms<br></code></pre></td></tr></table></figure><ul><li>如果是串行执行，那么总共花费的时间是 <code>10 + 11 + 9 + 1 = 31ms</code></li><li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个<br>线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 <code>11ms</code> 最后加上汇总时间只会花费 <code>12ms</code></li></ul><p><strong>注意</strong></p><blockquote><p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 并发编程概览</title>
    <link href="/2021/12/16/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E8%A7%88/"/>
    <url>/2021/12/16/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-并发编程概览"><a href="#第一章-并发编程概览" class="headerlink" title="第一章 并发编程概览"></a>第一章 并发编程概览</h1><h2 id="1-1-这门课主要学什么"><a href="#1-1-这门课主要学什么" class="headerlink" title="1.1 这门课主要学什么"></a>1.1 这门课主要学什么</h2><p>这门课中的【并发】一词涵盖了在 Java 平台上的</p><ul><li>进程</li><li>线程</li><li>并发</li><li>并行</li></ul><p>以及 Java 并发工具、并发问题以及解决方案，同时我也会讲解一些其它领域的并发</p><h2 id="1-2-为什么要学并发编程"><a href="#1-2-为什么要学并发编程" class="headerlink" title="1.2 为什么要学并发编程"></a>1.2 为什么要学并发编程</h2><ul><li><p>我工作中用不到并发啊？</p><p>  做CRUD，用不到并发编程；但希望往更高层面发展，必须学并发编程！平时用的Tomcat服务器、Dubbo、消息中间件等，这些底层肯定涉及多线程！</p></li></ul><h2 id="1-3-学习路线"><a href="#1-3-学习路线" class="headerlink" title="1.3 学习路线"></a>1.3 学习路线</h2><p>本门课程以并发、并行为主线，穿插讲解</p><p><strong>应用</strong> - 结合实际<br><strong>原理</strong> - 了然于胸<br><strong>模式</strong> - 正确姿势</p><ul><li><input disabled="" type="checkbox"> 思维导图</li></ul><h2 id="1-4-预备知识"><a href="#1-4-预备知识" class="headerlink" title="1.4 预备知识"></a>1.4 预备知识</h2><ul><li>有一定的框架经验</li><li>线程安全问题，需要你接触过 Java Web 开发、Jdbc 开发、Web 服务器、分布式框架时才会遇到</li><li>基于 JDK 8，最好对函数式编程、lambda 有一定了解</li><li>采用了 slf4j 打印日志，这是好的实践</li><li>采用了 lombok 简化 java bean 编写</li><li>给每个线程好名字，这也是一项好的实践</li></ul><p>pom.xml 依赖如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>logback.xml配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://ch.qos.logback/xml/ns/logback&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://ch.qos.logback/xml/ns/logback logback.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%date&#123;HH:mm:ss&#125; [%t] %logger - %m%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;c&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
