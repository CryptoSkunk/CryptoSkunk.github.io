<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第一章 JVM的内存结构</title>
    <link href="/2021/12/24/%E7%AC%AC%E4%B8%80%E7%AB%A0-JVM%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/2021/12/24/%E7%AC%AC%E4%B8%80%E7%AB%A0-JVM%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-JVM的内存结构"><a href="#第一章-JVM的内存结构" class="headerlink" title="第一章 JVM的内存结构"></a>第一章 JVM的内存结构</h1><p><strong>本章内容</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li></ul><h2 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h2><p>所处位置</p><p><img src="http://image.cryptomartin.top/img/image-20211222083645693.png" alt="image-20211222083645693"></p><h3 id="1-1-1-定义"><a href="#1-1-1-定义" class="headerlink" title="1.1.1 定义"></a>1.1.1 定义</h3><p>Program Counter Register 程序计数器（寄存器）</p><ul><li><p>作用：记住下一条JVM指令的执行地址。</p></li><li><p>特点</p><ul><li>是线程私有的（每个线程都有自己的程序计数器）</li><li>不会存在内存溢出</li></ul></li></ul><p>物理上，是通过寄存器实现的。</p><h3 id="1-1-2-作用"><a href="#1-1-2-作用" class="headerlink" title="1.1.2 作用"></a>1.1.2 作用</h3><p><img src="http://image.cryptomartin.top/img/image-20211222084432356.png" alt="image-20211222084432356"></p><blockquote><p>1.java源代码不能直接被执行，得经过编译。编译成左侧的二进制的字节码，叫作JVM指令。</p><p>2.JVM指令直接交给CPU，还不能执行；必须经过解释器，解释成机器码，然后再交给CPU执行。</p></blockquote><p>作用：记住下一条JVM指令的执行地址。</p><ul><li><p>图中的数字，可以理解为JVM指令对应的内存地址，当这些JVM指令被加载到虚拟机内存后，会有一个地址信息，JVM根据地址信息可以找到JVM指令，来执行它。</p></li><li><p>当这些指令被加载JVM内存以后，JVM会有这些地址信息。根据地址信息找到第一条，当第一条<code>0: getstatic #20</code>执行，与此同时，会把下一条执行的地址<code>3</code>放入程序计数器；等第一条执行完以后，<code>解释器</code>会到<code>程序计数器</code>中找到下一条执行的指令地址<code>3</code>，在<code>3</code>指令执行的同时，会把<code>4</code>地址放入程序计数器。重复！</p></li></ul><h2 id="1-2-虚拟机栈"><a href="#1-2-虚拟机栈" class="headerlink" title="1.2 虚拟机栈"></a>1.2 虚拟机栈</h2><p><img src="http://image.cryptomartin.top/img/image-20211222204215587.png" alt="image-20211222204215587"></p><p>虚拟机栈，就是线程运行需要的内存空间。</p><p>栈帧，就是每个方法运行需要的内存空间。一个栈帧就对应一次方法的调用。</p><p>一个栈由多个栈帧组成。</p><h3 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1 定义"></a>1.2.1 定义</h3><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><ul><li>每个线程运行时所需要的内存，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p>问题辨析：</p><ol><li><p>垃圾回收是否涉及栈内存？不涉及，栈帧内存每次方法结束后，都会被弹出栈，会被自动回收，不需要垃圾回收管理。</p></li><li><p>栈内存分配越大越好吗？不是。栈越大，线程数会少。一般采用系统默认的栈内存1024kb就好了。</p></li><li><p>方法内的局部变量是否线程安全？</p><ul><li><p>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的</p></li><li><p>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</p></li></ul></li></ol><p><img src="http://image.cryptomartin.top/img/image-20211222225101335.png" alt="image-20211222225101335"></p><h3 id="1-2-2-栈溢出"><a href="#1-2-2-栈溢出" class="headerlink" title="1.2.2 栈溢出"></a>1.2.2 栈溢出</h3><p>什么情况下会导致栈溢出？</p><ul><li>栈帧过多导致栈内存溢出 （递归/对象相互引用…）</li><li>栈帧过大导致栈内存溢出</li></ul><h3 id="1-2-3-线程运行诊断"><a href="#1-2-3-线程运行诊断" class="headerlink" title="1.2.3 线程运行诊断"></a>1.2.3 线程运行诊断</h3><p>案例1： cpu 占用过多</p><p>定位</p><ul><li>用top定位哪个进程对cpu的占用过高，但定位不到是哪个线程导致问题</li><li>ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高）</li><li>jstack 进程id<ul><li>可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号（线程id 转为十六进制查看）</li></ul></li></ul><p>案例2：程序运行很长时间没有结果</p><p>可能发生死锁。可以使用案例1方法查看。</p><h2 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h2><p><img src="http://image.cryptomartin.top/img/image-20211222233156739.png" alt="image-20211222233156739"></p><p>本地方法：不是由java编写的代码。有时候需要通过调用操作系统，这时候需要c或者c++编写的本地方法来与操作系统底层API交流。</p><p>本地方法栈：给本地方法的调用提供内存空间</p><p>例如：<code>object</code>类里的<code>clone()</code>方法</p><p><img src="http://image.cryptomartin.top/img/image-20211222234406180.png" alt="image-20211222234406180"></p><h2 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4 堆"></a>1.4 堆</h2><p><img src="http://image.cryptomartin.top/img/image-20211222234505594.png" alt="image-20211222234505594"></p><p>堆和方法区是线程共享的区域；其他内存结构是线程私有的。</p><h3 id="1-4-1-定义"><a href="#1-4-1-定义" class="headerlink" title="1.4.1 定义"></a>1.4.1 定义</h3><p>Heap 堆</p><ul><li>通过 new 关键字，创建对象都会使用堆内存</li></ul><p>特点</p><ul><li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul><h3 id="1-4-2-堆内存溢出"><a href="#1-4-2-堆内存溢出" class="headerlink" title="1.4.2 堆内存溢出"></a>1.4.2 堆内存溢出</h3><p><code>java.lang.OutOfMemoryError: Java heap space</code></p><p><code>-Xmx8m</code>:设置堆内存大小</p><h3 id="1-4-3-堆内存诊断"><a href="#1-4-3-堆内存诊断" class="headerlink" title="1.4.3 堆内存诊断"></a>1.4.3 堆内存诊断</h3><ol><li><p>jps 工具<br>查看当前系统中有哪些 java 进程</p></li><li><p>jmap 工具<br>查看堆内存占用情况 jmap - heap 进程id</p></li><li><p>jconsole 工具<br>图形界面的，多功能的监测工具，可以连续监测</p></li></ol><h3 id="1-4-4-案例"><a href="#1-4-4-案例" class="headerlink" title="1.4.4 案例"></a>1.4.4 案例</h3><ul><li>垃圾回收后，内存占用仍然很高</li></ul><p><code>jvisualvm</code>:可以查看堆Dump,分析查找问题</p><h2 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h2><p><img src="http://image.cryptomartin.top/img/image-20211223152803582.png" alt="image-20211223152803582"> </p><h3 id="1-5-1-定义"><a href="#1-5-1-定义" class="headerlink" title="1.5.1 定义"></a>1.5.1 定义</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the &quot;text&quot; segment in an operating system process. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods (§2.9) used in class and instance initialization and interface initialization.<br><br>The method area is created on virtual machine start-up. Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it. This specification does not mandate the location of the method area or the policies used to manage compiled code. The method area may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger method area becomes unnecessary. The memory for the method area does not need to be contiguous.<br><br>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the method area, as well as, in the case of a varying-size method area, control over the maximum and minimum method area size.<br><br>The following exceptional condition is associated with the method area:<br><span class="hljs-bullet">-</span> If memory in the method area cannot be made available to satisfy an allocation request, the Java Virtual Machine throws an OutOfMemoryError.<br></code></pre></td></tr></table></figure><h3 id="1-5-2-组成"><a href="#1-5-2-组成" class="headerlink" title="1.5.2 组成"></a>1.5.2 组成</h3><p><img src="http://image.cryptomartin.top/img/image-20211223153516263.png" alt="image-20211223153516263"></p><p><strong>JVM内存结构1.6</strong></p><ul><li><p>有堆，Method area。</p></li><li><p><code>Method area</code> 是概念上的东西，1.6版本用<code>永久代</code>的方法作为实现。</p></li><li><p><code>永久代</code>包含:存储类的信息(field，method,构造器等等)，类加载器；还有一块运行时常量池，运行池常量池里有个重要的东西<code>StringTable</code>字符串表。</p></li></ul><p><img src="http://image.cryptomartin.top/img/image-20211223154117117.png" alt="image-20211223154117117"></p><p><strong>JVM内存结构1.8</strong></p><ul><li><code>Method area</code>还是概念上的东西</li><li>方法区的实现叫作<code>Metaspace</code>元空间，<code>Metaspace</code>里存储类，类加载器，常量池的信息。</li><li>方法区不占用堆内存了，不是由JVM来管理方法区的内存结构了；方法区被转移到<code>本地内存</code>当中！<code>本地内存</code>-&gt;<code>操作系统内存</code></li><li><code>StringTable</code>字符串表在堆里面</li></ul><h3 id="1-5-3-方法区内存溢出"><a href="#1-5-3-方法区内存溢出" class="headerlink" title="1.5.3 方法区内存溢出"></a>1.5.3 方法区内存溢出</h3><ul><li><p>1.8 以前会导致永久代内存溢出</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 演示永久代内存溢出 java.lang.OutOfMemoryError: PermGen space <br><span class="hljs-bullet">*</span> -XX:MaxPermSize=8m<br></code></pre></td></tr></table></figure></li><li><p>1.8 之后会导致元空间内存溢出</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace <br><span class="hljs-bullet">*</span> -XX:MaxMetaspaceSize=8m<br></code></pre></td></tr></table></figure></li></ul><p><strong>场景</strong></p><ul><li>Spring</li><li>mybatis</li></ul><p>字节码的动态生成。 </p><h3 id="1-5-4-运行时常量池"><a href="#1-5-4-运行时常量池" class="headerlink" title="1.5.4 运行时常量池"></a>1.5.4 运行时常量池</h3><p><code>javap -v HelloWorld.class</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//类的基本信息<br>Classfile /E:/JavaProject/cocurrent/Java<span class="hljs-emphasis">_concurrent/src/main/java/com/sunk/jvm/t1/t5/HelloWorld.class</span><br><span class="hljs-emphasis">  Last modified 2021-12-23; size 444 bytes</span><br><span class="hljs-emphasis">  MD5 checksum b00ce07193edf9b24a43ce9f1cc4d75a</span><br><span class="hljs-emphasis">  Compiled from &quot;HelloWorld.java&quot;</span><br><span class="hljs-emphasis">public class com.sunk.jvm.t1.t5.HelloWorld</span><br><span class="hljs-emphasis">  minor version: 0</span><br><span class="hljs-emphasis">  major version: 52</span><br><span class="hljs-emphasis">  flags: ACC_</span>PUBLIC, ACC<span class="hljs-emphasis">_SUPER</span><br><span class="hljs-emphasis">//常量池</span><br><span class="hljs-emphasis">Constant pool:</span><br><span class="hljs-emphasis">   #1 = Methodref          #6.#15         // java/lang/Object.&quot;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">init</span>&gt;</span></span>&quot;:()V</span><br><span class="hljs-emphasis">   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="hljs-emphasis">   #3 = String             #18            // hello world</span><br><span class="hljs-emphasis">   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="hljs-emphasis">   #5 = Class              #21            // com/sunk/jvm/t1/t5/HelloWorld</span><br><span class="hljs-emphasis">   #6 = Class              #22            // java/lang/Object</span><br><span class="hljs-emphasis">   #7 = Utf8               <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">init</span>&gt;</span></span></span><br><span class="hljs-emphasis">   #8 = Utf8               ()V</span><br><span class="hljs-emphasis">   #9 = Utf8               Code</span><br><span class="hljs-emphasis">  #10 = Utf8               LineNumberTable</span><br><span class="hljs-emphasis">  #11 = Utf8               main</span><br><span class="hljs-emphasis">  #12 = Utf8               ([Ljava/lang/String;)V</span><br><span class="hljs-emphasis">  #13 = Utf8               SourceFile</span><br><span class="hljs-emphasis">  #14 = Utf8               HelloWorld.java</span><br><span class="hljs-emphasis">  #15 = NameAndType        #7:#8          // &quot;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">init</span>&gt;</span></span>&quot;:()V</span><br><span class="hljs-emphasis">  #16 = Class              #23            // java/lang/System</span><br><span class="hljs-emphasis">  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;</span><br><span class="hljs-emphasis">  #18 = Utf8               hello world</span><br><span class="hljs-emphasis">  #19 = Class              #26            // java/io/PrintStream</span><br><span class="hljs-emphasis">  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V</span><br><span class="hljs-emphasis">  #21 = Utf8               com/sunk/jvm/t1/t5/HelloWorld</span><br><span class="hljs-emphasis">  #22 = Utf8               java/lang/Object</span><br><span class="hljs-emphasis">  #23 = Utf8               java/lang/System</span><br><span class="hljs-emphasis">  #24 = Utf8               out</span><br><span class="hljs-emphasis">  #25 = Utf8               Ljava/io/PrintStream;</span><br><span class="hljs-emphasis">  #26 = Utf8               java/io/PrintStream</span><br><span class="hljs-emphasis">  #27 = Utf8               println</span><br><span class="hljs-emphasis">  #28 = Utf8               (Ljava/lang/String;)V</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">//类的方法定义</span><br><span class="hljs-emphasis">&#123;</span><br><span class="hljs-emphasis">  public com.sunk.jvm.t1.t5.HelloWorld(); //构造方法</span><br><span class="hljs-emphasis">    descriptor: ()V</span><br><span class="hljs-emphasis">    flags: ACC_</span>PUBLIC<br><span class="hljs-code">    Code:</span><br><span class="hljs-code">      stack=1, locals=1, args_size=1</span><br><span class="hljs-code">         0: aload_0</span><br><span class="hljs-code">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-code">         4: return</span><br><span class="hljs-code">      LineNumberTable:</span><br><span class="hljs-code">        line 8: 0</span><br><span class="hljs-code"></span><br>  public static void main(java.lang.String[]); //main方法<br><span class="hljs-code">    descriptor: ([Ljava/lang/String;)V</span><br><span class="hljs-code">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="hljs-code">    Code:</span><br><span class="hljs-code">      stack=2, locals=1, args_size=1</span><br><span class="hljs-code">        //从这开始；虚拟机指令</span><br><span class="hljs-code">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;  //#2要去查常量池的表</span><br><span class="hljs-code">         3: ldc           #3                  // String hello world</span><br><span class="hljs-code">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="hljs-code">         8: return</span><br><span class="hljs-code">      LineNumberTable:</span><br><span class="hljs-code">        line 10: 0</span><br><span class="hljs-code">        line 11: 8</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code">SourceFile: &quot;HelloWorld.java&quot;</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><ul><li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li><li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为内存中的真实地址。程序运行时，常量池会放入本地内存中，变成运行时常量池。<code>#1</code>,<code>#2</code>也会变成内存中的地址。</li></ul><h3 id="1-5-5-StringTable"><a href="#1-5-5-StringTable" class="headerlink" title="1.5.5 StringTable"></a>1.5.5 StringTable</h3><ul><li><p>常量池中的字符串仅是符号，第一次用到时才变为对象</p></li><li><p>利用串池的机制，来避免重复创建字符串对象</p></li><li><p>字符串变量拼接的原理是 StringBuilder （1.8）</p></li><li><p>字符串常量拼接的原理是编译期优化</p></li><li><p>可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池</p><ul><li><p>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池;无论有没有，都 会把串池中的对象返回</p></li><li><p>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池； 会把串池中的对象返回</p></li></ul></li></ul><p>先看几道面试题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>String s3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>String s4 = s1 + s2;<br>String s5 = <span class="hljs-string">&quot;ab&quot;</span>;<br>String s6 = s4.intern();<br><br><span class="hljs-comment">// 问</span><br>System.out.println(s3 == s4);<br>System.out.println(s3 == s5);<br>System.out.println(s3 == s6);<br><br>String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>);<br>String x1 = <span class="hljs-string">&quot;cd&quot;</span>;<br>x2.intern();<br><br><span class="hljs-comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢 </span><br>System.out.println(x1 == x2);<br></code></pre></td></tr></table></figure><h4 id="1-5-5-1-常量池与串池的关系"><a href="#1-5-5-1-常量池与串池的关系" class="headerlink" title="1.5.5.1 常量池与串池的关系"></a>1.5.5.1 常量池与串池的关系</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_22</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>        String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译<code>javap -v Demo1_22.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java">Classfile /E:/JavaProject/cocurrent/Java_concurrent/src/main/java/com/sunk/jvm/t1/Demo1_22.class<br>  Last modified <span class="hljs-number">2021</span>-<span class="hljs-number">12</span>-<span class="hljs-number">24</span>; size <span class="hljs-number">320</span> bytes<br>  MD5 checksum 4cc52650a9c6199ee5039970ac0450c0<br>  Compiled from <span class="hljs-string">&quot;Demo1_22.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">sunk</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">t1</span>.<span class="hljs-title">Demo1_22</span></span><br><span class="hljs-class">  <span class="hljs-title">minor</span> <span class="hljs-title">version</span>: 0</span><br><span class="hljs-class">  <span class="hljs-title">major</span> <span class="hljs-title">version</span>: 52</span><br><span class="hljs-class">  <span class="hljs-title">flags</span>: <span class="hljs-title">ACC_PUBLIC</span>, <span class="hljs-title">ACC_SUPER</span></span><br><span class="hljs-class"><span class="hljs-title">Constant</span> <span class="hljs-title">pool</span>:</span><br><span class="hljs-class">   #1 </span>= Methodref          #<span class="hljs-number">6.</span>#<span class="hljs-number">15</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = String             #<span class="hljs-number">16</span>            <span class="hljs-comment">// a</span><br>   #<span class="hljs-number">3</span> = String             #<span class="hljs-number">17</span>            <span class="hljs-comment">// b</span><br>   #<span class="hljs-number">4</span> = String             #<span class="hljs-number">18</span>            <span class="hljs-comment">// ab</span><br>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">19</span>            <span class="hljs-comment">// com/sunk/jvm/t1/Demo1_22</span><br>   #<span class="hljs-number">6</span> = Class              #<span class="hljs-number">20</span>            <span class="hljs-comment">// java/lang/Object</span><br>   #<span class="hljs-number">7</span> = Utf8               &lt;init&gt;<br>   #<span class="hljs-number">8</span> = Utf8               ()V<br>   #<span class="hljs-number">9</span> = Utf8               Code<br>  #<span class="hljs-number">10</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">11</span> = Utf8               main<br>  #<span class="hljs-number">12</span> = Utf8               ([Ljava/lang/String;)V<br>  #<span class="hljs-number">13</span> = Utf8               SourceFile<br>  #<span class="hljs-number">14</span> = Utf8               Demo1_22.java<br>  #<span class="hljs-number">15</span> = NameAndType        #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">16</span> = Utf8               a<br>  #<span class="hljs-number">17</span> = Utf8               b<br>  #<span class="hljs-number">18</span> = Utf8               ab<br>  #<span class="hljs-number">19</span> = Utf8               com/sunk/jvm/t1/Demo1_22<br>  #<span class="hljs-number">20</span> = Utf8               java/lang/Object<br>&#123;<br>  <span class="hljs-keyword">public</span> com.sunk.jvm.t1.Demo1_22();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br>         <span class="hljs-number">2</span>: astore_1<br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br>         <span class="hljs-number">5</span>: astore_2<br>         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>         <span class="hljs-number">8</span>: astore_3<br>         <span class="hljs-number">9</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">10</span>: <span class="hljs-number">3</span><br>        line <span class="hljs-number">11</span>: <span class="hljs-number">6</span><br>        line <span class="hljs-number">12</span>: <span class="hljs-number">9</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">10</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>            <span class="hljs-number">3</span>       <span class="hljs-number">7</span>     <span class="hljs-number">1</span>    s1   Ljava/lang/String;<br>            <span class="hljs-number">6</span>       <span class="hljs-number">4</span>     <span class="hljs-number">2</span>    s2   Ljava/lang/String;<br>            <span class="hljs-number">9</span>       <span class="hljs-number">1</span>     <span class="hljs-number">3</span>    s3   Ljava/lang/String;<br><br>&#125;<br>SourceFile: <span class="hljs-string">&quot;Demo1_22.java&quot;</span><br><br></code></pre></td></tr></table></figure><ul><li> 常量池中的信息，都会被加载到运行时常量池中，这时 a b ab 都是常量池中的符号，还没有变为 java字符串对象</li><li> <code>ldc</code> #2 会把 a符号变为 “a”字符串对象</li><li> 变为 “a”字符串对象后，会到 <code>StringTable</code>中去找有没有取值相同的key（”a”）；如果没有则放入串池。</li><li> 执行完<code>String s1 = &quot;a&quot;;</code>，串池就有 “a”字符串对象  </li><li> 用到才会创建，用不到不会提前创建</li><li> StringTable[“a”,”b”,”ab”] hashtable 结构，不能扩容</li><li> 每个字符串对象，在串池中都是唯一的。</li></ul><h4 id="1-5-5-2-字符串变量拼接"><a href="#1-5-5-2-字符串变量拼接" class="headerlink" title="1.5.5.2 字符串变量拼接"></a>1.5.5.2 字符串变量拼接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_22</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>        String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>        String s4 = s1 + s2;<span class="hljs-comment">//new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString() </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>String s4 = s1 + s2;//new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString() new String(&quot;ab&quot;) </code></p><p>图解：</p><p><img src="http://image.cryptomartin.top/img/image-20211224112919717.png" alt="image-20211224112919717"></p><p><code>StringBuilder</code>的<code>toString</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Create a copy, don&#x27;t share the array</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(value, <span class="hljs-number">0</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据拼接好的值，又创建了新的字符串对象！相当于创建”ab”的字符串对象，存入s4</li></ul><p><strong>问：s3==s4？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>    String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>    String s4 = s1 + s2;<br><br>    System.out.println(s3 == s4 );<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>答案为false。虽然s3的“ab”和s4的“ab”值一样，但s3的”ab”是在串池中的，s4的new String(“ab”)是在堆里面的。</li></ul><h4 id="1-5-5-3-编译期优化"><a href="#1-5-5-3-编译期优化" class="headerlink" title="1.5.5.3 编译期优化"></a>1.5.5.3 编译期优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>    String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>    String s4 = s1 + s2;<br>    String s5 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后：</p><p><img src="http://image.cryptomartin.top/img/image-20211224162436968.png" alt="image-20211224162436968"></p><p>直接找拼接好的 “ab”。串池中已经有了“ab”字符串对象，不会再创建新的“ab”字符串对象了</p><p>问：s3==s5？true</p><p><img src="http://image.cryptomartin.top/img/image-20211224162735236.png" alt="image-20211224162735236"></p><p><strong>原理</strong></p><p><code>String s5 = &quot;a&quot; + &quot;b&quot;;</code>javac在编译期间的优化，结果在编译期间确定为<code>&quot;ab&quot;</code>，已经确定的结果。</p><p><code>String s4 = s1 + s2;</code>,<code>s1</code>,<code>s2</code>是变量，在运行时，引用的值可能被修改，结果是不能确定的；所以在运行期间，用<code>StringBuilder</code>来动态拼接。</p><h4 id="1-5-5-4-intern-放入串池"><a href="#1-5-5-4-intern-放入串池" class="headerlink" title="1.5.5.4 intern,放入串池"></a>1.5.5.4 intern,放入串池</h4><blockquote><p><code>intern()</code>将这个字符串对象尝试放入串池，如果有，则不会放入串池，如果没有则放入串池；无论有没有，都会把串池中的对象返回。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo23</span> </span>&#123;<br>    <span class="hljs-comment">//StringTable:[&quot;a&quot;,&quot;b&quot;]，无&quot;ab&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">// StringBuilder 动态拼接 new String(&quot;ab&quot;)</span><br><br>        <span class="hljs-comment">//堆有 new String(&quot;a&quot;)对象  new String(&quot;b&quot;)对象  new String(&quot;ab&quot;)对象</span><br>        <span class="hljs-comment">//问：我们可以把动态创建的 new String(&quot;ab&quot;)对象里的&quot;ab&quot; 放入串池吗？</span><br>        <span class="hljs-comment">//答：可以，用intern</span><br>        System.out.println(<span class="hljs-string">&quot;s是否等于&#x27;ab&#x27;：&quot;</span>+(s==<span class="hljs-string">&quot;ab&quot;</span>));<br>        String s2 = s.intern();<span class="hljs-comment">//将这个字符串对象尝试放入串池，如果有，则不会放入串池。</span><br>        System.out.println(<span class="hljs-string">&quot;使用s.intern()后，s2是否等于&#x27;ab&#x27;:&quot;</span> + (s2 == <span class="hljs-string">&quot;ab&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">s是否等于&#x27;ab&#x27;：false<br>使用s.intern()后，s2是否等于&#x27;ab&#x27;:true<br></code></pre></td></tr></table></figure><p>如果在s2之前打印s==”ab”,那么使用intern之后，s==”ab”都为false; 所以屏蔽<code>//System.out.println(&quot;s是否等于&#39;ab&#39;：&quot; + (s == &quot;ab&quot;));</code>,这时候，s==”ab”为true，s使用了串池的值”ab”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo23</span> </span>&#123;<br>    <span class="hljs-comment">//StringTable:[&quot;a&quot;,&quot;b&quot;]，无&quot;ab&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">// StringBuilder 动态拼接 new String(&quot;ab&quot;)</span><br><br>        <span class="hljs-comment">//堆有 new String(&quot;a&quot;)对象  new String(&quot;b&quot;)对象  new String(&quot;ab&quot;)对象</span><br>        <span class="hljs-comment">//问：我们可以把动态创建的 new String(&quot;ab&quot;)对象里的&quot;ab&quot; 放入串池吗？</span><br>        <span class="hljs-comment">//答：可以，用intern</span><br>        <span class="hljs-comment">//System.out.println(&quot;s是否等于&#x27;ab&#x27;：&quot; + (s == &quot;ab&quot;));</span><br>        String s2 = s.intern();<span class="hljs-comment">//将这个字符串对象尝试放入串池，如果有，则不会放入串池，会把串池中的对象返回。</span><br>        System.out.println(<span class="hljs-string">&quot;使用s.intern()后，s2是否等于&#x27;ab&#x27;:&quot;</span> + (s2 == <span class="hljs-string">&quot;ab&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;s是否等于&#x27;ab&#x27;：&quot;</span> + (s == <span class="hljs-string">&quot;ab&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">使用s.intern()后，s2是否等于&#x27;ab&#x27;:true<br>s是否等于&#x27;ab&#x27;：true<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo23</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String x = <span class="hljs-string">&quot;ab&quot;</span>;<span class="hljs-comment">//&quot;ab&quot;在串池中</span><br>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">//&quot;ab&quot;在堆里</span><br>        <br>        <span class="hljs-comment">//将这个字符串对象尝试放入串池，如果有，则不会放入串池，如果没有则放入串池；无论有没有，都会把串池中的对象返回。</span><br>        String s2 = s.intern();<span class="hljs-comment">//s2是串池中的&quot;ab&quot;；s是堆里创建出的&quot;ab&quot;</span><br>        System.out.println(<span class="hljs-string">&quot;s2 == x:&quot;</span>+(s2 == x));<br>        System.out.println(<span class="hljs-string">&quot;s == x:&quot;</span>+(s == x));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">s2 == x:true<br>s == x:false<br></code></pre></td></tr></table></figure><h4 id="1-5-5-5-回答最初的问题"><a href="#1-5-5-5-回答最初的问题" class="headerlink" title="1.5.5.5 回答最初的问题"></a>1.5.5.5 回答最初的问题</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> s1 = <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-keyword">String</span> s2 = <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-keyword">String</span> s3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-keyword">String</span> s4 = s1 + s2;<br><span class="hljs-keyword">String</span> s5 = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-keyword">String</span> s6 = s4.<span class="hljs-built_in">intern</span>();<br><br><span class="hljs-comment">// 问</span><br>System.out.<span class="hljs-built_in">println</span>(s3 == s4);<br>System.out.<span class="hljs-built_in">println</span>(s3 == s5);<br>System.out.<span class="hljs-built_in">println</span>(s3 == s6);<br><br><span class="hljs-keyword">String</span> x2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;d&quot;</span>);<br><span class="hljs-keyword">String</span> x1 = <span class="hljs-string">&quot;cd&quot;</span>;<br>x2.<span class="hljs-built_in">intern</span>();<br><br><span class="hljs-comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢 </span><br>System.out.<span class="hljs-built_in">println</span>(x1 == x2);<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">false<br>true<br>true<br>false<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> x2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;d&quot;</span>);<br>x2.<span class="hljs-built_in">intern</span>();<br><span class="hljs-keyword">String</span> x1 = <span class="hljs-string">&quot;cd&quot;</span>;<br><span class="hljs-comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢 </span><br>System.out.<span class="hljs-built_in">println</span>(x1 == x2);<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">true<br></code></pre></td></tr></table></figure><ul><li><code>String x2 = new String(&quot;c&quot;) + new String(&quot;d&quot;);</code>堆中创建字符串对象”cd”</li><li><code>x2.intern();</code>，串池中没有<code>&quot;cd&quot;</code>，则将”cd”加入串池中；</li><li><code>String x1 = &quot;cd&quot;;</code>串池中已经有”cd”，引用串池中已有的”cd”对象。</li><li>JDK1.6:false.</li></ul><h3 id="1-5-6-StringTable的位置"><a href="#1-5-6-StringTable的位置" class="headerlink" title="1.5.6 StringTable的位置"></a>1.5.6 StringTable的位置</h3><p>见 1.5.2 组成</p><h3 id="1-5-7-StringTable-垃圾回收"><a href="#1-5-7-StringTable-垃圾回收" class="headerlink" title="1.5.7 StringTable 垃圾回收"></a>1.5.7 StringTable 垃圾回收</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示 StringTable 垃圾回收</span><br><span class="hljs-comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_7</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123; <span class="hljs-comment">// j=100, j=10000</span><br>                String.valueOf(j).intern();<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;504K(2560K)] 2048K-&gt;781K(9728K), 0.0011268 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br><br></code></pre></td></tr></table></figure><h3 id="1-5-8-StringTable-性能调优"><a href="#1-5-8-StringTable-性能调优" class="headerlink" title="1.5.8 StringTable 性能调优"></a>1.5.8 StringTable 性能调优</h3><ul><li>调整 -XX:StringTableSize=桶个数</li><li>考虑将字符串对象是否入池</li></ul><h2 id="1-6-直接内存-操作系统内存"><a href="#1-6-直接内存-操作系统内存" class="headerlink" title="1.6 直接内存-操作系统内存"></a>1.6 直接内存-操作系统内存</h2><h3 id="1-6-1-定义"><a href="#1-6-1-定义" class="headerlink" title="1.6.1 定义"></a>1.6.1 定义</h3><p>Direct Memory</p><ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211224223955718.png" alt="image-20211224223955718"></p><p>有两块缓冲区:系统缓冲区，java缓冲区</p><p>所以比较慢</p><hr><p><img src="http://image.cryptomartin.top/img/image-20211224224225735.png" alt="image-20211224224225735"></p><ul><li><p>系统出的direct memory ，java可以直接访问。系统和java都可以用直接内存。</p></li><li><p>少了一层缓冲区。</p></li></ul><h3 id="1-6-2-分配和回收原理"><a href="#1-6-2-分配和回收原理" class="headerlink" title="1.6.2 分配和回收原理"></a>1.6.2 分配和回收原理</h3><ul><li>使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法</li><li>ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存</li></ul><p><code>-XX:+DisableExplicatGC</code> ：禁用显式GC，<code>System.gc()</code>；对于直接内存的回收有影响！长时间得不到释放。</p><p>如何解决？直接用Unsafe对象，调用 freeMemory 方法手动释放直接内存。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>JVM学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JVM引言</title>
    <link href="/2021/12/22/%E5%AD%A6%E4%B9%A0JVM%E5%BC%95%E8%A8%80/"/>
    <url>/2021/12/22/%E5%AD%A6%E4%B9%A0JVM%E5%BC%95%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="学习JVM引言"><a href="#学习JVM引言" class="headerlink" title="学习JVM引言"></a>学习JVM引言</h1><h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>Java Virtual Machine - java 程序的运行环境（java 二进制字节码的运行环境）</p><h3 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收功能</li><li>数组下标越界检查</li><li>多态</li></ul><h3 id="比较："><a href="#比较：" class="headerlink" title="比较："></a>比较：</h3><p>jvm jre jdk</p><p><img src="http://image.cryptomartin.top/img/image-20211222072056047.png" alt="image-20211222072056047"></p><p>JVM：屏蔽Java代码与底层的操作系统的差异</p><p>JRE：JVM基础上加上基础类库，就是JRE。基础类库是什么？jang.lang.*,集合类，线程类，日期类，IO类</p><p>JDK：JRE基础上加上编译工具，就是JDK。编译工具有javac，javap等</p><h2 id="学习JVM有什么用？"><a href="#学习JVM有什么用？" class="headerlink" title="学习JVM有什么用？"></a>学习JVM有什么用？</h2><ul><li>面试</li><li>理解底层原理的实现原理</li><li>中高级程序员的必备技能</li></ul><h2 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h2><p><img src="http://image.cryptomartin.top/img/image-20211222073020952.png" alt="image-20211222073020952"></p><blockquote><p><a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines">维基百科参考</a></p></blockquote><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="http://image.cryptomartin.top/img/image-20211222073238466.png" alt="image-20211222073238466"></p><blockquote><p><a href="https://www.javainterviewpoint.com/java-virtual-machine-architecture-in-java/">参考资料</a></p></blockquote><p>一个类从Java源代码编译为二进制字节码以后，经过类加载器，才能被加载到JVM中运行；</p><p>类都是放在<code>Method Area方法区</code>中，类将来创建的实例对象放在<code>Heap堆</code>中，而<code>Heap堆</code>里面的对象调用<code>方法</code>时,又会用到<code>JVM Stacks虚拟机栈</code>，<code>PC Register程序计数器</code>,<code>Native Method Stacks 本地方法栈</code>;</p><p><code>方法</code> 执行时，每行代码是由<code>执行引擎</code>中的<code>Interpret解释器</code>逐行进行一个执行；<code>方法里的热点代码</code>,即被频繁调用的代码，会由一个<code>JIT Compiler即时编译器</code>对<code>方法里的热点代码</code>做一个编译，也可以理解为做优化后的执行。</p><p><code>GC垃圾回收</code>会对<code>Heap堆</code>里面不再被引用的对象进行一个垃圾回收。</p><p>还有一些Java代码不方便实现的功能，必须调用底层操作系统的功能，跟操作系统交互需要一个<code>本地方法接口</code></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>JVM学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章 Java线程</title>
    <link href="/2021/12/20/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/12/20/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-Java线程"><a href="#第三章-Java线程" class="headerlink" title="第三章 Java线程"></a>第三章 Java线程</h1><p><strong>本章内容</strong>：</p><ul><li>创建和运行线程</li><li>查看线程</li><li>线程 API</li><li>线程状态</li></ul><h2 id="3-1-创建和运行线程"><a href="#3-1-创建和运行线程" class="headerlink" title="3.1 创建和运行线程"></a>3.1 创建和运行线程</h2><blockquote><p>每个程序一启动，都有一个主程序线程，称之为主线程。默认已经有一个主线程在运行了。</p></blockquote><h3 id="方法一，直接使用Thread"><a href="#方法一，直接使用Thread" class="headerlink" title="方法一，直接使用Thread"></a>方法一，直接使用Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程对象</span><br>Thread t = <span class="hljs-keyword">new</span> Thread() &#123;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 要执行的任务</span><br> &#125;<br>&#125;;<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//构造方法的参数是给线程指定名字，推荐</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//setName给线程指定名称</span><br>        <span class="hljs-comment">//t.setName(&quot;t1&quot;);</span><br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>        log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:42:09 [main] c.Test1 - running<br>16:42:09 [t1] c.Test1 - running<br></code></pre></td></tr></table></figure><h3 id="方法二，使用Runnable配合Thread"><a href="#方法二，使用Runnable配合Thread" class="headerlink" title="方法二，使用Runnable配合Thread"></a>方法二，使用Runnable配合Thread</h3><p>把【线程】和【任务】（要执行的代码）分开</p><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务（线程要执行的代码）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 要执行的任务</span><br>&#125;<br>&#125;;<br><span class="hljs-comment">// 创建线程对象，把runnable对象放入线程中</span><br>Thread t = <span class="hljs-keyword">new</span> Thread( runnable );<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建可运行的任务对象</span><br>        Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//创建线程对象,这边IDE提示：不建议显示创建线程，请使用线程池。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;t2&quot;</span>);<br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:54:14 [t2] c.Test2 - running<br></code></pre></td></tr></table></figure><p>Java8后可以使用lambda简化代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建可运行的任务对象</span><br>        Runnable runnable = () -&gt; log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>        <span class="hljs-comment">//创建线程对象,这边IDE提示：不建议显示创建线程，请使用线程池。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;t2&quot;</span>);<br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="***** 原理之 Thread 与 Runnable 的关系"></a>***** <strong>原理之</strong> <strong>Thread</strong> <strong>与</strong> <strong>Runnable</strong> 的关系</h3><blockquote><p>Test1是用了哪个run方法？</p></blockquote><p><img src="http://image.cryptomartin.top/img/image-20211218171132351.png" alt="image-20211218171132351"></p><blockquote><p>方法1是重写了父类的run方法，以子类的run方法为准。</p></blockquote><hr><blockquote><p>Test2是用了哪个run方法？</p></blockquote><p><img src="http://image.cryptomartin.top/img/image-20211218170423475.png" alt="image-20211218170423475"></p><p><img src="http://image.cryptomartin.top/img/image-20211218170523199.png" alt="image-20211218170523199"></p><p><img src="http://image.cryptomartin.top/img/image-20211218170708785.png" alt="image-20211218170708785"></p><p><img src="http://image.cryptomartin.top/img/image-20211218170923368.png" alt="image-20211218170923368"></p><blockquote><p>如果有Runnable对象，Thread优先采用Runnable对象的run方法。</p></blockquote><p><strong>小结</strong></p><ul><li>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合</li><li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><blockquote><p>更推荐Runnable的方法！！！优先组合关系，不是继承关系。</p></blockquote><h3 id="方法三，FutureTask配置Thread"><a href="#方法三，FutureTask配置Thread" class="headerlink" title="方法三，FutureTask配置Thread"></a>方法三，FutureTask配置Thread</h3><p><img src="http://image.cryptomartin.top/img/image-20211218172101398.png" alt="image-20211218172101398"></p><p><img src="http://image.cryptomartin.top/img/image-20211218172237257.png" alt="image-20211218172237257"></p><p><img src="http://image.cryptomartin.top/img/image-20211218172311299.png" alt="image-20211218172311299"></p><p>Future中的get方法可以返回任务执行的结果；Runnable是void没有返回结果。</p><hr><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        FutureTask&lt;Integer&gt; task =<span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>                <span class="hljs-comment">//让当前线程睡眠1s</span><br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//FutureTask实现了Runnable接口，所以可以放入Thread。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(task,<span class="hljs-string">&quot;t1&quot;</span>);<br>        t.start();<br><br>        <span class="hljs-comment">//主线程阻塞，等待结果FutureTask结果返回；FutureTask实现了任务及异步结果的集合功能</span><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,task.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">17:32:24 [t1] c.Test2 - running...<br>17:32:26 [main] c.Test2 - 100<br></code></pre></td></tr></table></figure><h2 id="3-2-观察多个线程同时运行"><a href="#3-2-观察多个线程同时运行" class="headerlink" title="3.2 观察多个线程同时运行"></a>3.2 观察多个线程同时运行</h2><p>主要是理解</p><ul><li>交替执行</li><li>谁先谁后，不由我们控制</li></ul><h2 id="3-3-查看进程线程的方法"><a href="#3-3-查看进程线程的方法" class="headerlink" title="3.3 查看进程线程的方法"></a>3.3 查看进程线程的方法</h2><p><strong>windows</strong></p><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li><code>tasklist</code> 查看进程</li><li><code>taskkill</code> 杀死进程</li></ul><p><strong>linux</strong></p><ul><li><code>ps -fe</code> 查看所有进程</li><li><code>ps -fT -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>top</code> 按大写 H 切换是否显示线程</li><li><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li></ul><h2 id="3-4-原理之线程运行"><a href="#3-4-原理之线程运行" class="headerlink" title="3.4 * 原理之线程运行"></a>3.4 * 原理之线程运行</h2><h3 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h3><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</p><ul><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法，互不干扰</li></ul><p>线程运行原理-栈帧图解：</p><p><img src="http://image.cryptomartin.top/img/image-20211218224550413.png" alt="image-20211218224550413"></p><h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul><h2 id="3-5-常见方法"><a href="#3-5-常见方法" class="headerlink" title="3.5 常见方法"></a>3.5 常见方法</h2><p><img src="http://image.cryptomartin.top/img/image-20211218230238918.png" alt="image-20211218230238918"></p><p><img src="http://image.cryptomartin.top/img/image-20211218230301086.png" alt="image-20211218230301086"></p><p><img src="http://image.cryptomartin.top/img/image-20211218230316126.png" alt="image-20211218230316126"></p><h3 id="3-5-1-Start与run"><a href="#3-5-1-Start与run" class="headerlink" title="3.5.1 Start与run"></a>3.5.1 Start与run</h3><p><strong>调用run方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>            log.debug(<span class="hljs-string">&quot;t1 Thread is running...&quot;</span>);<br>        &#125;<br>    &#125;;<br>    t1.run();<br>    log.debug(<span class="hljs-string">&quot;main Thread is running...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">23:16:48 [main] c.Test4 - t1 Thread is running...<br>23:16:48 [main] c.Test4 - main Thread is running...<br></code></pre></td></tr></table></figure><p>程序仍在 main 线程运行。</p><p><strong>调用start方法</strong></p><p>将上述代码中的<code>t1.run()</code>改为<code>t1.start()</code>，输出</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">23:21:01 [t1] c.Test4 - t1 Thread is running...<br>23:21:01 [main] c.Test4 - main Thread is running...<br></code></pre></td></tr></table></figure><p>程序在 t1 线程运行。</p><p><strong>小结</strong></p><ul><li>直接调用 <code>run()</code> 是在主线程中执行了 <code>run()</code>，没有启动新的线程</li><li>使用 <code>start()</code> 是启动新的线程，通过新的线程间接执行 <code>run()</code>方法 中的代码</li></ul><h3 id="3-5-2-sleep与yield"><a href="#3-5-2-sleep与yield" class="headerlink" title="3.5.2 sleep与yield"></a>3.5.2 sleep与yield</h3><p><strong>sleep</strong></p><ol><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 <code>InterruptedException</code>异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】</li><li>睡眠结束后的线程未必会立刻得到执行(需要分配到cpu时间片)</li><li>建议用 TimeUnit 的 <code>sleep()</code> 代替 Thread 的 <code>sleep()</code>来获得更好的可读性</li></ol><p>ps:<code>sleep()</code>方法写在哪个线程中，那个线程就进入睡眠。</p><p><strong>yield(让出的意思)</strong></p><ol><li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)</li></ol><p>阻塞状态与就绪状态线程区别：</p><ul><li>就绪状态，还是有机会被任务调度器调度的，任务调度器会分时间片给就绪状态的线程。</li><li>阻塞状态，任务调度器不会分时间片给阻塞状态的线程，只有睡眠时间到了，醒过来后，任务调度器才会时间片分给醒来的线程。</li></ul><p> <strong>小结</strong></p><p>yield让出cpu使用权，但是cpu可能会再分配时间片给该线程；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片</p><h3 id="3-5-3-线程优先级"><a href="#3-5-3-线程优先级" class="headerlink" title="3.5.3 线程优先级"></a>3.5.3 线程优先级</h3><ul><li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li><li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><h3 id="3-3-4-join"><a href="#3-3-4-join" class="headerlink" title="3.3.4 join"></a>3.3.4 join</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test10&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        test1();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>            r = <span class="hljs-number">10</span>;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">//t1.join();</span><br>        log.debug(<span class="hljs-string">&quot;结果为:&#123;&#125;&quot;</span>, r);<br>        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">11:58:20 [main] c.Test10 - 开始<br>11:58:20 [t1] c.Test10 - 开始<br>11:58:20 [main] c.Test10 - 结果为:0<br>11:58:20 [main] c.Test10 - 结束<br>11:58:21 [t1] c.Test10 - 结束<br></code></pre></td></tr></table></figure><p>分析</p><ul><li>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 <code>r=10</code></li><li>而主线程一开始就要打印 r 的结果，所以只能打印出 <code>r=0</code></li></ul><p>解决方法</p><ul><li>用 <code>sleep()</code> 行不行？为什么？</li><li>用 <code>join()</code>，加在 <code>t1.start()</code> 之后即可</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211219120326852.png" alt="image-20211219120326852"></p><p>以<code>调用方角度</code>来讲，如果:</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211219120527024.png" alt="image-20211219120527024"></p><blockquote><p><code>t1 thread</code>调用<code>join()</code>方法之后，<code>main thread</code>跟<code>t1 thread</code>是同步的，<code>main thread</code>必须等待<code>t1 thread</code>执行完成后，才能继续执行。</p></blockquote><p><strong>join()方法等待多个线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r1 = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r2 = <span class="hljs-number">0</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       test2();<br>   &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>           sleep(<span class="hljs-number">1</span>);<br>           r1 = <span class="hljs-number">10</span>;<br>       &#125;);<br>       Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>           sleep(<span class="hljs-number">2</span>);<br>           r2 = <span class="hljs-number">20</span>;<br>       &#125;);<br>       t1.start();<br>       t2.start();<br>       <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>       log.debug(<span class="hljs-string">&quot;join begin&quot;</span>);<br>       t2.join();<br>       log.debug(<span class="hljs-string">&quot;t2 join end&quot;</span>);<br>       t1.join();<br>       log.debug(<span class="hljs-string">&quot;t1 join end&quot;</span>);<br>       <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>       log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);<br>   &#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">14:16:35 [main] c.TestJoin - join begin<br>14:16:37 [main] c.TestJoin - t2 join end<br>14:16:37 [main] c.TestJoin - t1 join end<br>14:16:37 [main] c.TestJoin - r1: 10 r2: 20 cost: 2003<br></code></pre></td></tr></table></figure><p>分析如下</p><ul><li>第一个 join：等待 t1 时, t2 并没有停止, 而在运行</li><li>第二个 join：1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s</li></ul><p>如果颠倒两个 join 呢？</p><p>答：结果还是一样</p><p><strong>join(long n):最多等待n毫秒</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r1 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r2 = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    test3();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        sleep(<span class="hljs-number">2</span>);<br>        r1 = <span class="hljs-number">10</span>;<br>    &#125;);<br><br>    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>    t1.start();<br><br>    <span class="hljs-comment">// 线程执行结束会导致 join 结束</span><br>    log.debug(<span class="hljs-string">&quot;join begin&quot;</span>);<br>    t1.join(<span class="hljs-number">1500</span>);<br>    <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>    log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">14:24:33 [main] c.TestJoin - join begin<br>14:24:35 [main] c.TestJoin - r1: 0 r2: 0 cost: 1508<br></code></pre></td></tr></table></figure><blockquote><p>没等够时间，就按时间到期结束；如果等待时间还没万，但线程结束了，就不再等待了。</p></blockquote><h3 id="3-5-5-interrupt-方法详解"><a href="#3-5-5-interrupt-方法详解" class="headerlink" title="3.5.5 interrupt 方法详解"></a>3.5.5 interrupt 方法详解</h3><h4 id="interrupt可以打断-sleep，wait，join-的线程"><a href="#interrupt可以打断-sleep，wait，join-的线程" class="headerlink" title="interrupt可以打断 sleep，wait，join 的线程"></a>interrupt可以打断 sleep，wait，join 的线程</h4><p>阻塞</p><p>打断 sleep 的线程, 会清空打断状态，以 sleep 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>sleep(<span class="hljs-number">1</span>);<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>sleep(<span class="hljs-number">0.5</span>);<br>t1.interrupt();<br>log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">java.lang.InterruptedException: sleep interrupted<br> at java.lang.Thread.sleep(Native Method)<br> at java.lang.Thread.sleep(Thread.java:340)<br> at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)<br> at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)<br> at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)<br> at java.lang.Thread.run(Thread.java:745)<br>21:18:10.374 [main] c.TestInterrupt - 打断状态: false<br></code></pre></td></tr></table></figure><p><strong>打断正常运行的线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>Thread current = Thread.currentThread();<br>Boolean interrupted = current.isInterrupted();<br><span class="hljs-keyword">if</span>(interrupted) &#123;<br>log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br>sleep(<span class="hljs-number">0.5</span>);<br>t2.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">20:57:37.964 [t2] c.TestInterrupt - 打断状态: true<br></code></pre></td></tr></table></figure><p><strong>小结</strong></p><ul><li><p>如果位于特殊的阻塞状态，比如调用wait()、wait(long)或者join()或者sleep()等方法，中断标志位将会被清除，并且收到一个InterruptedException</p></li><li><p>打断正常运行的线程，调用<code>interrupt()</code>方法只是给线程打上一个中断标志位，并不会马上打断该线程。我们可以根据中断标志位来做一些操作。</p></li></ul><h4 id="【模式】模式之两阶段终止"><a href="#【模式】模式之两阶段终止" class="headerlink" title="【模式】模式之两阶段终止"></a>【模式】模式之两阶段终止</h4><p><code>Two Phase Termination</code><br>是在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。</p><p><strong>1.错误思路</strong></p><ul><li>使用线程对象的 stop() 方法停止线程<ul><li>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，<br>其它线程将永远无法获取锁</li></ul></li><li>使用 System.exit(int) 方法停止线程<ul><li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li></ul></li></ul><p><strong>2.两阶段终止模式</strong></p><p><img src="http://image.cryptomartin.top/img/image-20211220155929525.png" alt="image-20211220155929525"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        TwoPhaseTermination tpt = <span class="hljs-keyword">new</span> TwoPhaseTermination();<br>        tpt.start();<br><br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        tpt.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//监控类</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTermination</span> </span>&#123;<br>    <span class="hljs-comment">//创建监控线程，作为成员变量</span><br>    <span class="hljs-keyword">private</span> Thread monitor;<br><br>    <span class="hljs-comment">//开启监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">//不断执行</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-comment">//查看当前线程的中断标记</span><br>                Thread currentThread = Thread.currentThread();<br>                <span class="hljs-comment">//判断当前线程是否被打断</span><br>                <span class="hljs-keyword">if</span> (currentThread.isInterrupted()) &#123;<br>                    <span class="hljs-comment">//如果被打断</span><br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//如果当前线程没有被打断,睡眠1秒</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    <span class="hljs-comment">//没被打断，且没有异常；记录日志</span><br>                    log.debug(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                    <span class="hljs-comment">//在睡眠中被打断，会清除打断标记，打断标记此时为false;需要将中断标记置为真;重新设置打断标记为true</span><br>                    currentThread.interrupt();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//开启线程</span><br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">//停止监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:25:32 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>16:25:33 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>16:25:34 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>java.lang.InterruptedException: sleep interrupted<br><span class="hljs-code">at java.lang.Thread.sleep(Native Method)</span><br><span class="hljs-code">at com.sunk.test.TwoPhaseTermination.lambda$start$0(Test3.java:41)</span><br><span class="hljs-code">at java.lang.Thread.run(Thread.java:748)</span><br><span class="hljs-code">16:25:35 [Thread-0] c.TwoPhaseTermination - 料理后事</span><br></code></pre></td></tr></table></figure><p><strong>isInterrupted()与interrupted()区别</strong></p><ul><li><code>isInterrupted()</code>：判断当前线程是否被打断；不会清除打断标记</li><li><code>interrupted()</code>:判断当前线程是否被打断；会清除打断标记，如果打断标记为<code>true</code>，调用此方法后，变为<code>false</code></li></ul><h4 id="interrupted打断park线程"><a href="#interrupted打断park线程" class="headerlink" title="interrupted打断park线程"></a>interrupted打断park线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test14&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test14</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        test3();<br>    &#125;<br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>            log.debug(<span class="hljs-string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());<br>            <span class="hljs-comment">//打断标记为true，park就失效了。</span><br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        sleep(<span class="hljs-number">0.5</span>);<br>        t1.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:38:28 [t1] c.Test14 - park...<br>16:38:28 [t1] c.Test14 - unpark...<br>16:38:28 [t1] c.Test14 - 打断状态：true<br>16:38:28 [t1] c.Test14 - unpark...<br></code></pre></td></tr></table></figure><blockquote><p>如果打断标记已经是 true, 则 park 会失效</p></blockquote><h2 id="3-6-不推荐的方法"><a href="#3-6-不推荐的方法" class="headerlink" title="3.6 不推荐的方法"></a>3.6 不推荐的方法</h2><p><img src="http://image.cryptomartin.top/img/image-20211220164128203.png" alt="image-20211220164128203"></p><h2 id="3-7-守护线程"><a href="#3-7-守护线程" class="headerlink" title="3.7 守护线程"></a>3.7 守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做<code>守护线程</code>，<strong>只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test15&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test15</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;t1线程结束&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-comment">//设置t1线程为守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束</span><br>        t1.setDaemon(<span class="hljs-keyword">true</span>);<br>        t1.start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;主线程结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">19:06:21 [main] c.Test15 - 主线程结束<br></code></pre></td></tr></table></figure><blockquote><p>注意:</p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等<br>待它们处理完当前请求</li></ul></blockquote><h2 id="3-8-线程的五种状态"><a href="#3-8-线程的五种状态" class="headerlink" title="3.8 线程的五种状态"></a>3.8 线程的五种状态</h2><p>五种状态的划分主要是从操作系统的层面进行划分的</p><p><img src="http://image.cryptomartin.top/img/20200307093417-638644.png" alt="1583507073055"></p><ol><li><p>初始状态，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联</p></li><li><p>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</p></li><li><p>运行状态，指线程获取了CPU时间片，正在运行</p><ul><li>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</li></ul></li><li><p>阻塞状态</p><ul><li><p>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】</p></li><li><p>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p></li><li><p>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</p></li></ul></li><li><p>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ol><h2 id="3-9-线程的六种状态"><a href="#3-9-线程的六种状态" class="headerlink" title="3.9 线程的六种状态"></a>3.9 线程的六种状态</h2><p>这是从 Java API 层面来描述的，我们主要研究的就是这种。状态转换详情图：<a href="https://www.jianshu.com/p/ec94ed32895f">地址</a><br>根据 Thread.State 枚举，分为六种状态 </p><p><img src="http://image.cryptomartin.top/img/20200307093352-614933.png" alt="1583507709834"></p><ul><li>NEW 跟五种状态里的初始状态是一个意思</li><li> RUNNABLE 是当调用了 <code>start()</code> 方法之后的状态，注意，Java API 层面的 <code>RUNNABLE</code> 状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【io阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li><li><code>BLOCKED</code> ， <code>WAITING</code> ， <code>TIMED_WAITING</code> 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节<br> 详述</li></ul><h2 id="3-10-习题-统筹规划"><a href="#3-10-习题-统筹规划" class="headerlink" title="3.10 习题-统筹规划"></a>3.10 习题-统筹规划</h2><p><img src="http://image.cryptomartin.top/img/image-20211220194112708.png" alt="image-20211220194112708"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test16&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test16</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;洗水壶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            log.debug(<span class="hljs-string">&quot;烧开水，花费15分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">15</span>);<br>        &#125;, <span class="hljs-string">&quot;老王&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;洗茶壶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            log.debug(<span class="hljs-string">&quot;洗茶杯，花费2分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>            log.debug(<span class="hljs-string">&quot;拿茶叶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//小王模拟泡茶，等待开水烧开。</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                t1.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;可以泡茶了！&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;小王&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">19:38:37 [老王] c.Test16 - 洗水壶，花费1分钟<br>19:38:37 [小王] c.Test16 - 洗茶壶，花费1分钟<br>19:38:38 [老王] c.Test16 - 烧开水，花费15分钟<br>19:38:38 [小王] c.Test16 - 洗茶杯，花费2分钟<br>19:38:40 [小王] c.Test16 - 拿茶叶，花费1分钟<br>19:38:53 [小王] c.Test16 - 可以泡茶了！<br></code></pre></td></tr></table></figure><p>ps:秒代替分钟。</p><p>执行到<code>19:38:38 [老王] c.Test16 - 烧开水，花费15分钟</code>，会等待15秒，然后会执行<code>19:38:53 [小王] c.Test16 - 可以泡茶了！</code></p><h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><p>本章的重点在于掌握</p><ul><li><p>线程创建</p></li><li><p>线程重要 api，如 start，run，sleep，join，interrupt 等</p></li><li><p>线程状态</p></li><li><p>应用方面</p><ul><li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li><li>提高效率：并行计算，缩短运算时间</li><li>同步等待：join</li><li>统筹规划：合理使用线程，得到最优效果</li></ul></li><li><p>原理方面</p><ul><li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li><li>Thread 两种创建方式 的源码</li></ul></li><li><p>模式方面</p><ul><li>两阶段终止模式</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 七牛云外链图片无法显示</title>
    <link href="/2021/12/16/Hexo%20%E5%A4%96%E9%93%BE%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/"/>
    <url>/2021/12/16/Hexo%20%E5%A4%96%E9%93%BE%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-七牛云外链图片无法显示"><a href="#Hexo-七牛云外链图片无法显示" class="headerlink" title="Hexo 七牛云外链图片无法显示"></a>Hexo 七牛云外链图片无法显示</h1><h2 id="1-起因"><a href="#1-起因" class="headerlink" title="1. 起因"></a>1. 起因</h2><p>打算好好做Hexo博客，结果太折腾了。七牛云的图床，在Hexo博客结果不能显示，网上的方法用了很多都失败了，自己查了一下错误。</p><p>大概原因是：<code>github请求的协议是用HTTPS，而七牛云是HTTP，协议不兼容导致</code></p><p><img src="http://image.cryptomartin.top/img/image-20211216185546365.png" alt="image-20211216185546365"></p><h2 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h2><p><code>在七牛云打开强制HTTPS</code></p><p><img src="http://image.cryptomartin.top/img/image-20211216190015768.png" alt="image-20211216190015768"></p><p><img src="http://image.cryptomartin.top/img/image-20211216190203695.png" alt="image-20211216190203695"></p><h2 id="3-结果"><a href="#3-结果" class="headerlink" title="3. 结果"></a>3. 结果</h2><p>等待5分钟左右，就有七牛云发邮件，提示成功开启<code>强制HTTPS</code></p><p><img src="http://image.cryptomartin.top/img/image-20211216190318735.png" alt="image-20211216190318735"></p><p>Hexo成功显示七牛云外链图片：</p><p><img src="http://image.cryptomartin.top/img/image-20211216190503464.png" alt="image-20211216190503464"></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 进程与线程</title>
    <link href="/2021/12/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/12/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 进程与线程</h1><p><strong>本章内容</strong></p><ul><li>进程和线程的概念</li><li>并行和并发的概念</li><li>线程基本应用</li></ul><h2 id="2-1-进程与线程概念"><a href="#2-1-进程与线程概念" class="headerlink" title="2.1 进程与线程概念"></a>2.1 进程与线程概念</h2><h3 id="2-1-1-进程"><a href="#2-1-1-进程" class="headerlink" title="2.1.1 进程"></a>2.1.1 进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在<br>指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器<br>等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><p>简单说就是：</p><blockquote><p>进程：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程.</p></blockquote><h3 id="2-1-2-线程"><a href="#2-1-2-线程" class="headerlink" title="2.1.2 线程"></a>2.1.2 线程</h3><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作<br>为线程的容器</li></ul><blockquote><p>线程是进程当中的一条执行流程.</p></blockquote><blockquote><p>线程 = 进程 - 共享资源</p></blockquote><h3 id="2-1-3-进程与线程对比"><a href="#2-1-3-进程与线程对比" class="headerlink" title="2.1.3 进程与线程对比"></a>2.1.3 进程与线程对比</h3><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li><li>进程间通信较为复杂<ul><li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h2 id="2-2-并发与并行的概念"><a href="#2-2-并发与并行的概念" class="headerlink" title="2.2 并发与并行的概念"></a>2.2 并发与并行的概念</h2><p>单核 cpu 下，线程实际还是 <code>串行执行</code> 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows<br>下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感<br>觉是 同时运行的 。总结为一句话就是： <code>微观串行，宏观并行</code> ，<br>一般会将这种 线程轮流使用 CPU 的做法称为并发， concurrent</p><p><img src="http://image.cryptomartin.top/img/image-20211216152119986.png" alt="image-20211216152119986"></p><p>多核 cpu下，每个 核（core） 都可以调度运行线程，这时候线程可以是并行的。</p><p><img src="http://image.cryptomartin.top/img/image-20211216152309525.png" alt="image-20211216152309525"></p><blockquote><p>并发：一段时间内运行多个进程</p><p>并行：一个时间点运行多个进程，一般要求有多个CPU</p></blockquote><h2 id="2-3-应用"><a href="#2-3-应用" class="headerlink" title="2.3 应用"></a>2.3 应用</h2><h3 id="2-3-1-应用之异步调用（案例1）"><a href="#2-3-1-应用之异步调用（案例1）" class="headerlink" title="2.3.1 应用之异步调用（案例1）"></a>2.3.1 应用之异步调用（案例1）</h3><p>以调用方角度来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><h4 id="1-设计"><a href="#1-设计" class="headerlink" title="1) 设计"></a>1) 设计</h4><p>多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，这么cpu只能等5秒，啥都不能做。</p><h4 id="2-结论"><a href="#2-结论" class="headerlink" title="2) 结论"></a>2) 结论</h4><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li><li>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><h3 id="2-3-2-应用之提高效率（案例1）"><a href="#2-3-2-应用之提高效率（案例1）" class="headerlink" title="2.3.2 应用之提高效率（案例1）"></a>2.3.2 应用之提高效率（案例1）</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">计算 <span class="hljs-number">1</span> 花费 <span class="hljs-number">10</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">计算 2</span> 花费 <span class="hljs-number">11</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">计算 3</span> 花费 <span class="hljs-number">9</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">汇总需要 1</span> ms<br></code></pre></td></tr></table></figure><ul><li>如果是串行执行，那么总共花费的时间是 <code>10 + 11 + 9 + 1 = 31ms</code></li><li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个<br>线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 <code>11ms</code> 最后加上汇总时间只会花费 <code>12ms</code></li></ul><p><strong>注意</strong></p><blockquote><p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 并发编程概览</title>
    <link href="/2021/12/16/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E8%A7%88/"/>
    <url>/2021/12/16/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-并发编程概览"><a href="#第一章-并发编程概览" class="headerlink" title="第一章 并发编程概览"></a>第一章 并发编程概览</h1><h2 id="1-1-这门课主要学什么"><a href="#1-1-这门课主要学什么" class="headerlink" title="1.1 这门课主要学什么"></a>1.1 这门课主要学什么</h2><p>这门课中的【并发】一词涵盖了在 Java 平台上的</p><ul><li>进程</li><li>线程</li><li>并发</li><li>并行</li></ul><p>以及 Java 并发工具、并发问题以及解决方案，同时我也会讲解一些其它领域的并发</p><h2 id="1-2-为什么要学并发编程"><a href="#1-2-为什么要学并发编程" class="headerlink" title="1.2 为什么要学并发编程"></a>1.2 为什么要学并发编程</h2><ul><li><p>我工作中用不到并发啊？</p><p>  做CRUD，用不到并发编程；但希望往更高层面发展，必须学并发编程！平时用的Tomcat服务器、Dubbo、消息中间件等，这些底层肯定涉及多线程！</p></li></ul><h2 id="1-3-学习路线"><a href="#1-3-学习路线" class="headerlink" title="1.3 学习路线"></a>1.3 学习路线</h2><p>本门课程以并发、并行为主线，穿插讲解</p><p><strong>应用</strong> - 结合实际<br><strong>原理</strong> - 了然于胸<br><strong>模式</strong> - 正确姿势</p><ul><li><input disabled="" type="checkbox"> 思维导图</li></ul><h2 id="1-4-预备知识"><a href="#1-4-预备知识" class="headerlink" title="1.4 预备知识"></a>1.4 预备知识</h2><ul><li>有一定的框架经验</li><li>线程安全问题，需要你接触过 Java Web 开发、Jdbc 开发、Web 服务器、分布式框架时才会遇到</li><li>基于 JDK 8，最好对函数式编程、lambda 有一定了解</li><li>采用了 slf4j 打印日志，这是好的实践</li><li>采用了 lombok 简化 java bean 编写</li><li>给每个线程好名字，这也是一项好的实践</li></ul><p>pom.xml 依赖如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>logback.xml配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://ch.qos.logback/xml/ns/logback&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://ch.qos.logback/xml/ns/logback logback.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%date&#123;HH:mm:ss&#125; [%t] %logger - %m%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;c&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
