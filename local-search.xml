<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第二章 垃圾回收</title>
    <link href="/2022/02/02/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/02/02/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-垃圾回收"><a href="#第二章-垃圾回收" class="headerlink" title="第二章 垃圾回收"></a>第二章 垃圾回收</h1><p>本章内容：</p><ul><li>如何判断对象可以回收</li><li>垃圾回收算法</li><li>分代垃圾回收</li><li>垃圾回收器</li><li>垃圾回收调优</li></ul><h2 id="2-1-如何判断对象可以回收"><a href="#2-1-如何判断对象可以回收" class="headerlink" title="2.1 如何判断对象可以回收"></a>2.1 如何判断对象可以回收</h2><h3 id="2-1-1-引用计数法"><a href="#2-1-1-引用计数法" class="headerlink" title="2.1.1 引用计数法"></a>2.1.1 引用计数法</h3><p>顾名思义，此种算法会在每一个对象上记录这个对象被引用的次数，只要有任何一个对象引用了次对象，这个对象的计数器就+1，取消对这个对象的引用时，计数器就-1。任何一个时刻，如果该对象的计数器为0，那么这个对象就是可以回收的。</p><p>弊端：可能存在循环引用</p><p><img src="http://image.cryptomartin.top/img/image-20220126222346273.png" alt="image-20220126222346273"></p><blockquote><p>这种情况不会被垃圾回收。Java不采用引用计数法</p></blockquote><h3 id="2-1-2-可达性分析算法"><a href="#2-1-2-可达性分析算法" class="headerlink" title="2.1.2 可达性分析算法"></a>2.1.2 可达性分析算法</h3><p>可达性分析算法的主要思路是先找出一批根节点对象集合作为GC Roots（可称为根节点枚举），然后从这批根节点出发，查找其引用关系（类似于深度优先搜索），最终形成如下图这样的反映对象间依赖关系的图，若某些对象没有任何引用链与GC Roots相连（如下图中的Object5,Object6,Object7），则说明这些对象就是垃圾对象，是可以被垃圾收集器回收的。</p><p><img src="http://image.cryptomartin.top/img/1460000023838477" alt="image-20200829145357624"></p><ul><li>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li><li>扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收</li><li>哪些对象可以作为 GC Root ?</li></ul><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        List&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        System.out.println(<span class="hljs-number">1</span>);<br>        System.in.read();<br><br>        list=<span class="hljs-keyword">null</span>;<br>        System.out.println(<span class="hljs-number">2</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;end...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>先<code>jps</code>查出进程号为：10644</p></li><li><p><code>jmap -dump:format=b,live,file=1.bin 10644</code>          (<code>dump</code>:堆内存当前运行时状态存为一个文件;<code>format=b</code>:指定为二进制格式;<code>live</code>:只关心存活的对象，且在抓快照之前进行一次垃圾回收;<code>file=1.bin</code>:文件存在哪里？)</p><p><code>jmap -dump:format=b,live,file=2.bin 10644</code>  生成2.bin</p></li><li><p>使用<code>Memory Analyzer</code>进行分析 <a href="https://eclipse.org/mat/downloads.php">MAT下载地址</a></p></li></ol><p><img src="http://image.cryptomartin.top/img/image-20220126230305870.png" alt="image-20220126230305870"></p><p>查看<code>1.bin</code></p><p><code>gc root</code>可以分为四大类</p><p><img src="http://image.cryptomartin.top/img/image-20220126230917849.png" alt="image-20220126230917849"></p><p><img src="http://image.cryptomartin.top/img/image-20220126231016123.png" alt="image-20220126231016123"></p><p>图中所指，为代码中局部变量<code>list</code>所引用的对象<code>new ArrayList&lt;&gt;() </code>，可以作为一个<code>gc root</code></p><p>查看<code>2.bin</code></p><p><img src="http://image.cryptomartin.top/img/image-20220126231450669.png" alt="image-20220126231450669"></p><p>没有了<code>1.bin</code>中的<code>ArrayList</code>了。为什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">list=<span class="hljs-keyword">null</span>;<br>System.out.println(<span class="hljs-number">2</span>);<br>System.in.read();<br>System.out.println(<span class="hljs-string">&quot;end...&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>jmap -dump:format=b,live,file=2.bin 10644</code>,<code>live</code>执行了一次垃圾回收，把没有人引用的对象<code>new ArrayList&lt;&gt;()</code>对象回收了。</p><h3 id="2-1-3-四种引用"><a href="#2-1-3-四种引用" class="headerlink" title="2.1.3 四种引用"></a>2.1.3 四种引用</h3><h4 id="2-1-3-1四种引用介绍"><a href="#2-1-3-1四种引用介绍" class="headerlink" title="2.1.3.1四种引用介绍"></a>2.1.3.1四种引用介绍</h4><ol><li>强引用<ul><li>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li></ul></li><li>弱引用（WeakReference）<ul><li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li><li>可以配合引用队列来释放弱引用自身</li></ul></li><li>软引用（SoftReference）<ul><li>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</li><li>可以配合引用队列来释放软引用自身</li></ul></li><li>虚引用（PhantomReference）<ul><li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</li></ul></li><li>终结器引用（FinalReference）<ul><li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize方法，第二次 GC 时才能回收被引用对象</li></ul></li></ol><p><strong>强引用</strong></p><p><img src="http://image.cryptomartin.top/img/image-20220127110859359.png" alt="image-20220127110859359"></p><p>A1对象， C对象和B对象都不【强引用】A1对象，A1对象才会被垃圾回收</p><p><img src="http://image.cryptomartin.top/img/image-20220127110920966.png" alt="image-20220127110920966"></p><p><strong>弱引用和软引用</strong></p><p>软/弱引用跟强引用的区别：只要A2对象，A3对象直接地被强引用所引用，当垃圾回收发生时，都有可能被回收掉。</p><p>A2对象被C对象【强引用】一个【软引用】对象，然后通过【软引用】对象引用到A2对象，这算是一种间接途径。并且被B对象【强引用】，这种情况下，A2对象是不会被垃圾回收的。</p><p><img src="http://image.cryptomartin.top/img/image-20220127111954211.png" alt="image-20220127111954211"></p><p>当A2对象，没有被B对象【强引用】，没有其他任何【强引用】。只要满足下面的条件，A2对象是会被垃圾回收掉的：</p><ul><li>当垃圾回收发生时并且内存不够时</li></ul><p>这时，系统认为【软引用】引用的对象不够重要，当内存不够时，把它回收掉，腾出空间给更有用的对象来使用。</p><p><img src="http://image.cryptomartin.top/img/image-20220127112502360.png" alt="image-20220127112502360"></p><p>【弱引用】跟【软引用】非常像，也是当没有任何【强引用】引用A3对象，回收条件更宽松，只要发生了垃圾回收，不管内存是否充足。</p><p>都会被垃圾回收掉。</p><p><img src="http://image.cryptomartin.top/img/image-20220127112809512.png" alt="image-20220127112809512"></p><p>【软/弱引用】还可以配合【引用队列】来一起工作。</p><p>【软引用】引用的对象被回收掉后，【软引用】自身也是一个对象，【软引用】在创建时会被分配一个【引用队列】，当【软引用】引用的对象被垃圾回收掉后，【软引用】就会进入【引用队列】。</p><p><img src="http://image.cryptomartin.top/img/image-20220127113203936.png" alt="image-20220127113203936"></p><p>【弱引用】也是类似，【弱引用】引用的对象被垃圾回收掉后，【弱引用】也会进入【引用队列】</p><p><img src="http://image.cryptomartin.top/img/image-20220127113333844.png" alt="image-20220127113333844"></p><p>【软引用】【弱引用】占用的内存进行释放，需要【引用队列】来找到它们，做进一步的处理。</p><p><img src="http://image.cryptomartin.top/img/image-20220127113549470.png" alt="image-20220127113549470"></p><hr><p><strong>虚引用和终结器引用</strong></p><p>【软/弱引用】既可以配合【引用队列】使用，也可以不配合【引用队列】使用。</p><p>【虚引用】和终结器引用必须配合【引用队列】来使用</p><p><img src="http://image.cryptomartin.top/img/image-20220127135307614.png" alt="image-20220127135307614"></p><p>当【虚引用】创建出来时，会关联一个【引用队列】；当【终结器引用】创建出来时，也会关联一个【引用队列】；</p><p>【虚引用】在创建<code>ByteBuffer</code>时，会创建一个叫<code>Cleaner</code>的【虚引用对象】，<code>ByteBuffer</code>会分配一块【直接内存】，并且会把【直接内存】的地址会传给【虚引用对象】<code>Cleaner</code></p><p>如果<code>ByteBuffer</code>没有【强引用】来引用它了，<code>ByteBuffer</code>自己就会被垃圾回收掉。</p><p><img src="http://image.cryptomartin.top/img/image-20220127140057157.png" alt="image-20220127140057157"></p><p><img src="http://image.cryptomartin.top/img/image-20220127140113442.png" alt="image-20220127140113442"></p><p>然而<code>ByteBuffer</code>分配的【直接内存】并不能被Java垃圾回收所管理。如何解决呢？</p><p>就是在<code>ByteBufffer</code>被垃圾回收时，让【虚引用对象】进入【引用队列】。【虚引用】所在的【引用队列】会有一个<code>referrencehandler</code>的线程会定时地找有没有新入队的<code>Cleaner</code>。如果有，它就会调用<code>Cleaner</code>中的<code>clean()</code>方法，会根据前面记录的【直接内存】的地址，调用<code>Unsafe.freeMemory</code>，会把对应的直接内存释放掉。</p><p><img src="http://image.cryptomartin.top/img/image-20220127140929880.png" alt="image-20220127140929880"></p><p>这样处理就保证【直接内存】不会导致内存泄漏。</p><p><img src="http://image.cryptomartin.top/img/image-20220127141125626.png" alt="image-20220127141125626"></p><p>【终结器引用】，所有的Java对象都继承Object父类，而Object都有<code>finallize()</code>的方法，终结方法。</p><p>当A4对象重写了<code>finallize()</code>方法且没有【强引用】来引用它时，这时进行垃圾回收。那么，<code>finallize()</code>方法什么时候被调用呢？靠【终结器引用】</p><p>当A4对象重写了<code>finallize()</code>方法且没有【强引用】来引用它时，JVM会创建A4对象对应的【终结器引用】；当A4对象被垃圾回收时，会把【终结器引用】加入到【引用队列】。注意：这时，A4对象还没有被垃圾回收。</p><p><img src="http://image.cryptomartin.top/img/image-20220127142754103.png" alt="image-20220127142754103"></p><p>这时A4不是立即垃圾回收，再由一个优先级很低的线程，在某时刻该线程会查看【引用队列中】是否有一个【终结器引用】，会找到【终结器】引用的对象A4，并且调用A4对象的<code>finallize()</code>方法，等调用完后，下一次垃圾回收时，会把A4对象占用的内存真正释放掉。</p><p><img src="http://image.cryptomartin.top/img/image-20220127143232356.png" alt="image-20220127143232356"></p><blockquote><p><code>finallize()</code>方法效率很低，第一次垃圾回收时没有真正回收掉；而是把【终结器引用】入队后，优先级很低的线程执行的机会很少，对象的<code>finallize()</code>方法迟迟没有被调用，对象占用的内存也迟迟没有被释放。</p><p>所以，不推荐用<code>finallize()</code>来释放资源！</p></blockquote><h4 id="2-1-3-2-软引用-应用"><a href="#2-1-3-2-软引用-应用" class="headerlink" title="2.1.3.2 软引用_应用"></a>2.1.3.2 软引用_应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示软引用</span><br><span class="hljs-comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_3</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4MB=<span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        List&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>        &#125;<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space<br>at com.sunk.jvm.t2.Demo2_3.main(Demo2_3.java:<span class="hljs-number">17</span>)<br></code></pre></td></tr></table></figure><p>例如有一个场景：byte[]是读取网络上的图片，这些图片显示需要放到一个<code>list</code>集合中,但是这些图片资源不属于核心业务资源。图片数量过多，使用【强引用】来引用这些图片资源，会导致内存溢出的错误。</p><p>解决思路：这些不重要的资源，在内存紧张时，把它占用的内存释放掉。以后用到某图片，可以再次读取一次该图片。【强引用】不适合该场景。可以考虑采用【软引用】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">soft</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//list --&gt; SoftReference --&gt; byte[]</span><br>    List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>        System.out.println(ref.get());<br>        list.add(ref);<br>        System.out.println(list.size());<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());<br>    <span class="hljs-keyword">for</span> (SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref : list) &#123;<br>        System.out.println(ref.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>List是先强引用软引用对象SoftReference,软引用对象然后软引用byte[]数组</p><p>执行<code>soft</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">[B@330bedb4<br><span class="hljs-number">1</span><br>[B@2503dbd3<br><span class="hljs-number">2</span><br>[B@4b67cf4d<br><span class="hljs-number">3</span><br>[B@7ea987ac<br><span class="hljs-number">4</span><br>[B@12a3a380<br><span class="hljs-number">5</span><br>循环结束：<span class="hljs-number">5</span><br><span class="hljs-keyword">null</span><br><span class="hljs-keyword">null</span><br><span class="hljs-keyword">null</span><br><span class="hljs-keyword">null</span><br>[B@12a3a380<br><br></code></pre></td></tr></table></figure><p>发现：加了5次4MB的对象，并没有造成内存溢出(VM options设置:-Xmx20m)，循环5次。但是等循环结束，再次循环5次，调用软引用的get，前4个都变成了null，最后一个保留了。</p><p>再深入看一下垃圾回收过程，<code>VM options：-Xmx20m -XX:+PrintGCDetails -verbose:gc</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">[B@330bedb4<br><span class="hljs-number">1</span><br>[B@2503dbd3<br><span class="hljs-number">2</span><br>[B@4b67cf4d<br><span class="hljs-number">3</span><br>[GC (Allocation Failure) [PSYoungGen: 1934K-&gt;504K(6144K)] 14222K-&gt;12981K(19968K), <span class="hljs-number">0.0012385</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[B@7ea987ac<br><span class="hljs-number">4</span><br>[GC (Allocation Failure) --[PSYoungGen: 4825K-&gt;4825K(6144K)] 17303K-&gt;17399K(19968K), <span class="hljs-number">0.0009838</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Ergonomics)</span> [PSYoungGen: 4825K-&gt;4566<span class="hljs-title">K</span><span class="hljs-params">(6144K)</span>] [ParOldGen: 12573K-&gt;12477<span class="hljs-title">K</span><span class="hljs-params">(13824K)</span>] 17399K-&gt;17043<span class="hljs-title">K</span><span class="hljs-params">(19968K)</span>, [Metaspace: 3301K-&gt;3301<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0055370 secs] [Times: user</span>=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) --[PSYoungGen: 4566K-&gt;4566K(6144K)] 17043K-&gt;17043K(19968K), <span class="hljs-number">0.0008829</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Allocation Failure)</span> [PSYoungGen: 4566K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(6144K)</span>] [ParOldGen: 12477K-&gt;641<span class="hljs-title">K</span><span class="hljs-params">(8704K)</span>] 17043K-&gt;641<span class="hljs-title">K</span><span class="hljs-params">(14848K)</span>, [Metaspace: 3301K-&gt;3301<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0054372 secs] [Times: user</span>=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>[B@12a3a380<br><span class="hljs-number">5</span><br>循环结束：<span class="hljs-number">5</span><br><span class="hljs-keyword">null</span><br><span class="hljs-keyword">null</span><br><span class="hljs-keyword">null</span><br><span class="hljs-keyword">null</span><br>[B@12a3a380<br>Heap<br> PSYoungGen      total 6144K, used 4263K [<span class="hljs-number">0x00000000ff980000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>  eden space 5632K, <span class="hljs-number">75</span>% used [<span class="hljs-number">0x00000000ff980000</span>,<span class="hljs-number">0x00000000ffda9c88</span>,<span class="hljs-number">0x00000000fff00000</span>)<br>  from space 512K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x00000000fff80000</span>)<br>  to   space 512K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x0000000100000000</span>)<br> ParOldGen       total 8704K, used 641K [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000ff480000</span>, <span class="hljs-number">0x00000000ff980000</span>)<br>  object space 8704K, <span class="hljs-number">7</span>% used [<span class="hljs-number">0x00000000fec00000</span>,<span class="hljs-number">0x00000000feca0538</span>,<span class="hljs-number">0x00000000ff480000</span>)<br> Metaspace       used 3308K, capacity 4500K, committed 4864K, reserved 1056768K<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">space</span>    <span class="hljs-title">used</span> 360<span class="hljs-title">K</span>, <span class="hljs-title">capacity</span> 388<span class="hljs-title">K</span>, <span class="hljs-title">committed</span> 512<span class="hljs-title">K</span>, <span class="hljs-title">reserved</span> 1048576<span class="hljs-title">K</span></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">Process</span> <span class="hljs-title">finished</span> <span class="hljs-title">with</span> <span class="hljs-title">exit</span> <span class="hljs-title">code</span> 0</span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure><p>第3次循环分配失败，触发了垃圾回收，新生代:<code>PSYoungGen: 1934K-&gt;504K(6144K)</code>，内存空闲了不少。</p><p>第4次循环内存还是不够，触发了垃圾回收，新生代:<code>PSYoungGen: 4825K-&gt;4825K(6144K)</code>,效率不高；所以触发了<code>Full GC</code>，不光回收新生代，还回收老年代，<code>[PSYoungGen: 4825K-&gt;4566K(6144K)] [ParOldGen: 12573K-&gt;12477K(13824K)]</code>,结果还是没回收多少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>System.out.println(ref.get());<br>list.add(ref);<br>System.out.println(list.size());<span class="hljs-comment">//先添加，再打印list的大小。</span><br></code></pre></td></tr></table></figure><p>前4次循环，已经把内存占满了，想放第5个byte[]数组时放不下了。一次<code>Full GC</code>内存空间仍然不够，这时触发了软引用的内存回收。会把软引用引用的对象释掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) --[PSYoungGen: 4566K-&gt;4566K(6144K)] 17043K-&gt;17043K(19968K), <span class="hljs-number">0.0008829</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Allocation Failure)</span> [PSYoungGen: 4566K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(6144K)</span>] [ParOldGen: 12477K-&gt;641<span class="hljs-title">K</span><span class="hljs-params">(8704K)</span>] 17043K-&gt;641<span class="hljs-title">K</span><span class="hljs-params">(14848K)</span>, [Metaspace: 3301K-&gt;3301<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0054372 secs] [Times: user</span>=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br></code></pre></td></tr></table></figure><p>最后一次，<code>PSYoungGen: 4566K-&gt;0K(6144K)</code>新生代的内存占用变为0，<code>ParOldGen: 12477K-&gt;641K(8704K)</code>老年代的内存占用变为641k。代价就是把前4个Byte[]数组对象占用的内存释放掉，只有最后1个Byte[]数组没释放。</p><blockquote><p>在内存敏感的场景中，把不重要的资源用软引用去引用，当内存紧张时，可以把软引用的对象占用的内存回收掉。</p></blockquote><p>在上面的输出结果中，有效的只有最后1个，其他为null的无效了。我们希望把无用的软引用进行清理，因为软引用对象本身也是占用内存的。</p><p>如何清理无用的软引用？使用引用队列！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示软引用，配合引用队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_4</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br><br><br>        <span class="hljs-comment">//引用队列</span><br>        ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-comment">//关联了引用队列，当软引用所关联的byte[]数组对象被回收时，软引用自己会加入到引用队列queue中去。</span><br>            SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB],queue);<br>            System.out.println(ref.get());<br>            list.add(ref);<br>            System.out.println(list.size());<br>        &#125;<br><br>        <span class="hljs-comment">//去除掉无用的软引用</span><br>        Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<br>        <span class="hljs-keyword">while</span> (poll!= <span class="hljs-keyword">null</span>)&#123;<br>            list.remove(poll);<br>            <span class="hljs-comment">//在引用队列中回去下一个无用的软引用；因为无用的软引用才会加入到引用队列queue中</span><br>            poll= queue.poll();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());<br>        <span class="hljs-keyword">for</span> (SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref : list) &#123;<br>            System.out.println(ref.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：VM记得加：<code>-Xmx20m</code></p><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">[B@330bedb4<br><span class="hljs-number">1</span><br>[B@2503dbd3<br><span class="hljs-number">2</span><br>[B@4b67cf4d<br><span class="hljs-number">3</span><br>[B@7ea987ac<br><span class="hljs-number">4</span><br>[B@12a3a380<br><span class="hljs-number">5</span><br>循环结束：<span class="hljs-number">1</span><br>[B@12a3a380<br></code></pre></td></tr></table></figure><p>成功地消除了无用的软引用！</p><h4 id="2-1-3-3-弱引用-示例"><a href="#2-1-3-3-弱引用-示例" class="headerlink" title="2.1.3.3 弱引用_示例"></a>2.1.3.3 弱引用_示例</h4><p>弱引用跟软引用很类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示弱引用</span><br><span class="hljs-comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_5</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//list</span><br>        List&lt;WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>            list.add(ref);<br>            <span class="hljs-keyword">for</span> (WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; w : list) &#123;<br>                System.out.print(w.get() + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">[B@330bedb4 <br>[B@330bedb4 [B@2503dbd3 <br>[B@330bedb4 [B@2503dbd3 [B@4b67cf4d <br>[GC (Allocation Failure) [PSYoungGen: 1934K-&gt;488K(6144K)] 14222K-&gt;13025K(19968K), <span class="hljs-number">0.0011759</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[B@330bedb4 [B@2503dbd3 [B@4b67cf4d [B@7ea987ac <br>[GC (Allocation Failure) [PSYoungGen: 4696K-&gt;488K(6144K)] 17234K-&gt;13105K(19968K), <span class="hljs-number">0.0013181</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[B@330bedb4 [B@2503dbd3 [B@4b67cf4d <span class="hljs-keyword">null</span> [B@12a3a380 <br>[GC (Allocation Failure) [PSYoungGen: 4696K-&gt;480K(6144K)] 17313K-&gt;13097K(19968K), <span class="hljs-number">0.0009407</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[B@330bedb4 [B@2503dbd3 [B@4b67cf4d <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> [B@29453f44 <br>[GC (Allocation Failure) [PSYoungGen: 4687K-&gt;480K(6144K)] 17304K-&gt;13097K(19968K), <span class="hljs-number">0.0007364</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[B@330bedb4 [B@2503dbd3 [B@4b67cf4d <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> [B@5cad8086 <br>[GC (Allocation Failure) [PSYoungGen: 4686K-&gt;496K(6144K)] 17304K-&gt;13121K(19968K), <span class="hljs-number">0.0012411</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[B@330bedb4 [B@2503dbd3 [B@4b67cf4d <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> [B@6e0be858 <br>[GC (Allocation Failure) [PSYoungGen: 4702K-&gt;512K(5120K)] 17328K-&gt;13137K(18944K), <span class="hljs-number">0.0007849</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[B@330bedb4 [B@2503dbd3 [B@4b67cf4d <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> [B@61bbe9ba <br>[GC (Allocation Failure) [PSYoungGen: 4698K-&gt;96K(5632K)] 17323K-&gt;13137K(19456K), <span class="hljs-number">0.0006953</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Ergonomics)</span> [PSYoungGen: 96K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(5632K)</span>] [ParOldGen: 13041K-&gt;659<span class="hljs-title">K</span><span class="hljs-params">(8192K)</span>] 13137K-&gt;659<span class="hljs-title">K</span><span class="hljs-params">(13824K)</span>, [Metaspace: 3299K-&gt;3299<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0071561 secs] [Times: user</span>=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br><span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> [B@610455d6 <br>循环结束：<span class="hljs-number">10</span><br>Heap<br> PSYoungGen      total 5632K, used 4278K [<span class="hljs-number">0x00000000ff980000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>  eden space 4608K, <span class="hljs-number">92</span>% used [<span class="hljs-number">0x00000000ff980000</span>,<span class="hljs-number">0x00000000ffdadae8</span>,<span class="hljs-number">0x00000000ffe00000</span>)<br>  from space 1024K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ffe00000</span>,<span class="hljs-number">0x00000000ffe00000</span>,<span class="hljs-number">0x00000000fff00000</span>)<br>  to   space 1024K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x0000000100000000</span>)<br> ParOldGen       total 8192K, used 659K [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff980000</span>)<br>  object space 8192K, <span class="hljs-number">8</span>% used [<span class="hljs-number">0x00000000fec00000</span>,<span class="hljs-number">0x00000000feca4e70</span>,<span class="hljs-number">0x00000000ff400000</span>)<br> Metaspace       used 3308K, capacity 4500K, committed 4864K, reserved 1056768K<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">space</span>    <span class="hljs-title">used</span> 359<span class="hljs-title">K</span>, <span class="hljs-title">capacity</span> 388<span class="hljs-title">K</span>, <span class="hljs-title">committed</span> 512<span class="hljs-title">K</span>, <span class="hljs-title">reserved</span> 1048576<span class="hljs-title">K</span></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">Process</span> <span class="hljs-title">finished</span> <span class="hljs-title">with</span> <span class="hljs-title">exit</span> <span class="hljs-title">code</span> 0</span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure><p>第9次循环时，有4个弱引用；但在第10次循环时，只有最后1个弱引用，因为弱引用本身也占用内存，导致内存不足，弱引用引用的对象被垃圾回收。</p><p>如想清理无用的弱引用，需要配合引用队列来使用。跟清理无用的软引用类似！</p><h2 id="2-2-垃圾回收算法"><a href="#2-2-垃圾回收算法" class="headerlink" title="2.2 垃圾回收算法"></a>2.2 垃圾回收算法</h2><h3 id="2-2-1-标记-清除算法"><a href="#2-2-1-标记-清除算法" class="headerlink" title="2.2.1 标记-清除算法"></a>2.2.1 标记-清除算法</h3><p>最基础的收集算法时”标记-清除“(Mark-Sweep)算法。算法分为”标记“和”清除“两个阶段。</p><p>首先，标记出所有需要回收的对象，然后在标记完成后统一回收所有被标记的对象。</p><p><img src="http://image.cryptomartin.top/img/image-20220128222929252.png" alt="image-20220128222929252"></p><p>对对象所占用的内存空间进行释放，这里有人会有误区：释放，是不是要把所需要释放的内存清零呢？注意，不需要！</p><p>把对象所占用的内存起始结束的地址记录下来，放在一个空闲的地址列表里。下次分配新对象的时候，去空闲列表中有没有一块合适的内存空间容纳新对象；如果有，进行一个内存分配，并不会把内存进行清零处理。</p><p><strong>标记-清除 算法的优缺点</strong></p><p>优点</p><ul><li>垃圾回收速度快，只需要记录所回收对象所占用的内存起始结束的地址</li></ul><p>缺点</p><ul><li>容易产生大量不连续的内存碎片</li></ul><h3 id="2-2-2-标记-整理算法"><a href="#2-2-2-标记-整理算法" class="headerlink" title="2.2.2 标记-整理算法"></a>2.2.2 标记-整理算法</h3><p><img src="http://image.cryptomartin.top/img/image-20220128223623050.png" alt="image-20220128223623050"></p><p>”标记-整理“(Mark-Compact)算法，标记过程跟”标记-清除“算法一样，但是第二步整理，不是直接对可回收对象进行清除，而是让所有存货的对象都想一端移动，然后直接清除掉端边界以外的内存。</p><p><strong>标记-整理算法优缺点</strong></p><p>优点</p><ul><li>没有内存碎片</li></ul><p>缺点</p><ul><li>整理过程涉及到对象的移动，必然效率变低。</li></ul><h3 id="2-2-3-复制算法"><a href="#2-2-3-复制算法" class="headerlink" title="2.2.3 复制算法"></a>2.2.3 复制算法</h3><p><img src="http://image.cryptomartin.top/img/image-20220128224432197.png" alt="image-20220128224432197"></p><p>复制算法将可用内存按容量分为大小相等的两块，一块叫<code>FROM区域</code>，另一块叫<code>TO区域</code></p><p><img src="http://image.cryptomartin.top/img/image-20220128225002982.png" alt="image-20220128225002982"></p><p>复制算法首先也是做标记，把不被<code>GC Root</code>引用的对象标记为垃圾，然后把<code>FROM区域</code>存活的对象赋值到<code>TO区域</code>，复制的过程就会完成碎片的整理，不会产生碎片</p><p><img src="http://image.cryptomartin.top/img/image-20220128225113936.png" alt="image-20220128225113936"></p><p>等复制完成，清空<code>FROM区域</code></p><p><img src="http://image.cryptomartin.top/img/image-20220128225516448.png" alt="image-20220128225516448"></p><p>然后交换<code>FROM区域</code>和<code>TO区域</code>的位置，<code>TO区域</code>总是空闲的。</p><p><strong>复制算法优缺点</strong></p><p>优点</p><ul><li>不会产生内存碎片</li></ul><p>缺点</p><ul><li>占用双倍的内存空间</li></ul><h3 id="2-2-4-回收算法小结"><a href="#2-2-4-回收算法小结" class="headerlink" title="2.2.4 回收算法小结"></a>2.2.4 回收算法小结</h3><p><strong>标记-清除算法</strong></p><p><img src="http://image.cryptomartin.top/img/image-20220128230128163.png" alt="image-20220128230128163"></p><p><strong>标记-整理算法</strong></p><p><img src="http://image.cryptomartin.top/img/image-20220128230147031.png" alt="image-20220128230147031"></p><p><strong>复制算法</strong></p><p><img src="http://image.cryptomartin.top/img/image-20220128230205689.png" alt="image-20220128230205689"></p><h2 id="2-3-分代垃圾回收"><a href="#2-3-分代垃圾回收" class="headerlink" title="2.3 分代垃圾回收"></a>2.3 分代垃圾回收</h2><h3 id="2-3-1-基本介绍"><a href="#2-3-1-基本介绍" class="headerlink" title="2.3.1 基本介绍"></a>2.3.1 基本介绍</h3><p><img src="http://image.cryptomartin.top/img/image-20220129154032961.png" alt="image-20220129154032961"></p><p>现在的垃圾收集都采用”分代收集“(Generation Collection)算法。主要思想是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为<code>新生代</code>和<code>老年代</code>。</p><p>新生代又分为3个小的区域，<code>伊甸园</code>，<code>幸存区From</code>，<code>幸存区To</code>。</p><p>长时间使用的对象放在老年代中，而那些用完就丢弃的对象放在新生代。</p><h3 id="2-3-2-分代回收的基本流程"><a href="#2-3-2-分代回收的基本流程" class="headerlink" title="2.3.2 分代回收的基本流程"></a>2.3.2 分代回收的基本流程</h3><p><img src="http://image.cryptomartin.top/img/image-20220129154854580.png" alt="image-20220129154854580"></p><p>新的对象被创建，会采用伊甸园的一块空间。当有更多新的对象，它们都在伊甸园中，伊甸园逐渐被沾满了，容纳不下新的对象了，这时就会触发垃圾回收—<code>Minor GC</code>。</p><p><img src="http://image.cryptomartin.top/img/image-20220129155832652.png" alt="image-20220129155832652"></p><p>第一次Minor GC 触发以后，会采用可达性算法，找出有用的对象，标记需要回收的对象进行回收，然后采用复制算法，把存活的对象复制到幸存区To中，会把存活的对象寿命+1(刚开始为0)，交换幸存区From和幸存区To的位置。</p><p><img src="http://image.cryptomartin.top/img/image-20220129160754037.png" alt="image-20220129160754037"></p><p>当Minor GC出发以后，伊甸园空间充足了，又可以在伊甸园创建新的对象。当伊甸园又满了，触发第二次垃圾回收—<code>Minor GC</code>。第二次垃圾回收，不仅要在伊甸园找出存活的对象，还要在幸存区From中找出继续存活的对象(有可能有对象在幸存区时没被引用) 。然后采用复制算法，把存活的对象(包括伊甸园和幸存区From中的对象)复制到幸存区To中，然后象寿命+1，剩下的对象进行回收，交换幸存区From和幸存区To的位置。</p><p><img src="http://image.cryptomartin.top/img/image-20220129164910714.png" alt="image-20220129164910714"></p><p>当幸存区的对象寿命超过阈值(如15)，就晋升到老年代中。有价值的对象逐渐到老年代。<br>当新生代和老年代对象都满了，新对象添加不进去新生代，这时触发了一次老年代垃圾回收—<code>Full GC</code>，做一次整个的清理，从新生代到老年代。</p><h3 id="2-3-3-分代回收要点"><a href="#2-3-3-分代回收要点" class="headerlink" title="2.3.3 分代回收要点"></a>2.3.3 分代回收要点</h3><p><img src="http://image.cryptomartin.top/img/image-20220129165020111.png" alt="image-20220129165020111"></p><ul><li>对象首先分配在伊甸园区域</li><li>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to</li><li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</li><li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长</li></ul><h3 id="2-3-4-相关VM参数"><a href="#2-3-4-相关VM参数" class="headerlink" title="2.3.4 相关VM参数"></a>2.3.4 相关VM参数</h3><table><thead><tr><th align="left">含义</th><th align="left">参数</th></tr></thead><tbody><tr><td align="left">堆初始大小</td><td align="left">-Xms</td></tr><tr><td align="left">堆最大大小</td><td align="left">-Xmx 或 -XX:MaxHeapSize=size</td></tr><tr><td align="left">新生代大小</td><td align="left">-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td></tr><tr><td align="left">幸存区比例(动态)</td><td align="left">-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td align="left">幸存区比例</td><td align="left">-XX:SurvivorRatio=ratio</td></tr><tr><td align="left">晋升阈值</td><td align="left">-XX:MaxTenuringThreshold=threshold</td></tr><tr><td align="left">晋升详情</td><td align="left">-XX:+PrintTenuringDistribution</td></tr><tr><td align="left">GC详情</td><td align="left">-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td align="left">FullGC 前 MinorGC</td><td align="left">-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h3 id="2-3-5-案例分析GC"><a href="#2-3-5-案例分析GC" class="headerlink" title="2.3.5 案例分析GC"></a>2.3.5 案例分析GC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_1</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的代码，运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Heap<br> def <span class="hljs-keyword">new</span> generation   total 9216K, used 2190K [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ff600000</span>)<br>  eden space 8192K,  <span class="hljs-number">26</span>% used [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000fee23870</span>, <span class="hljs-number">0x00000000ff400000</span>)<br>  from space 1024K,   <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff500000</span>)<br>  to   space 1024K,   <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff500000</span>, <span class="hljs-number">0x00000000ff500000</span>, <span class="hljs-number">0x00000000ff600000</span>)<br> tenured generation   total 10240K, used 0K [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>   the space 10240K,   <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ff600200</span>, <span class="hljs-number">0x0000000100000000</span>)<br> Metaspace       used 3161K, capacity 4496K, committed 4864K, reserved 1056768K<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">space</span>    <span class="hljs-title">used</span> 344<span class="hljs-title">K</span>, <span class="hljs-title">capacity</span> 388<span class="hljs-title">K</span>, <span class="hljs-title">committed</span> 512<span class="hljs-title">K</span>, <span class="hljs-title">reserved</span> 1048576<span class="hljs-title">K</span></span><br></code></pre></td></tr></table></figure><ul><li><p><code>total 9216K</code>:新生代空间为什么只有7MB，我们设置的时10MB？8MB分给伊甸园，另外幸存区From和幸存区To各占1MB，这里认为幸存区To的1MB始终是空的，不能用的。计算空间时不计入幸存区To。</p></li><li><p><code>[0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</code>为内存地址</p></li><li><p><code> eden space 8192K,  26%</code>:为什么伊甸园一开始有东西了呢？因为再简单的Java程序执行，都需要加载必须的一些类，这些类使用伊甸园的内存空间。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_1</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_7MB]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>伊甸园一开始已经有26%的占用了，现在再加入7MB的数组，已经放不下了，这时会触发GC。运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [DefNew: 2025K-&gt;624K(9216K), <span class="hljs-number">0.0014746</span> secs] 2025K-&gt;624K(19456K), <span class="hljs-number">0.0015406</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>Heap<br> def <span class="hljs-keyword">new</span> generation   total 9216K, used 8202K [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ff600000</span>)<br>  eden space 8192K,  <span class="hljs-number">92</span>% used [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000ff366830</span>, <span class="hljs-number">0x00000000ff400000</span>)<br>  from space 1024K,  <span class="hljs-number">60</span>% used [<span class="hljs-number">0x00000000ff500000</span>, <span class="hljs-number">0x00000000ff59c208</span>, <span class="hljs-number">0x00000000ff600000</span>)<br>  to   space 1024K,   <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff500000</span>)<br> tenured generation   total 10240K, used 0K [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>   the space 10240K,   <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ff600200</span>, <span class="hljs-number">0x0000000100000000</span>)<br> Metaspace       used 3291K, capacity 4496K, committed 4864K, reserved 1056768K<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">space</span>    <span class="hljs-title">used</span> 358<span class="hljs-title">K</span>, <span class="hljs-title">capacity</span> 388<span class="hljs-title">K</span>, <span class="hljs-title">committed</span> 512<span class="hljs-title">K</span>, <span class="hljs-title">reserved</span> 1048576<span class="hljs-title">K</span></span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure><ul><li><code>DefNew: 2025K-&gt;624K(9216K)</code>:表示GC发生在新生代，9216k是伊甸园的总大小。</li><li><code>2025K-&gt;624K(19456K)</code>:整个堆，GC前和GC后的内存占用，19456K是堆的总大小。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_1</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_7MB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_512KB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_512KB]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [DefNew: 1835K-&gt;621K(9216K), <span class="hljs-number">0.0014672</span> secs] 1835K-&gt;621K(19456K), <span class="hljs-number">0.0015383</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) [DefNew: 8628K-&gt;525K(9216K), <span class="hljs-number">0.0070760</span> secs] 8628K-&gt;8292K(19456K), <span class="hljs-number">0.0071476</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>Heap<br> def <span class="hljs-keyword">new</span> generation   total 9216K, used 1203K [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ff600000</span>)<br>  eden space 8192K,   <span class="hljs-number">8</span>% used [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000feca9730</span>, <span class="hljs-number">0x00000000ff400000</span>)<br>  from space 1024K,  <span class="hljs-number">51</span>% used [<span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff4836b0</span>, <span class="hljs-number">0x00000000ff500000</span>)<br>  to   space 1024K,   <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff500000</span>, <span class="hljs-number">0x00000000ff500000</span>, <span class="hljs-number">0x00000000ff600000</span>)<br> tenured generation   total 10240K, used 7767K [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>   the space 10240K,  <span class="hljs-number">75</span>% used [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ffd95ca8</span>, <span class="hljs-number">0x00000000ffd95e00</span>, <span class="hljs-number">0x0000000100000000</span>)<br> Metaspace       used 3288K, capacity 4496K, committed 4864K, reserved 1056768K<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">space</span>    <span class="hljs-title">used</span> 357<span class="hljs-title">K</span>, <span class="hljs-title">capacity</span> 388<span class="hljs-title">K</span>, <span class="hljs-title">committed</span> 512<span class="hljs-title">K</span>, <span class="hljs-title">reserved</span> 1048576<span class="hljs-title">K</span></span><br></code></pre></td></tr></table></figure><ul><li>发生了两次GC，7MB的数组在新生代放不下了，内存紧张，导致提前晋升到老年代。</li></ul><p><strong>大对象直接晋升到老年代</strong></p><p>大对象，不发生GC，直接晋升。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_1</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_8MB]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Heap<br> def <span class="hljs-keyword">new</span> generation   total 9216K, used 2190K [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ff600000</span>)<br>  eden space 8192K,  <span class="hljs-number">26</span>% used [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000fee23870</span>, <span class="hljs-number">0x00000000ff400000</span>)<br>  from space 1024K,   <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff500000</span>)<br>  to   space 1024K,   <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff500000</span>, <span class="hljs-number">0x00000000ff500000</span>, <span class="hljs-number">0x00000000ff600000</span>)<br> tenured generation   total 10240K, used 8192K [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>   the space 10240K,  <span class="hljs-number">80</span>% used [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ffe00010</span>, <span class="hljs-number">0x00000000ffe00200</span>, <span class="hljs-number">0x0000000100000000</span>)<br> Metaspace       used 3288K, capacity 4496K, committed 4864K, reserved 1056768K<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">space</span>    <span class="hljs-title">used</span> 357<span class="hljs-title">K</span>, <span class="hljs-title">capacity</span> 388<span class="hljs-title">K</span>, <span class="hljs-title">committed</span> 512<span class="hljs-title">K</span>, <span class="hljs-title">reserved</span> 1048576<span class="hljs-title">K</span></span><br></code></pre></td></tr></table></figure><ul><li>大对象在伊甸园区域容纳不下，不会发生垃圾回收，如果老年代内存空间足够，直接晋升到老年代</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_1</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_8MB]);<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_8MB]);<br>        &#125;).start();<br><br>        System.out.println(<span class="hljs-string">&quot;main thread...&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">1000L</span>);<br>            <span class="hljs-keyword">int</span> j = i;<br>            System.out.println(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">main thread...<br>[GC (Allocation Failure) [DefNew: 4093K-&gt;865K(9216K), <span class="hljs-number">0.0032911</span> secs][Tenured: 8192K-&gt;9055K(10240K), <span class="hljs-number">0.0043370</span> secs] 12285K-&gt;9055K(19456K), [Metaspace: 4197K-&gt;4197K(1056768K)], <span class="hljs-number">0.0077406</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Allocation Failure)</span> [Tenured: 9055K-&gt;8999<span class="hljs-title">K</span><span class="hljs-params">(10240K)</span>, 0.0029429 secs] 9055K-&gt;8999<span class="hljs-title">K</span><span class="hljs-params">(19456K)</span>, [Metaspace: 4197K-&gt;4197<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0030113 secs] [Times: user</span>=<span class="hljs-number">0.02</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>Exception in thread <span class="hljs-string">&quot;Thread-0&quot;</span> java.lang.OutOfMemoryError: Java heap space<br>at com.sunk.jvm.t2.Demo2_1.lambda$main$<span class="hljs-number">0</span>(Demo2_1.java:<span class="hljs-number">20</span>)<br>at com.sunk.jvm.t2.Demo2_1$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">2074407503.</span>run(Unknown Source)<br>at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br>Heap<br> def <span class="hljs-keyword">new</span> generation   total 9216K, used 1539K [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ff600000</span>)<br>  eden space 8192K,  <span class="hljs-number">18</span>% used [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000fed80c48</span>, <span class="hljs-number">0x00000000ff400000</span>)<br>  from space 1024K,   <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff500000</span>, <span class="hljs-number">0x00000000ff500000</span>, <span class="hljs-number">0x00000000ff600000</span>)<br>  to   space 1024K,   <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff500000</span>)<br> tenured generation   total 10240K, used 8999K [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>   the space 10240K,  <span class="hljs-number">87</span>% used [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ffec9d30</span>, <span class="hljs-number">0x00000000ffec9e00</span>, <span class="hljs-number">0x0000000100000000</span>)<br> Metaspace       used 4728K, capacity 4804K, committed 4992K, reserved 1056768K<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">space</span>    <span class="hljs-title">used</span> 526<span class="hljs-title">K</span>, <span class="hljs-title">capacity</span> 560<span class="hljs-title">K</span>, <span class="hljs-title">committed</span> 640<span class="hljs-title">K</span>, <span class="hljs-title">reserved</span> 1048576<span class="hljs-title">K</span></span><br></code></pre></td></tr></table></figure><ul><li>有某个线程发生了内存溢出的错误，并不会影响主线程的运行！</li></ul><h2 id="2-4-垃圾回收器"><a href="#2-4-垃圾回收器" class="headerlink" title="2.4 垃圾回收器"></a>2.4 垃圾回收器</h2><p>垃圾回收器类型：</p><ol><li>串行<ul><li>单线程，GC发生时会把其他的线程暂停</li><li>适用场景：堆内存较小，CPU个数少，适合个人电脑</li></ul></li><li>吞吐量优先<ul><li>多线程</li><li>适用场景：堆内存较大，多核CPU，服务器</li><li>让单位时间内，STW的时间变短(最短) 0.2 0.2 = 0.4</li></ul></li><li>响应时间优先<ul><li>多线程</li><li>适用场景：堆内存较大，多核CPU，服务器</li><li>GC发生时，尽可能让STW的单次时间变短(最短) 0.1 0.1 0.1 0.1 0.1 = 0.5</li></ul></li></ol><h3 id="2-4-1-串行垃圾回收器"><a href="#2-4-1-串行垃圾回收器" class="headerlink" title="2.4.1 串行垃圾回收器"></a>2.4.1 串行垃圾回收器</h3><p><code>-XX:+UseSerialGC = Serial + SerialOld</code>，Serial工作在新生代，采用的回收算法是复制算法；SerialOld工作在老年代，采用的回收算法是标记-整理算法。</p><p><img src="http://image.cryptomartin.top/img/image-20220130232036389.png" alt="image-20220130232036389"></p><p>现在有多核CPU，刚开始线程都在运行，过一会儿发现堆内存不够了，发生了GC。触发垃圾回收，会有一个<code>安全点</code>让这些运行的线程都停下来。为什么要让线程停下来？因为垃圾回收的过程中，可能对象的地址发生改变，为了安全地使用对象的地址，需要让所有的线程在安全点暂停下来。这时，进行垃圾回收的工作，就不会有其他的线程来干扰垃圾回收线程。</p><p>注意，Serial和SerialOld都是单线程的垃圾回收器，只有一个垃圾回收线程在运行，其他的线程都阻塞，等待垃圾回收线程的结束。当垃圾回收线程的结束，线程都恢复运行。</p><h3 id="2-4-2-吞吐量优先垃圾回收器"><a href="#2-4-2-吞吐量优先垃圾回收器" class="headerlink" title="2.4.2 吞吐量优先垃圾回收器"></a>2.4.2 吞吐量优先垃圾回收器</h3><p><code>-XX:+UseParallelGC</code> ~ <code>-XX:+UseParallelOldGC </code></p><p><code>-XX:+UseAdaptiveSizePolicy</code></p><p><code>-XX:GCTimeRatio=ratio</code> 默认值99 1/(1+99);一般设为19 1/(1+19)=0.05</p><p><code>-XX:MaxGCPauseMillis=ms</code> 默认值200ms</p><p><code>-XX:ParallelGCThreads=n</code></p><p><img src="http://image.cryptomartin.top/img/image-20220131135952292.png" alt="image-20220131135952292"></p><h3 id="2-4-3-响应时间优先"><a href="#2-4-3-响应时间优先" class="headerlink" title="2.4.3 响应时间优先"></a>2.4.3 响应时间优先</h3><p><code>-XX:+UseConcMarkSweepGC</code> ~ <code>-XX:+UseParNewGC</code> ~ <code>SerialOld</code></p><p><code>-XX:ParallelGCThreads=n</code> ~ <code>-XX:ConcGCThreads=threads</code> </p><p><code>-XX:CMSInitiatingOccupancyFraction=percent</code> 何时执行CMS？</p><p><code>-XX:+CMSScavengeBeforeRemark</code> 在重新标记前对新生代进行垃圾回收</p><hr><p><code>-XX:+UseConcMarkSweepGC</code>:工作在老年代<br>concurrent:并发；paralle:并行<br>并发，指垃圾回收器工作的同时，其他的用户线程也能同时进行，即用户线程和垃圾回收线程并发执行；并发，多个垃圾回收器并行运行，不允许用户线程继续运行。</p><p><code>-XX:+UseParNewGC</code>:工作在新生代</p><p>当<code>CMS垃圾回收器</code>并发失败时，老年代的垃圾回收器退化为<code>SerialOld</code>,单线程垃圾回收器。</p><p><img src="http://image.cryptomartin.top/img/image-20220131140803550.png" alt="image-20220131140803550"></p><p>多个CPU并行执行，当老年代发生了内存不足，线程都到达安全点暂停下来了。这时，CMS垃圾回收器会做一个初始标记的工作，其他用户线程都暂停下来了，时间非常短；标记完成后，用户线程就可以运行起来了，与此同时，垃圾回收线程继续并发标记，把剩余的垃圾找出来；等并发标记完成，需要STW重新标记，为什么要重新标记？因为垃圾回收线程在并发标记时，用户线程也在同时工作，可能会改变一些对象的引用，会对垃圾回收形成干扰，所以在并发标记完成后，需要做重新标记的工作。等重新标记完成后，用户线程又可以重新运行，垃圾回收线程做并发清理然后运行。</p><p>只要在初始标记和重新标记时STW，其他阶段都是并发执行的。</p><p><code>-XX:ConcGCThreads=threads</code> 设置为并行线程数的1/4。</p><p>CMS垃圾回收器是基于标记清除算法，当老年代内存碎片过多导致内存不足时，发生并发失败，垃圾回收器退为<code>SerialOld</code>垃圾回收器。</p><h3 id="2-4-4-G1垃圾回收器-重点"><a href="#2-4-4-G1垃圾回收器-重点" class="headerlink" title="2.4.4 G1垃圾回收器(重点)"></a>2.4.4 G1垃圾回收器(重点)</h3><p>定义：Garbage First</p><ul><li>2004 论文发布</li><li>2009 JDK 6u14 体验</li><li>2012 JDK 7u4 官方支持</li><li>2017 JDK 9 默认</li></ul><p>适用场景</p><ul><li>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</li><li>超大堆内存，会将堆划分为多个大小相等的 Region</li><li>整体上是 <code>标记+整理</code> 算法，两个区域之间是 <code>复制</code> 算法</li></ul><p>相关 JVM 参数<br><code>-XX:+UseG1GC</code><br><code>-XX:G1HeapRegionSize=size</code><br><code>-XX:MaxGCPauseMillis=time</code></p><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/22591838">Java Hotspot G1 GC的一些关键技术</a></li><li><a href="https://www.bilibili.com/video/BV13J411g7A1">【java】垃圾收集器|g1收集器</a></li><li><a href="https://www.bilibili.com/video/BV1yE411Z7AP?p=72">满一航P72-P83</a></li></ul><h2 id="2-5-垃圾回收调优"><a href="#2-5-垃圾回收调优" class="headerlink" title="2.5 垃圾回收调优"></a>2.5 垃圾回收调优</h2><p>预备知识</p><ul><li>掌握 GC 相关的 VM 参数，会基本的空间调整</li><li>掌握相关工具</li><li>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</li></ul><h3 id="2-5-1-调优领域"><a href="#2-5-1-调优领域" class="headerlink" title="2.5.1 调优领域"></a>2.5.1 调优领域</h3><ul><li>内存</li><li>锁竞争</li><li>CPU占用</li><li>IO</li></ul><h3 id="2-5-2-确定目标"><a href="#2-5-2-确定目标" class="headerlink" title="2.5.2 确定目标"></a>2.5.2 确定目标</h3><ul><li>【低延迟】还是【高吞吐量】，选择合适的回收器</li><li>CMS，G1，ZGC</li><li>ParallelGC</li><li>Zing</li></ul><h3 id="2-5-3-最快的-GC"><a href="#2-5-3-最快的-GC" class="headerlink" title="2.5.3 最快的 GC"></a>2.5.3 最快的 GC</h3><p>答案是不发生 GC。</p><p>查看 FullGC 前后的内存占用，考虑下面几个问题：</p><ul><li>数据是不是太多？<ul><li>resultSet = statement.executeQuery(“select * from 大表 limit n”)</li></ul></li><li>数据表示是否太臃肿？<ul><li>对象图 保存不必要的数据内容</li><li>对象大小  16 Integer 24 int 4</li></ul></li><li>是否存在内存泄漏？<ul><li>static Map map =</li><li>软</li><li>弱</li><li>第三方缓存实现</li></ul></li></ul><h3 id="2-5-4-新生代调优"><a href="#2-5-4-新生代调优" class="headerlink" title="2.5.4 新生代调优"></a>2.5.4 新生代调优</h3><p>新生代的特点：</p><ul><li>所有的 new 操作的内存分配非常廉价<ul><li>TLAB thread-local allocation buffer</li></ul></li><li>死亡对象的回收代价是零</li><li>大部分对象用过即死</li><li>Minor GC 的时间远远低于 Full GC</li></ul><p>越大越好吗？</p><p>-Xmn<br>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC isperformed in this region more often than in other regions. If the size for the young generation istoo small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</p><p>设置多少合适？</p><ul><li>新生代能容纳所有【并发量 * (请求-响应)】的数据</li><li>幸存区大到能保留【当前活跃对象+需要晋升对象】</li><li>晋升阈值配置得当，让长时间存活对象尽快晋升<ul><li><code>-XX:MaxTenuringThreshold=threshold</code></li><li><code>-XX:+PrintTenuringDistribution </code></li></ul></li></ul><h3 id="2-5-5-老年代调优"><a href="#2-5-5-老年代调优" class="headerlink" title="2.5.5 老年代调优"></a>2.5.5 老年代调优</h3><p>以 CMS 为例</p><ul><li>CMS 的老年代内存越大越好</li><li>先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代</li><li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3<ul><li><code>-XX:CMSInitiatingOccupancyFraction=percent</code>:控制老年代占总内存的多少时，开始垃圾回收。</li></ul></li></ul><h3 id="2-5-6-案例"><a href="#2-5-6-案例" class="headerlink" title="2.5.6 案例"></a>2.5.6 案例</h3><ul><li>案例1 Full GC 和 Minor GC频繁<ul><li>增大新生代内存，增大幸存区空间和晋升阈值，让生命周期较短的对象尽可能留在新生代。</li></ul></li><li>案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）<ul><li>查看GC日志，重新标记耗时较多，使用<code>-XX:+CMSScavengeBeforeRemark</code> 在重新标记前对新生代进行垃圾回收</li></ul></li><li>案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）<ul><li>JDK1.7的永久代发生堆的Full GC;JDK1.8改成元空间</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>JVM学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第八章 共享模型之工具</title>
    <link href="/2022/02/02/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/02/02/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="第八章-共享模型之工具"><a href="#第八章-共享模型之工具" class="headerlink" title="第八章 共享模型之工具"></a>第八章 共享模型之工具</h1><p><strong>本章内容</strong></p><ul><li>线程池</li><li>J.U.C</li><li>disruptor</li><li>guava</li></ul><h2 id="8-1-自定义线程池"><a href="#8-1-自定义线程池" class="headerlink" title="8.1  自定义线程池"></a>8.1  自定义线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sunk.test;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.ArrayDeque;<br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> skunk</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TestPool&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPool</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ThreadPool threadPool = <span class="hljs-keyword">new</span> ThreadPool(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, (queue, task) -&gt; &#123;<br>            <span class="hljs-comment">//1.死等</span><br>            <span class="hljs-comment">//queue.put(task);</span><br>            <span class="hljs-comment">//2.带超时</span><br>            <span class="hljs-comment">//queue.offer(task, 1500, TimeUnit.MILLISECONDS);</span><br>            <span class="hljs-comment">//3.让调用者放弃任务执行</span><br>            <span class="hljs-comment">//log.debug(&quot;放弃&#123;&#125;&quot;, task);</span><br>            <span class="hljs-comment">//4.让调用者抛出异常</span><br>            <span class="hljs-comment">//throw new RuntimeException(&quot;任务执行失败&quot; + task);</span><br>            <span class="hljs-comment">//5.让调用者自己执行任务</span><br>            task.run();<br>        &#125;);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> j = i;<span class="hljs-comment">//i是变化的，赋值给局部变量</span><br>            threadPool.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000L</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, j);<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RejectPolicy</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reject</span><span class="hljs-params">(BlockQueue&lt;T&gt; queue, T task)</span></span>;<br>&#125;<br><br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.ThreadPool&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;<br>    <span class="hljs-comment">//任务队列</span><br>    <span class="hljs-keyword">private</span> BlockQueue&lt;Runnable&gt; taskQueue;<br><br>    <span class="hljs-comment">//线程集合</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;worker&gt; workers = <span class="hljs-keyword">new</span> HashSet();<br><br>    <span class="hljs-comment">//核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> coreSize;<br><br>    <span class="hljs-comment">//超时时间设置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> timeout;<br>    <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br><br>    <span class="hljs-comment">//拒绝策略</span><br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> coreSize, <span class="hljs-keyword">int</span> queueCapacity, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.taskQueue = <span class="hljs-keyword">new</span> BlockQueue&lt;&gt;(queueCapacity);<br>        <span class="hljs-keyword">this</span>.coreSize = coreSize;<br>        <span class="hljs-keyword">this</span>.timeout = timeout;<br>        <span class="hljs-keyword">this</span>.timeUnit = timeUnit;<br>        <span class="hljs-keyword">this</span>.rejectPolicy = rejectPolicy;<br>    &#125;<br><br>    <span class="hljs-comment">//分配任务，执行任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        当任务数没有超过coreSize时，直接交给worker对象执行；</span><br><span class="hljs-comment">        当任务数超过coreSize时，加入任务队列</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">synchronized</span> (workers) &#123;<span class="hljs-comment">//为什么要锁住workers?workers是共享资源，HashSet线程不安全。</span><br>            <span class="hljs-keyword">if</span> (workers.size() &lt; coreSize) &#123;<br>                worker worker = <span class="hljs-keyword">new</span> worker(task);<br>                log.debug(<span class="hljs-string">&quot;新增 worker&#123;&#125;,任务&#123;&#125;&quot;</span>, worker, task);<br>                workers.add(worker);<br>                worker.start();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//taskQueue.put(task);</span><br>                <span class="hljs-comment">//拒绝策略</span><br>                taskQueue.tryPut(rejectPolicy, task);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<span class="hljs-comment">//worker是一个线程</span><br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">worker</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            执行任务</span><br><span class="hljs-comment">                1.当task不为空，执行任务；</span><br><span class="hljs-comment">                2.当task执行完毕，再接着从任务队列获取任务并执行</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-comment">//while (task != null || (task = taskQueue.get()) != null) &#123;</span><br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;正在执行任务...&#123;&#125;&quot;</span>, task);<br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-keyword">null</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>                log.debug(<span class="hljs-string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="hljs-keyword">this</span>);<br>                workers.remove(<span class="hljs-keyword">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Blocking&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//1.任务队列</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br><br>    <span class="hljs-comment">//2.锁</span><br>    <span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-comment">//3.生产者条件变量</span><br>    <span class="hljs-keyword">private</span> Condition fullWaitSet = lock.newCondition();<br><br>    <span class="hljs-comment">//4.消费者条件变量</span><br>    <span class="hljs-keyword">private</span> Condition emptyWaitSet = lock.newCondition();<br><br>    <span class="hljs-comment">//5.队列容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br><br><br>    <span class="hljs-comment">//构造方法</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BlockQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">//消费者获取任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            T t = queue.removeFirst();<br>            fullWaitSet.signalAll();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//消费者带超时的等待</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">long</span> nanos = timeUnit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                    &#125;<br>                    nanos = emptyWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            T t = queue.removeFirst();<br>            fullWaitSet.signalAll();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//生产者产生任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T task)</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务队列&#123;&#125;...&quot;</span>, task);<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务队列&#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signalAll();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//生产者带超时时间的阻塞添加任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(T task, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">long</span> nanos = timeUnit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务队列&#123;&#125;...&quot;</span>, task);<br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                    nanos = fullWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务队列&#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signalAll();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//获取任务队列大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//判断队列是否已满</span><br>            <span class="hljs-keyword">if</span> (queue.size() == capacity) &#123;<br>                rejectPolicy.reject(<span class="hljs-keyword">this</span>, task);<span class="hljs-comment">//权力下方</span><br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//有空闲</span><br>                log.debug(<span class="hljs-string">&quot;加入任务队列&#123;&#125;&quot;</span>, task);<br>                queue.addLast(task);<br>                emptyWaitSet.signalAll();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-2-ThreadPoolExecutor"><a href="#8-2-ThreadPoolExecutor" class="headerlink" title="8.2 ThreadPoolExecutor"></a>8.2 ThreadPoolExecutor</h2><p><img src="http://image.cryptomartin.top/img/image-20220117155441091.png" alt="image-20220117155441091"></p><h3 id="8-2-1-线程池状态"><a href="#8-2-1-线程池状态" class="headerlink" title="8.2.1 线程池状态"></a>8.2.1 线程池状态</h3><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p><p><img src="http://image.cryptomartin.top/img/image-20220117155529699.png" alt="image-20220117155529699"></p><p>从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</p><blockquote><p>高3位，111– 第一个1表示负数</p></blockquote><p>这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// c 为旧值， ctlOf 返回结果为新值</span><br>ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));<br><br><span class="hljs-comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-2-构造方法"><a href="#8-2-2-构造方法" class="headerlink" title="8.2.2 构造方法"></a>8.2.2 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-params"><span class="hljs-function">                              TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-params"><span class="hljs-function">                              RejectedExecutionHandler handler)</span></span><br></code></pre></td></tr></table></figure><ul><li>corePoolSize 核心线程数目 (最多保留的线程数)</li><li>maximumPoolSize 最大线程数目</li><li>keepAliveTime 生存时间 - 针对救急线程</li><li>unit 时间单位 - 针对救急线程</li><li>workQueue 阻塞队列</li><li>threadFactory 线程工厂 - 可以为线程创建时起个好名字</li><li>handler 拒绝策略</li></ul><p>工作方式：</p><p><img src="http://image.cryptomartin.top/img/image-20220117162957144.png" alt="image-20220117162957144"></p><ul><li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li><li>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。</li><li>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</li><li>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它著名框架也提供了实现<ul><li>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li><li>CallerRunsPolicy 让调用者运行任务</li><li>DiscardPolicy 放弃本次任务</li><li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li><li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题</li><li>Netty 的实现，是创建一个新线程来执行任务</li><li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li><li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ul></li><li>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由keepAliveTime 和 unit 来控制。</li></ul><p><img src="http://image.cryptomartin.top/img/image-20220117163306482.png" alt="image-20220117163306482"></p><h3 id="8-2-3-newFixedThreadPool"><a href="#8-2-3-newFixedThreadPool" class="headerlink" title="8.2.3  newFixedThreadPool"></a>8.2.3  newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                                      threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>特点:</p><ul><li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li><li>阻塞队列是无界的，可以放任意数量的任务 – LinkedBlockingQueue</li></ul><blockquote><p><strong>评价</strong> 适用于任务量已知，相对耗时的任务</p></blockquote><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestThreadPoolExecutors&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThreadPoolExecutors</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger poolNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;myPool-&quot;</span> + poolNumber.getAndIncrement());<br>            &#125;<br>        &#125;);<br><br>        pool.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;);<br><br>        pool.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>        &#125;);<br><br>        pool.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;3&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-4-newCachedThreadPool"><a href="#8-2-4-newCachedThreadPool" class="headerlink" title="8.2.4  newCachedThreadPool"></a>8.2.4  newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br> <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着<ul><li>全部都是救急线程（60s 后可以回收）</li><li>救急线程可以无限创建</li></ul></li><li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestSynchronousQueue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSynchronousQueue</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SynchronousQueue&lt;Integer&gt; integers = <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;putting &#123;&#125; &quot;</span>, <span class="hljs-number">1</span>);<br>                integers.put(<span class="hljs-number">1</span>);<br>                log.debug(<span class="hljs-string">&quot;&#123;&#125; putted...&quot;</span>, <span class="hljs-number">1</span>);<br>                log.debug(<span class="hljs-string">&quot;putting...&#123;&#125; &quot;</span>, <span class="hljs-number">2</span>);<br>                integers.put(<span class="hljs-number">2</span>);<br>                log.debug(<span class="hljs-string">&quot;&#123;&#125; putted...&quot;</span>, <span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;taking &#123;&#125;&quot;</span>, <span class="hljs-number">1</span>);<br>                integers.take();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>        <br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;taking &#123;&#125;&quot;</span>, <span class="hljs-number">2</span>);<br>                integers.take();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t3&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">23</span>:<span class="hljs-number">24</span>:09 [t1] c.TestSynchronousQueue - putting <span class="hljs-number">1</span> <br><span class="hljs-number">23</span>:<span class="hljs-number">24</span>:<span class="hljs-number">10</span> [t2] c.TestSynchronousQueue - taking <span class="hljs-number">1</span><br><span class="hljs-number">23</span>:<span class="hljs-number">24</span>:<span class="hljs-number">10</span> [t1] c.TestSynchronousQueue - <span class="hljs-number">1</span> putted...<br><span class="hljs-number">23</span>:<span class="hljs-number">24</span>:<span class="hljs-number">10</span> [t1] c.TestSynchronousQueue - putting..<span class="hljs-number">.2</span> <br><span class="hljs-number">23</span>:<span class="hljs-number">24</span>:<span class="hljs-number">11</span> [t3] c.TestSynchronousQueue - taking <span class="hljs-number">2</span><br><span class="hljs-number">23</span>:<span class="hljs-number">24</span>:<span class="hljs-number">11</span> [t1] c.TestSynchronousQueue - <span class="hljs-number">2</span> putted...<br></code></pre></td></tr></table></figure><blockquote><p><strong>评价</strong> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况</p></blockquote><h3 id="8-2-5-newSingleThreadExecuto"><a href="#8-2-5-newSingleThreadExecuto" class="headerlink" title="8.2.5 newSingleThreadExecuto"></a>8.2.5 newSingleThreadExecuto</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br> (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br> <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br> <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><p>使用场景：</p><p>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p><p>区别：</p><ul><li>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作。</li><li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改<ul><li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</li></ul></li><li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改<ul><li>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li></ul></li></ul><h3 id="8-2-6-提交任务"><a href="#8-2-6-提交任务" class="headerlink" title="8.2.6 提交任务"></a>8.2.6 提交任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行任务</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;<br><br><span class="hljs-comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span><br>&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，带超时时间</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-keyword">long</span> timeout, TimeUnit unit) <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="hljs-function"> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span><br>&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span><span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<br></code></pre></td></tr></table></figure><p><code>submit</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestSubmit&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSubmit</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>        Future&lt;String&gt; future = threadPool.submit(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>        &#125;);<br><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, future.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>invokeAll</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>List&lt;Future&lt;Object&gt;&gt; futures = threadPool.invokeAll(Arrays.asList(<br>                () -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>Thread.sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;<br>&#125;<br>,<br>                () -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>Thread.sleep(<span class="hljs-number">500</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;<br>&#125;<br>,<br>                () -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;3&quot;</span>);<br>Thread.sleep(<span class="hljs-number">2000</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;3&quot;</span>;<br>&#125;<br>));<br>futures.forEach(f -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, f.get());<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>invokeAny</code>返回最先得到的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>    String result = threadPool.invokeAny(Arrays.asList(<br>            () -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;begin 1&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                log.debug(<span class="hljs-string">&quot;end 1&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;<br>            &#125;,<br>            () -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;begin 2&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">500</span>);<br>                log.debug(<span class="hljs-string">&quot;end 2&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;<br>            &#125;,<br>            () -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;begin 3&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                log.debug(<span class="hljs-string">&quot;end 3&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;3&quot;</span>;<br>            &#125;<br>    ));<br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-7-关闭线程池"><a href="#8-2-7-关闭线程池" class="headerlink" title="8.2.7 关闭线程池"></a>8.2.7 关闭线程池</h3><p><strong>shutdown</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">线程池状态变为 SHUTDOWN</span><br><span class="hljs-comment">- 不会接收新任务</span><br><span class="hljs-comment">- 但已提交任务会执行完</span><br><span class="hljs-comment">- 此方法不会阻塞调用线程的执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>checkShutdownAccess();<br><span class="hljs-comment">// 修改线程池状态</span><br>advanceRunState(SHUTDOWN);<br><span class="hljs-comment">// 仅会打断空闲线程</span><br>interruptIdleWorkers();<br>onShutdown();<br><span class="hljs-comment">// 扩展点 ScheduledThreadPoolExecutor</span><br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>mainLock.unlock();<br>&#125;<br><span class="hljs-comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span><br>tryTerminate();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>shutdownNow</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">线程池状态变为 STOP</span><br><span class="hljs-comment">- 不会接收新任务</span><br><span class="hljs-comment">- 会将队列中的任务返回</span><br><span class="hljs-comment">- 并用 interrupt 的方式中断正在执行的任务</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;<br>List&lt;Runnable&gt; tasks;<br><span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>checkShutdownAccess();<br><span class="hljs-comment">// 修改线程池状态</span><br>advanceRunState(STOP);<br><span class="hljs-comment">// 打断所有线程</span><br>interruptWorkers();<br><span class="hljs-comment">// 获取队列中剩余任务</span><br>tasks = drainQueue();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>mainLock.unlock();<br>&#125;<br><span class="hljs-comment">// 尝试终结</span><br>tryTerminate();<br><span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其他方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 线程池状态是否是 TERMINATED</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTerminated</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitTermination</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br></code></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestShutDown&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestShutDown</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>        Future&lt;Integer&gt; result1 = pool.submit(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task 1 running...&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            log.debug(<span class="hljs-string">&quot;task 1 finish...&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;);<br><br>        Future&lt;Integer&gt; result2 = pool.submit(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task 2 running...&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            log.debug(<span class="hljs-string">&quot;task 2 finish...&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;);<br><br>        Future&lt;Integer&gt; result3 = pool.submit(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task 3 running...&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            log.debug(<span class="hljs-string">&quot;task 3 finish...&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        &#125;);<br><br>        pool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>shutdown</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">55</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">1</span> running...<br><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">55</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">2</span> running...<br><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">56</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">2</span> finish...<br><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">56</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">1</span> finish...<br><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">56</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">3</span> running...<br><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">57</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">3</span> finish...<br></code></pre></td></tr></table></figure><blockquote><p>3个任务都执行完成</p></blockquote><p>调用<code>awaitTermination</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">log.debug(<span class="hljs-string">&quot;shutdown&quot;</span>);<br>pool.shutdown();<br>pool.awaitTermination(<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>log.debug(<span class="hljs-string">&quot;other...&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">16</span>:<span class="hljs-number">32</span> [main] c.TestShutDown - shutdown<br><span class="hljs-number">11</span>:<span class="hljs-number">16</span>:<span class="hljs-number">32</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">1</span> running...<br><span class="hljs-number">11</span>:<span class="hljs-number">16</span>:<span class="hljs-number">32</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">2</span> running...<br><span class="hljs-number">11</span>:<span class="hljs-number">16</span>:<span class="hljs-number">33</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">1</span> finish...<br><span class="hljs-number">11</span>:<span class="hljs-number">16</span>:<span class="hljs-number">33</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">2</span> finish...<br><span class="hljs-number">11</span>:<span class="hljs-number">16</span>:<span class="hljs-number">33</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">3</span> running...<br><span class="hljs-number">11</span>:<span class="hljs-number">16</span>:<span class="hljs-number">34</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">3</span> finish...<br><span class="hljs-number">11</span>:<span class="hljs-number">16</span>:<span class="hljs-number">34</span> [main] c.TestShutDown - other...<br></code></pre></td></tr></table></figure><blockquote><p>调用 shutdown 后,调用awaitTermination进行等待；如果线程都执行完成，则无需等待。</p></blockquote><p>调用<code>shutdownNow()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">        log.debug(<span class="hljs-string">&quot;shutdown&quot;</span>);<br><span class="hljs-comment">//        pool.shutdown();</span><br><span class="hljs-comment">//        pool.awaitTermination(3, TimeUnit.SECONDS);</span><br>        List&lt;Runnable&gt; burnables = pool.shutdownNow();<br>        log.debug(<span class="hljs-string">&quot;other...&#123;&#125;&quot;</span>,burnables);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">12</span> [main] c.TestShutDown - shutdown<br><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">12</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">2</span> running...<br><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">12</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">1</span> running...<br><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">12</span> [main] c.TestShutDown - other...[java.util.concurrent.FutureTask@2b80d80f]<br></code></pre></td></tr></table></figure><blockquote><p>正在执行的任务，还是任务队列中的任务都进行打断。返回一个任务list</p></blockquote><h2 id="8-3-【模式】异步模式之工作线程"><a href="#8-3-【模式】异步模式之工作线程" class="headerlink" title="8.3 【模式】异步模式之工作线程"></a>8.3 【模式】异步模式之工作线程</h2><h3 id="8-3-1-定义"><a href="#8-3-1-定义" class="headerlink" title="8.3.1 定义"></a>8.3.1 定义</h3><p>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式。</p><p>例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）</p><p>注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率<br>例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工</p><h3 id="8-3-2-饥饿"><a href="#8-3-2-饥饿" class="headerlink" title="8.3.2 饥饿"></a>8.3.2 饥饿</h3><p>固定大小线程池会有饥饿现象</p><ul><li>两个工人是同一个线程池中的两个线程</li><li>他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作<ul><li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待</li><li>后厨做菜：没啥说的，做就是了</li></ul></li><li>比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好</li><li>但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestStarvation&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestStarvation</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="hljs-string">&quot;地三鲜&quot;</span>, <span class="hljs-string">&quot;宫保鸡丁&quot;</span>, <span class="hljs-string">&quot;辣子鸡丁&quot;</span>, <span class="hljs-string">&quot;烤鸡翅&quot;</span>);<br>    <span class="hljs-keyword">static</span> Random RANDOM = <span class="hljs-keyword">new</span> Random();<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">cooking</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService waiterPool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>        ExecutorService cookPool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><br>        waiterPool.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);<br>            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);<br>                <span class="hljs-keyword">return</span> cooking();<br>            &#125;);<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        waiterPool.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);<br>            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);<br>                <span class="hljs-keyword">return</span> cooking();<br>            &#125;);<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">32</span>:<span class="hljs-number">12</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestStarvation - 处理点餐...<br><span class="hljs-number">18</span>:<span class="hljs-number">32</span>:<span class="hljs-number">12</span> [pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span>] c.TestStarvation - 做菜<br><span class="hljs-number">18</span>:<span class="hljs-number">32</span>:<span class="hljs-number">12</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestStarvation - 上菜: 辣子鸡丁<br><span class="hljs-number">18</span>:<span class="hljs-number">32</span>:<span class="hljs-number">12</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestStarvation - 处理点餐...<br><span class="hljs-number">18</span>:<span class="hljs-number">32</span>:<span class="hljs-number">12</span> [pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span>] c.TestStarvation - 做菜<br><span class="hljs-number">18</span>:<span class="hljs-number">32</span>:<span class="hljs-number">12</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestStarvation - 上菜: 地三鲜<br></code></pre></td></tr></table></figure><h3 id="8-3-3-创建多少线程合适"><a href="#8-3-3-创建多少线程合适" class="headerlink" title="8.3.3 创建多少线程合适"></a>8.3.3 创建多少线程合适</h3><ul><li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li><li>过大会导致更多的线程上下文切换，占用更多内存</li></ul><p><strong>CPU 密集型运算</strong></p><p>通常采用 <code>cpu 核数 + 1</code> 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p><p><strong>I/O 密集型运算</strong></p><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程<br>RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</p><p>经验公式如下:<br><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code></p><p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式</p><p><code>4 * 100% * 100% / 50% = 8</code></p><p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式</p><p><code>4 * 100% * 100% / 10% = 40</code></p><h2 id="8-4-任务调度线程池"><a href="#8-4-任务调度线程池" class="headerlink" title="8.4 任务调度线程池"></a>8.4 任务调度线程池</h2><h3 id="8-4-1newScheduledThreadPool"><a href="#8-4-1newScheduledThreadPool" class="headerlink" title="8.4.1newScheduledThreadPool"></a>8.4.1newScheduledThreadPool</h3><p>在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Timer timer = <span class="hljs-keyword">new</span> Timer();<br>TimerTask task1 = <span class="hljs-keyword">new</span> TimerTask() &#123;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>log.debug(<span class="hljs-string">&quot;task 1&quot;</span>);<br>sleep(<span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br>;<br>TimerTask task2 = <span class="hljs-keyword">new</span> TimerTask() &#123;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>log.debug(<span class="hljs-string">&quot;task 2&quot;</span>);<br>&#125;<br>&#125;<br>;<br><span class="hljs-comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span><br><span class="hljs-comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span><br>timer.schedule(task1, <span class="hljs-number">1000</span>);<br>timer.schedule(task2, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 ScheduledExecutorService 改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br>pool.schedule(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>&#125;, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br>pool.schedule(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;task2&quot;</span>);<br>&#125;, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>scheduleAtFixedRate 例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>pool.scheduleAtFixedRate(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>scheduleWithFixedDelay 例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>pool.scheduleWithFixedDelay(()-&gt; &#123;<br> log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br> sleep(<span class="hljs-number">2</span>);<br>&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 &lt;-&gt; 延时 &lt;-&gt; 下一个任务开始 所以间隔都是 3s</p><blockquote><p><strong>评价</strong> 整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。用来执行延迟或反复执行的任务</p></blockquote><h3 id="8-4-2-正确处理执行任务异常"><a href="#8-4-2-正确处理执行任务异常" class="headerlink" title="8.4.2 正确处理执行任务异常"></a>8.4.2 正确处理执行任务异常</h3><p><strong>方法1：主动捉异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>pool.submit(() -&gt; &#123;<br> <span class="hljs-keyword">try</span> &#123;<br> log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br> &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br> log.error(<span class="hljs-string">&quot;error:&quot;</span>, e);<br> &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>方法2：被动处理-使用 Future</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;<br> log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;);<br>log.debug(<span class="hljs-string">&quot;result:&#123;&#125;&quot;</span>, f.get());<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">58.208</span> c.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - task1 <br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.concurrent.ExecutionException: <br>java.lang.ArithmeticException: / by zero <br> at java.util.concurrent.FutureTask.report(FutureTask.java:<span class="hljs-number">122</span>) <br> at java.util.concurrent.FutureTask.get(FutureTask.java:<span class="hljs-number">192</span>) <br> at cn.itcast.n8.TestTimer.main(TestTimer.java:<span class="hljs-number">31</span>) <br>Caused by: java.lang.ArithmeticException: / by zero <br> at cn.itcast.n8.TestTimer.lambda$main$<span class="hljs-number">0</span>(TestTimer.java:<span class="hljs-number">28</span>) <br> at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="hljs-number">266</span>) <br> at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="hljs-number">1149</span>) <br> at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="hljs-number">624</span>) <br> at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br></code></pre></td></tr></table></figure><h3 id="8-4-3-任务调度线程池的应用-定时任务"><a href="#8-4-3-任务调度线程池的应用-定时任务" class="headerlink" title="8.4.3 任务调度线程池的应用-定时任务"></a>8.4.3 任务调度线程池的应用-定时任务</h3><p>如何让每周四 18:00:00 定时执行任务？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得当前时间</span><br>LocalDateTime now = LocalDateTime.now();<br><span class="hljs-comment">// 获取本周四 18:00:00.000</span><br>LocalDateTime thursday = now.with(DayOfWeek.THURSDAY).withHour(<span class="hljs-number">18</span>).withMinute(<span class="hljs-number">0</span>).withSecond(<span class="hljs-number">0</span>).withNano(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 如果当前时间已经超过 本周四 18:00:00.000， 那么找下周四 18:00:00.000</span><br><span class="hljs-keyword">if</span>(now.compareTo(thursday) &gt;= <span class="hljs-number">0</span>) &#123;<br>thursday = thursday.plusWeeks(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 计算时间差，即延时执行时间</span><br><span class="hljs-keyword">long</span> initialDelay = Duration.between(now, thursday).toMillis();<br><span class="hljs-comment">// 计算间隔时间，即 1 周的毫秒值</span><br><span class="hljs-keyword">long</span> oneWeek = <span class="hljs-number">7</span> * <span class="hljs-number">24</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span>;<br>ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br>System.out.println(<span class="hljs-string">&quot;开始时间：&quot;</span> + <span class="hljs-keyword">new</span> Date());<br>executor.scheduleAtFixedRate(() -&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;执行时间：&quot;</span> + <span class="hljs-keyword">new</span> Date());<br>&#125;, initialDelay, oneWeek, TimeUnit.MILLISECONDS);<br></code></pre></td></tr></table></figure><h3 id="8-4-4-Tomcat线程池"><a href="#8-4-4-Tomcat线程池" class="headerlink" title="8.4.4 Tomcat线程池"></a>8.4.4 Tomcat线程池</h3><p>Tomcat 在哪里用到了线程池呢</p><p><img src="http://image.cryptomartin.top/img/image-20220123171328639.png" alt="image-20220123171328639"></p><ul><li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲</li><li>Acceptor 只负责【接收新的 socket 连接】</li><li>Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】</li><li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li><li>Executor 线程池中的工作线程最终负责【处理请求】</li></ul><p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p><ul><li>如果总线程数达到 maximumPoolSize<br>这时不会立刻抛 RejectedExecutionException 异常<br>而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</li></ul><p>源码 tomcat-7.0.42</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;<br>submittedCount.incrementAndGet();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">super</span>.execute(command);<br>&#125;<span class="hljs-keyword">catch</span> (RejectedExecutionException rx) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">super</span>.getQueue() <span class="hljs-keyword">instanceof</span> TaskQueue) &#123;<br><span class="hljs-keyword">final</span> TaskQueue queue = (TaskQueue)<span class="hljs-keyword">super</span>.getQueue();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (!queue.force(command, timeout, unit)) &#123;<br>submittedCount.decrementAndGet();<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Queue capacity is full.&quot;</span>);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (InterruptedException x) &#123;<br>submittedCount.decrementAndGet();<br>Thread.interrupted();<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(x);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>submittedCount.decrementAndGet();<br><span class="hljs-keyword">throw</span> rx;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TaskQueue.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">force</span><span class="hljs-params">(Runnable o, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">if</span> ( parent.isShutdown() ) <br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<br> <span class="hljs-string">&quot;Executor not running, can&#x27;t force a command into the queue&quot;</span><br> );<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.offer(o,timeout,unit);<br><span class="hljs-comment">//forces the item onto the queue, to be used if the task </span><br>is rejected<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20220123171702762.png" alt="image-20220123171702762"></p><p>Executor配置</p><p><img src="http://image.cryptomartin.top/img/image-20220123171712868.png" alt="image-20220123171712868"></p><p><img src="http://image.cryptomartin.top/img/image-20220123171736491.png" alt="image-20220123171736491"></p><blockquote><p>Tomcat 达到最大核心线程数时，先创建救急线程。</p></blockquote><h2 id="8-5-Fork-Join"><a href="#8-5-Fork-Join" class="headerlink" title="8.5 Fork/Join"></a>8.5 Fork/Join</h2><h3 id="8-5-1-概念"><a href="#8-5-1-概念" class="headerlink" title="8.5.1 概念"></a>8.5.1 概念</h3><p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算</p><p>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解</p><p>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率</p><p>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</p><h3 id="8-5-2-使用"><a href="#8-5-2-使用" class="headerlink" title="8.5.2 使用"></a>8.5.2 使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestForkJoin&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestForkJoin</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ForkJoinPool pool = <span class="hljs-keyword">new</span> ForkJoinPool();<br>        System.out.println(pool.invoke(<span class="hljs-keyword">new</span> MyTask(<span class="hljs-number">5</span>)));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//计算1~n的累加</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.MyTask&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.n = n;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, n);<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br><br>        <span class="hljs-comment">// 将任务进行拆分(fork)</span><br>        MyTask t1 = <span class="hljs-keyword">new</span> MyTask(n - <span class="hljs-number">1</span>);<br>        t1.fork();<br>        log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);<br><br>        <span class="hljs-comment">// 合并(join)结果</span><br>        <span class="hljs-keyword">int</span> result = n + t1.join();<br>        log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">29</span>:<span class="hljs-number">15</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span>] c.MyTask - fork() <span class="hljs-number">4</span> + &#123;<span class="hljs-number">3</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">29</span>:<span class="hljs-number">15</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>] c.MyTask - fork() <span class="hljs-number">5</span> + &#123;<span class="hljs-number">4</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">29</span>:<span class="hljs-number">15</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">5</span>] c.MyTask - join() <span class="hljs-number">1</span><br><span class="hljs-number">18</span>:<span class="hljs-number">29</span>:<span class="hljs-number">15</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">3</span>] c.MyTask - fork() <span class="hljs-number">3</span> + &#123;<span class="hljs-number">2</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">29</span>:<span class="hljs-number">15</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">4</span>] c.MyTask - fork() <span class="hljs-number">2</span> + &#123;<span class="hljs-number">1</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">29</span>:<span class="hljs-number">15</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">4</span>] c.MyTask - join() <span class="hljs-number">2</span> + &#123;<span class="hljs-number">1</span>&#125; = <span class="hljs-number">3</span><br><span class="hljs-number">18</span>:<span class="hljs-number">29</span>:<span class="hljs-number">15</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">3</span>] c.MyTask - join() <span class="hljs-number">3</span> + &#123;<span class="hljs-number">2</span>&#125; = <span class="hljs-number">6</span><br><span class="hljs-number">18</span>:<span class="hljs-number">29</span>:<span class="hljs-number">15</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span>] c.MyTask - join() <span class="hljs-number">4</span> + &#123;<span class="hljs-number">3</span>&#125; = <span class="hljs-number">10</span><br><span class="hljs-number">18</span>:<span class="hljs-number">29</span>:<span class="hljs-number">15</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>] c.MyTask - join() <span class="hljs-number">5</span> + &#123;<span class="hljs-number">4</span>&#125; = <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20220123183033090.png" alt="image-20220123183033090"></p><p>串行执行，并行度不高。进行改进</p><p><strong>改进</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//二分法计算1~n的累加</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.MyTask2&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">int</span> begin;<br>    <span class="hljs-keyword">int</span> end;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyTask2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.begin = begin;<br>        <span class="hljs-keyword">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + begin + <span class="hljs-string">&quot;,&quot;</span> + end + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 5, 5</span><br>        <span class="hljs-keyword">if</span> (begin == end) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, begin);<br>            <span class="hljs-keyword">return</span> begin;<br>        &#125;<br>        <span class="hljs-comment">// 4, 5</span><br>        <span class="hljs-keyword">if</span> (end - begin == <span class="hljs-number">1</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, begin, end, end + begin);<br>            <span class="hljs-keyword">return</span> end + begin;<br>        &#125;<br><br>        <span class="hljs-comment">// 1 5</span><br>        <span class="hljs-keyword">int</span> mid = (end + begin) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 3</span><br>        MyTask2 t1 = <span class="hljs-keyword">new</span> MyTask2(begin, mid); <span class="hljs-comment">// 1,3</span><br>        t1.fork();<br>        MyTask2 t2 = <span class="hljs-keyword">new</span> MyTask2(mid + <span class="hljs-number">1</span>, end); <span class="hljs-comment">// 4,5</span><br>        t2.fork();<br>        log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125; = ?&quot;</span>, t1, t2);<br>        <span class="hljs-keyword">int</span> result = t1.join() + t2.join();<br>        log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, t1, t2, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">37</span>:<span class="hljs-number">29</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>] c.MyTask2 - fork() &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125; + &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125; = ?<br><span class="hljs-number">18</span>:<span class="hljs-number">37</span>:<span class="hljs-number">29</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">5</span>] c.MyTask2 - join() <span class="hljs-number">3</span><br><span class="hljs-number">18</span>:<span class="hljs-number">37</span>:<span class="hljs-number">29</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">3</span>] c.MyTask2 - join() <span class="hljs-number">4</span> + <span class="hljs-number">5</span> = <span class="hljs-number">9</span><br><span class="hljs-number">18</span>:<span class="hljs-number">37</span>:<span class="hljs-number">29</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">4</span>] c.MyTask2 - join() <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">3</span><br><span class="hljs-number">18</span>:<span class="hljs-number">37</span>:<span class="hljs-number">29</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span>] c.MyTask2 - fork() &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125; + &#123;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125; = ?<br><span class="hljs-number">18</span>:<span class="hljs-number">37</span>:<span class="hljs-number">29</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span>] c.MyTask2 - join() &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125; + &#123;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125; = <span class="hljs-number">6</span><br><span class="hljs-number">18</span>:<span class="hljs-number">37</span>:<span class="hljs-number">29</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>] c.MyTask2 - join() &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125; + &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125; = <span class="hljs-number">15</span><br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>用图来表示</p><p><img src="http://image.cryptomartin.top/img/image-20220123183829207.png" alt="image-20220123183829207"></p><h2 id="8-6-J-U-C"><a href="#8-6-J-U-C" class="headerlink" title="8.6 J.U.C"></a>8.6 J.U.C</h2><h3 id="8-6-1-AQS原理"><a href="#8-6-1-AQS原理" class="headerlink" title="8.6.1 AQS原理"></a>8.6.1 AQS原理</h3><h4 id="8-6-1-1-概述"><a href="#8-6-1-1-概述" class="headerlink" title="8.6.1.1 概述"></a>8.6.1.1 概述</h4><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。子类重写方法</p><p>特点：</p><ul><li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul><li>getState - 获取 state 状态</li><li>setState - 设置 state 状态</li></ul></li><li>compareAndSetState - cas 机制设置 state 状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul><p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><p>如何获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果获取锁失败</span><br><span class="hljs-keyword">if</span> (!tryAcquire(arg)) &#123;<br> <span class="hljs-comment">// 入队, 可以选择阻塞当前线程 park unpark</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如何释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果释放锁成功</span><br><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br> <span class="hljs-comment">// 让阻塞线程恢复运行</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-6-1-2-实现不可重入锁"><a href="#8-6-1-2-实现不可重入锁" class="headerlink" title="8.6.1.2 实现不可重入锁"></a>8.6.1.2 实现不可重入锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestAQS&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAQS</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyLock lock = <span class="hljs-keyword">new</span> MyLock();<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//自定义锁（不可重入锁：线程加锁后不能再次加锁）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;<br><br>    <span class="hljs-comment">//实现独占锁</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><span class="hljs-comment">//是否持有独占锁</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> MySync mySync = <span class="hljs-keyword">new</span> MySync();<br><br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//加锁，不成功会进入等待队列</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        mySync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//加锁，可打断</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        mySync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//尝试加锁，仅尝试一次</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mySync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//尝试加锁，带超时</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">return</span> mySync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//解锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        mySync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//创建条件变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mySync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">16</span>:<span class="hljs-number">06</span>:<span class="hljs-number">05</span> [t1] c.TestAQS - locking...<br><span class="hljs-number">16</span>:<span class="hljs-number">06</span>:<span class="hljs-number">06</span> [t1] c.TestAQS - unlocking...<br><span class="hljs-number">16</span>:<span class="hljs-number">06</span>:<span class="hljs-number">06</span> [t2] c.TestAQS - locking...<br><span class="hljs-number">16</span>:<span class="hljs-number">06</span>:<span class="hljs-number">06</span> [t2] c.TestAQS - unlocking...<br></code></pre></td></tr></table></figure><h3 id="8-6-2-ReentrantLock-原理"><a href="#8-6-2-ReentrantLock-原理" class="headerlink" title="8.6.2 ReentrantLock 原理"></a>8.6.2 ReentrantLock 原理</h3><p><a href="https://www.bilibili.com/video/BV16J411h7Rd?p=238">ReentrantLock 原理 P238-P246</a></p><p><img src="http://image.cryptomartin.top/img/image-20220124222445832.png" alt="image-20220124222445832"></p><h4 id="8-6-2-1-非公平锁实现原理"><a href="#8-6-2-1-非公平锁实现原理" class="headerlink" title="8.6.2.1 非公平锁实现原理"></a>8.6.2.1 非公平锁实现原理</h4><p><strong>加锁解锁流程</strong></p><p>先从构造器开始看，默认为非公平锁实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;<br> sync = <span class="hljs-keyword">new</span> NonfairSync();<br>&#125;<br></code></pre></td></tr></table></figure><p>NonfairSync 继承自 AQS</p><p>没有竞争时</p><p><img src="http://image.cryptomartin.top/img/image-20220124222701599.png" alt="image-20220124222701599"></p><p>第一个竞争出现时</p><p><img src="http://image.cryptomartin.top/img/image-20220124222733411.png" alt="image-20220124222733411"></p><p>Thread-1 执行了</p><ol><li>CAS 尝试将 state 由 0 改为 1，结果失败</li><li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li><li>接下来进入 addWaiter 逻辑，构造 Node 队列</li></ol><ul><li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</li><li>Node 的创建是懒惰的</li><li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li></ul><p>当前线程进入 acquireQueued 逻辑</p><ol><li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li><li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li><li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false</li></ol><p><img src="http://image.cryptomartin.top/img/image-20220124223513426.png" alt="image-20220124223513426"></p><ol start="4"><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时state 仍为 1，失败</li><li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回true</li><li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li></ol><p><img src="http://image.cryptomartin.top/img/image-20220124223648455.png" alt="image-20220124223648455"></p><p>再次有多个线程经历上述过程竞争失败，变成这个样子</p><p><img src="http://image.cryptomartin.top/img/image-20220124223708589.png" alt="image-20220124223708589"></p><p>Thread-0 释放锁，进入 tryRelease 流程，如果成功</p><ul><li>设置 exclusiveOwnerThread 为 null</li><li>state = 0</li></ul><p><img src="http://image.cryptomartin.top/img/image-20220124223744024.png" alt="image-20220124223744024"></p><p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程<br>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1<br>回到 Thread-1 的 acquireQueued 流程</p><p><img src="http://image.cryptomartin.top/img/image-20220124223820877.png" alt="image-20220124223820877"></p><p>如果加锁成功（没有竞争），会设置</p><ul><li>exclusiveOwnerThread 为 Thread-1，state = 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li><li>原本的 head 因为从链表断开，而可被垃圾回收</li></ul><p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p><p><img src="http://image.cryptomartin.top/img/image-20220124223924346.png" alt="image-20220124223924346"></p><p>如果不巧又被 Thread-4 占了先</p><ul><li>Thread-4 被设置为 exclusiveOwnerThread，state = 1</li><li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li></ul><h4 id="8-6-2-2-可重入原理"><a href="#8-6-2-2-可重入原理" class="headerlink" title="8.6.2.2 可重入原理"></a>8.6.2.2 可重入原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> Boolean <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br><span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br><span class="hljs-keyword">int</span> c = getState();<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入 else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="hljs-comment">// state++</span><br><span class="hljs-keyword">int</span> nextc = c + acquires;<br><span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(nextc);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Boolean <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br><span class="hljs-comment">// state-- </span><br><span class="hljs-keyword">int</span> c = getState() - releases;<br><span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>Boolean free = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>free = <span class="hljs-keyword">true</span>;<br>setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>&#125;<br>setState(c);<br><span class="hljs-keyword">return</span> free;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：加锁时，重入让state自增；解锁时，让state自减，减为0才解开。</p></blockquote><h4 id="8-6-2-3-可打断原理"><a href="#8-6-2-3-可打断原理" class="headerlink" title="8.6.2.3 可打断原理"></a>8.6.2.3 可打断原理</h4><p><strong>不可打断模式</strong></p><p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Boolean <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 如果打断标记已经是 true, 则 park 会失效</span><br>LockSupport.park(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">// interrupted 会清除打断标记</span><br><span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">final</span> Boolean <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>Boolean failed = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">try</span> &#123;<br>Boolean interrupted = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">final</span> Node p = node.predecessor();<br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>setHead(node);<br>p.next = <span class="hljs-keyword">null</span>;<br>failed = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 还是需要获得锁后, 才能返回打断状态</span><br><span class="hljs-keyword">return</span> interrupted;<br>&#125;<br><span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;parkAndCheckInterrupt()) &#123;<br><span class="hljs-comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span><br>interrupted = <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (failed)<br> cancelAcquire(node);<br>&#125;<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;<br><span class="hljs-comment">// 如果打断状态为 true</span><br>selfInterrupt();<br>&#125;<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selfInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 重新产生一次中断;获取到锁以后，打断才生效</span><br>Thread.currentThread().interrupt();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可打断模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br><span class="hljs-comment">// 如果没有获得到锁, 进入 ㈠</span><br><span class="hljs-keyword">if</span> (!tryAcquire(arg))<br> doAcquireInterruptibly(arg);<br>&#125;<br><span class="hljs-comment">// ㈠ 可打断的获取锁流程</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);<br>Boolean failed = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">final</span> Node p = node.predecessor();<br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>setHead(node);<br>p.next = <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">// help GC</span><br>failed = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br> parkAndCheckInterrupt()) &#123;<br><span class="hljs-comment">// 在 park 过程中如果被 interrupt 会进入此</span><br><span class="hljs-comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (failed)<br> cancelAcquire(node);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：</p><p>可打断模式：在队列中不可被打断，当线程获得锁以后，就被打断执行；</p><p>可打断模式：在队列中被打断，直接抛异常。</p></blockquote><h4 id="8-6-2-4-公平锁原理"><a href="#8-6-2-4-公平锁原理" class="headerlink" title="8.6.2.4 公平锁原理"></a>8.6.2.4 公平锁原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">3000897897090466540L</span>;<br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>acquire(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<br> !tryAcquire(arg) &amp;&amp;<br> acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br> ) &#123;<br>selfInterrupt();<br>&#125;<br>&#125;<br><span class="hljs-comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Boolean <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br><span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br><span class="hljs-keyword">int</span> c = getState();<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span><br><span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br> compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br><span class="hljs-keyword">int</span> nextc = c + acquires;<br><span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(nextc);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Boolean <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>&#123;<br>Node t = tail;<br>Node h = head;<br>Node s;<br><span class="hljs-comment">// h != t 时表示队列中有 Node</span><br><span class="hljs-keyword">return</span> h != t &amp;&amp;<br> (<br> <span class="hljs-comment">// (s = h.next) == null 表示队列中还有没有老二</span><br>(s = h.next) == <span class="hljs-keyword">null</span> ||<br>   <span class="hljs-comment">// 或者队列中老二线程不是此线程</span><br>s.thread != Thread.currentThread()<br> );<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-6-2-5-条件变量实现原理"><a href="#8-6-2-5-条件变量实现原理" class="headerlink" title="8.6.2.5 条件变量实现原理"></a>8.6.2.5 条件变量实现原理</h4><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObjec</p><p><strong>await流程</strong></p><p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程</p><p>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p><p><img src="http://image.cryptomartin.top/img/image-20220125111922944.png" alt="image-20220125111922944"></p><p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p><p><img src="http://image.cryptomartin.top/img/image-20220125112201735.png" alt="image-20220125112201735"></p><p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p><p><img src="http://image.cryptomartin.top/img/image-20220125112242019.png" alt="image-20220125112242019"></p><p>park 阻塞 Thread-0</p><p><img src="http://image.cryptomartin.top/img/image-20220125112309929.png" alt="image-20220125112309929"></p><p><strong>signal流程</strong></p><p>假设 Thread-1 要来唤醒 Thread-0</p><p><img src="http://image.cryptomartin.top/img/image-20220125112345029.png" alt="image-20220125112345029"></p><p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p><p><img src="http://image.cryptomartin.top/img/image-20220125112411414.png" alt="image-20220125112411414"></p><p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为-1 </p><p><img src="http://image.cryptomartin.top/img/image-20220125112444665.png" alt="image-20220125112444665"></p><p>Thread-1 释放锁，进入 unlock 流程，略</p><h3 id="8-6-3-读写锁原理"><a href="#8-6-3-读写锁原理" class="headerlink" title="8.6.3 读写锁原理"></a>8.6.3 读写锁原理</h3><h4 id="8-6-3-1-ReentrantReadWriteLock"><a href="#8-6-3-1-ReentrantReadWriteLock" class="headerlink" title="8.6.3.1  ReentrantReadWriteLock"></a>8.6.3.1  ReentrantReadWriteLock</h4><p>当读操作远远高于写操作时，这时候使用<code>读写锁</code>让<code>读-读</code>可以并发提高性能。类似于数据库中的<code>select...from...lock in share mode</code></p><p>提供一个<code>数据容器类</code>内部分别使用 读锁保护数据的 <code>read()</code>方法，写锁保护数据的<code>write()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataContainer</span> </span>&#123;<br><span class="hljs-keyword">private</span> Object data;<br><span class="hljs-keyword">private</span> ReentrantReadWriteLock rw = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br><span class="hljs-keyword">private</span> ReentrantReadWriteLock.ReadLock r = rw.readLock();<br><span class="hljs-keyword">private</span> ReentrantReadWriteLock.WriteLock w = rw.writeLock();<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>log.debug(<span class="hljs-string">&quot;获取读锁...&quot;</span>);<br>r.lock();<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;读取&quot;</span>);<br>sleep(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> data;<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>log.debug(<span class="hljs-string">&quot;释放读锁...&quot;</span>);<br>r.unlock();<br>&#125;<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> </span>&#123;<br>log.debug(<span class="hljs-string">&quot;获取写锁...&quot;</span>);<br>w.lock();<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;写入&quot;</span>);<br>sleep(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>log.debug(<span class="hljs-string">&quot;释放写锁...&quot;</span>);<br>w.unlock();<br>&#125;<br>&#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>读读可以并发，读写/写写会阻塞</p></blockquote><p><strong>注意事项</strong></p><ul><li><p>读锁不支持条件变量</p></li><li><p>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">r.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// ...</span><br>w.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>w.unlock();<br>&#125;<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>r.unlock();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>重入时降级支持：即持有写锁的情况下去获取读锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CachedData</span> </span>&#123;<br>Object data;<br><span class="hljs-comment">// 是否有效，如果失效，需要重新计算 data</span><br><span class="hljs-keyword">volatile</span> Boolean cacheValid;<br><span class="hljs-keyword">final</span> ReentrantReadWriteLock rwl = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processCachedData</span><span class="hljs-params">()</span> </span>&#123;<br>rwl.readLock().lock();<br><span class="hljs-keyword">if</span> (!cacheValid) &#123;<br><span class="hljs-comment">// 获取写锁前必须释放读锁</span><br>rwl.readLock().unlock();<br>rwl.writeLock().lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span><br><span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>data = ...<br> cacheValid = <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span><br>rwl.readLock().lock();<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>rwl.writeLock().unlock();<br>&#125;<br>&#125;<br><span class="hljs-comment">// 自己用完数据, 释放读锁 </span><br><span class="hljs-keyword">try</span> &#123;<br>use(data);<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>rwl.readLock().unlock();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-6-3-2-【应用】缓存实现"><a href="#8-6-3-2-【应用】缓存实现" class="headerlink" title="8.6.3.2 【应用】缓存实现"></a>8.6.3.2 【应用】缓存实现</h4><p><strong>1.缓存更新策略</strong></p><p>更新时，是先清缓存还是先更新数据库</p><p>先清缓存</p><p><img src="http://image.cryptomartin.top/img/image-20220125161540423.png" alt="image-20220125161540423"></p><p>先更新数据库</p><p><img src="http://image.cryptomartin.top/img/image-20220125161635164.png" alt="image-20220125161635164"></p><p><strong>2. 读写锁实现一致性缓存</strong></p><p>使用读写锁实现一个简单的按需加载缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericCachedDao</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><span class="hljs-comment">// HashMap 作为缓存非线程安全, 需要保护</span><br>HashMap&lt;SqlPair, T&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>ReentrantReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>GenericDao genericDao = <span class="hljs-keyword">new</span> GenericDao();<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(String sql, Object... params)</span> </span>&#123;<br>SqlPair key = <span class="hljs-keyword">new</span> SqlPair(sql, params);<br><span class="hljs-comment">// 加写锁, 防止其它线程对缓存读取和更改</span><br>lock.writeLock().lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">int</span> rows = genericDao.update(sql, params);<br>map.clear();<br><span class="hljs-keyword">return</span> rows;<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>lock.writeLock().unlock();<br>&#125;<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">queryOne</span><span class="hljs-params">(Class&lt;T&gt; beanClass, String sql, Object... params)</span> </span>&#123;<br>SqlPair key = <span class="hljs-keyword">new</span> SqlPair(sql, params);<br><span class="hljs-comment">// 加读锁, 防止其它线程对缓存更改</span><br>lock.readLock().lock();<br><span class="hljs-keyword">try</span> &#123;<br>T value = map.get(key);<br><span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> value;<br>&#125;<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>lock.readLock().unlock();<br>&#125;<br><span class="hljs-comment">// 加写锁, 防止其它线程对缓存读取和更改</span><br>lock.writeLock().lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// get 方法上面部分是可能多个线程进来的, 可能已经向缓存填充了数据</span><br><span class="hljs-comment">// 为防止重复查询数据库, 再次验证</span><br>T value = map.get(key);<br><span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// 如果没有, 查询数据库</span><br>value = genericDao.queryOne(beanClass, sql, params);<br>map.put(key, value);<br>&#125;<br><span class="hljs-keyword">return</span> value;<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>lock.writeLock().unlock();<br>&#125;<br>&#125;<br>    <br><span class="hljs-comment">// 作为 key 保证其是不可变的</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlPair</span> </span>&#123;<br><span class="hljs-keyword">private</span> String sql;<br><span class="hljs-keyword">private</span> Object[] params;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SqlPair</span><span class="hljs-params">(String sql, Object[] params)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.sql = sql;<br><span class="hljs-keyword">this</span>.params = params;<br>&#125;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>SqlPair sqlPair = (SqlPair) o;<br><span class="hljs-keyword">return</span> sql.equals(sqlPair.sql) &amp;&amp;<br> Arrays.equals(params, sqlPair.params);<br>&#125;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> result = Objects.hash(sql);<br>result = <span class="hljs-number">31</span> * result + Arrays.hashCode(params);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>以上实现体现的是读写锁的应用，保证缓存和数据库的一致性，但有下面的问题没有考虑</p><ul><li>适合读多写少，如果写操作比较频繁，以上实现性能低</li><li>没有考虑缓存容量</li><li>没有考虑缓存过期</li><li>只适合单机</li><li>并发性还是低，目前只会用一把锁</li><li>更新方法太过简单粗暴，清空了所有 key（考虑按类型分区或重新设计 key）</li></ul><p>乐观锁实现：用 CAS 去更新</p></blockquote><h4 id="8-6-3-3-读写锁原理"><a href="#8-6-3-3-读写锁原理" class="headerlink" title="8.6.3.3 读写锁原理"></a>8.6.3.3 读写锁原理</h4><p><a href="https://www.bilibili.com/video/BV16J411h7Rd?p=253">reentrantreadwritelock-原理 P253-P258</a></p><h4 id="8-6-3-4-StampedLock"><a href="#8-6-3-4-StampedLock" class="headerlink" title="8.6.3.4 StampedLock"></a>8.6.3.4 <strong>StampedLock</strong></h4><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p><p>加解读锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.readLock();<br>lock.unlockRead(stamp);<br></code></pre></td></tr></table></figure><p>加解写锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.writeLock();<br>lock.unlockWrite(stamp);<br></code></pre></td></tr></table></figure><p>乐观读，StampedLock 支持<code>tryOptimisticRead()</code>方法（乐观读），读取完毕后需要做一次<code>戳校验</code>如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead();<br><span class="hljs-comment">// 验戳</span><br><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;<br> <span class="hljs-comment">// 锁升级</span><br>&#125;<br></code></pre></td></tr></table></figure><p>提供一个<code>数据容器类</code>内部分别使用读锁保护数据的<code>read()</code>方法，写锁保护数据的<code>write()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataContainerStamped</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StampedLock lock = <span class="hljs-keyword">new</span> StampedLock();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DataContainerStamped</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.data = data;<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> readTime)</span> </span>&#123;<br><span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead();<br>log.debug(<span class="hljs-string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);<br>sleep(readTime);<br><span class="hljs-keyword">if</span> (lock.validate(stamp)) &#123;<br>log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);<br><span class="hljs-keyword">return</span> data;<br>&#125;<br><span class="hljs-comment">// 锁升级 - 读锁</span><br>log.debug(<span class="hljs-string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);<br><span class="hljs-keyword">try</span> &#123;<br>stamp = lock.readLock();<br>log.debug(<span class="hljs-string">&quot;read lock &#123;&#125;&quot;</span>, stamp);<br>sleep(readTime);<br>log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);<br><span class="hljs-keyword">return</span> data;<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>log.debug(<span class="hljs-string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);<br>lock.unlockRead(stamp);<br>&#125;<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newData)</span> </span>&#123;<br><span class="hljs-keyword">long</span> stamp = lock.writeLock();<br>log.debug(<span class="hljs-string">&quot;write lock &#123;&#125;&quot;</span>, stamp);<br><span class="hljs-keyword">try</span> &#123;<br>sleep(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">this</span>.data = newData;<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>log.debug(<span class="hljs-string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);<br>lock.unlockWrite(stamp);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试<code>读-读</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>DataContainerStamped dataContainer = <span class="hljs-keyword">new</span> DataContainerStamped(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>dataContainer.read(<span class="hljs-number">1</span>);<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>sleep(<span class="hljs-number">0.5</span>);<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>dataContainer.read(<span class="hljs-number">0</span>);<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">58</span>:<span class="hljs-number">50.217</span> c.DataContainerStamped [t1] - optimistic read locking..<span class="hljs-number">.256</span> <br><span class="hljs-number">15</span>:<span class="hljs-number">58</span>:<span class="hljs-number">50.717</span> c.DataContainerStamped [t2] - optimistic read locking..<span class="hljs-number">.256</span> <br><span class="hljs-number">15</span>:<span class="hljs-number">58</span>:<span class="hljs-number">50.717</span> c.DataContainerStamped [t2] - read finish..<span class="hljs-number">.256</span>, data:<span class="hljs-number">1</span> <br><span class="hljs-number">15</span>:<span class="hljs-number">58</span>:<span class="hljs-number">51.220</span> c.DataContainerStamped [t1] - read finish..<span class="hljs-number">.256</span>, data:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>测试<code>读-写</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>DataContainerStamped dataContainer = <span class="hljs-keyword">new</span> DataContainerStamped(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>dataContainer.read(<span class="hljs-number">1</span>);<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>sleep(<span class="hljs-number">0.5</span>);<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>dataContainer.write(<span class="hljs-number">100</span>);<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">00.219</span> c.DataContainerStamped [t1] - optimistic read locking..<span class="hljs-number">.256</span> <br><span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">00.717</span> c.DataContainerStamped [t2] - write lock <span class="hljs-number">384</span> <br><span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">01.225</span> c.DataContainerStamped [t1] - updating to read lock... <span class="hljs-number">256</span> <br><span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">02.719</span> c.DataContainerStamped [t2] - write unlock <span class="hljs-number">384</span> <br><span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">02.719</span> c.DataContainerStamped [t1] - read lock <span class="hljs-number">513</span> <br><span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">03.719</span> c.DataContainerStamped [t1] - read finish..<span class="hljs-number">.513</span>, data:<span class="hljs-number">1000</span> <br><span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">03.719</span> c.DataContainerStamped [t1] - read unlock <span class="hljs-number">513</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><ul><li>StampedLock 不支持条件变量</li><li>StampedLock 不支持可重入</li></ul></blockquote><h3 id="8-6-4-Semaphore"><a href="#8-6-4-Semaphore" class="headerlink" title="8.6.4 Semaphore"></a>8.6.4 Semaphore</h3><h4 id="8-6-4-1-基本使用"><a href="#8-6-4-1-基本使用" class="headerlink" title="8.6.4.1 基本使用"></a>8.6.4.1 基本使用</h4><p>[ˈsɛməˌfɔr] 信号量，用来限制能同时访问共享资源的线程上限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 1. 创建 semaphore 对象</span><br>Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 2. 10个线程同时运行</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-comment">// 3. 获取许可</span><br><span class="hljs-keyword">try</span> &#123;<br>semaphore.acquire();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>sleep(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;end...&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 4. 释放许可</span><br>semaphore.release();<br>&#125;<br>&#125;<br>).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">15.485</span> c.TestSemaphore [Thread-<span class="hljs-number">2</span>] - running... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">15.485</span> c.TestSemaphore [Thread-<span class="hljs-number">1</span>] - running... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">15.485</span> c.TestSemaphore [Thread-<span class="hljs-number">0</span>] - running... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">16.490</span> c.TestSemaphore [Thread-<span class="hljs-number">2</span>] - end... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">16.490</span> c.TestSemaphore [Thread-<span class="hljs-number">0</span>] - end... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">16.490</span> c.TestSemaphore [Thread-<span class="hljs-number">1</span>] - end... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">16.490</span> c.TestSemaphore [Thread-<span class="hljs-number">3</span>] - running... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">16.490</span> c.TestSemaphore [Thread-<span class="hljs-number">5</span>] - running... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">16.490</span> c.TestSemaphore [Thread-<span class="hljs-number">4</span>] - running... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">17.490</span> c.TestSemaphore [Thread-<span class="hljs-number">5</span>] - end... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">17.490</span> c.TestSemaphore [Thread-<span class="hljs-number">4</span>] - end... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">17.490</span> c.TestSemaphore [Thread-<span class="hljs-number">3</span>] - end... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">17.490</span> c.TestSemaphore [Thread-<span class="hljs-number">6</span>] - running... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">17.490</span> c.TestSemaphore [Thread-<span class="hljs-number">7</span>] - running... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">17.490</span> c.TestSemaphore [Thread-<span class="hljs-number">9</span>] - running... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">18.491</span> c.TestSemaphore [Thread-<span class="hljs-number">6</span>] - end... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">18.491</span> c.TestSemaphore [Thread-<span class="hljs-number">7</span>] - end... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">18.491</span> c.TestSemaphore [Thread-<span class="hljs-number">9</span>] - end... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">18.491</span> c.TestSemaphore [Thread-<span class="hljs-number">8</span>] - running... <br><span class="hljs-number">07</span>:<span class="hljs-number">35</span>:<span class="hljs-number">19.492</span> c.TestSemaphore [Thread-<span class="hljs-number">8</span>] - end...<br></code></pre></td></tr></table></figure><h4 id="8-6-4-2-【应用】Semaphore应用"><a href="#8-6-4-2-【应用】Semaphore应用" class="headerlink" title="8.6.4.2 【应用】Semaphore应用"></a>8.6.4.2 【应用】Semaphore应用</h4><p><strong>限制对共享资源的使用</strong></p><p>semaphore 实现</p><ul><li>使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比 Tomcat LimitLatch 的实现）</li><li>用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好，注意下面的实现中线程数和数据库连接数是相等的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Pool&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span> </span>&#123;<br><span class="hljs-comment">// 1. 连接池大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> poolSize;<br><span class="hljs-comment">// 2. 连接对象数组</span><br><span class="hljs-keyword">private</span> Connection[] connections;<br><span class="hljs-comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span><br><span class="hljs-keyword">private</span> AtomicIntegerArray states;<br><span class="hljs-keyword">private</span> Semaphore semaphore;<br><span class="hljs-comment">// 4. 构造方法初始化</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolSize)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.poolSize = poolSize;<br><span class="hljs-comment">// 让许可数与资源数一致</span><br><span class="hljs-keyword">this</span>.semaphore = <span class="hljs-keyword">new</span> Semaphore(poolSize);<br><span class="hljs-keyword">this</span>.connections = <span class="hljs-keyword">new</span> Connection[poolSize];<br><span class="hljs-keyword">this</span>.states = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[poolSize]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>connections[i] = <span class="hljs-keyword">new</span> MockConnection(<span class="hljs-string">&quot;连接&quot;</span> + (i+<span class="hljs-number">1</span>));<br>&#125;<br>&#125;<br><span class="hljs-comment">// 5. 借连接</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">borrow</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// t1, t2, t3</span><br><span class="hljs-comment">// 获取许可</span><br><span class="hljs-keyword">try</span> &#123;<br>semaphore.acquire();<br><span class="hljs-comment">// 没有许可的线程，在此等待</span><br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br><span class="hljs-comment">// 获取空闲连接</span><br><span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br><span class="hljs-keyword">return</span> connections[i];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 不会执行到这里</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><span class="hljs-comment">// 6. 归还连接</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(Connection conn)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br><span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>states.set(i, <span class="hljs-number">0</span>);<br>log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br>semaphore.release();<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-6-4-3-【原理】Semaphore原理"><a href="#8-6-4-3-【原理】Semaphore原理" class="headerlink" title="8.6.4.3 【原理】Semaphore原理"></a>8.6.4.3 【原理】Semaphore原理</h4><p><a href="https://www.bilibili.com/video/BV16J411h7Rd?p=264">Semaphore原理视频讲解 P264-P265</a></p><h3 id="8-6-5-CountdownLatch"><a href="#8-6-5-CountdownLatch" class="headerlink" title="8.6.5  CountdownLatch"></a>8.6.5  CountdownLatch</h3><h4 id="8-6-5-1-基本使用"><a href="#8-6-5-1-基本使用" class="headerlink" title="8.6.5.1 基本使用"></a>8.6.5.1 基本使用</h4><p>用来进行线程同步协作，等待所有线程完成倒计时。</p><p>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>sleep(<span class="hljs-number">1</span>);<br>latch.countDown();<br>log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>&#125;<br>).start();<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>sleep(<span class="hljs-number">2</span>);<br>latch.countDown();<br>log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>&#125;<br>).start();<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>sleep(<span class="hljs-number">1.5</span>);<br>latch.countDown();<br>log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>&#125;<br>).start();<br>log.debug(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>latch.await();<br>log.debug(<span class="hljs-string">&quot;wait end...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">00.778</span> c.TestCountDownLatch [main] - waiting... <br><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">00.778</span> c.TestCountDownLatch [Thread-<span class="hljs-number">2</span>] - begin... <br><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">00.778</span> c.TestCountDownLatch [Thread-<span class="hljs-number">0</span>] - begin... <br><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">00.778</span> c.TestCountDownLatch [Thread-<span class="hljs-number">1</span>] - begin... <br><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">01.782</span> c.TestCountDownLatch [Thread-<span class="hljs-number">0</span>] - end..<span class="hljs-number">.2</span> <br><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">02.283</span> c.TestCountDownLatch [Thread-<span class="hljs-number">2</span>] - end..<span class="hljs-number">.1</span> <br><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">02.782</span> c.TestCountDownLatch [Thread-<span class="hljs-number">1</span>] - end..<span class="hljs-number">.0</span> <br><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">02.782</span> c.TestCountDownLatch [main] - wait end...<br></code></pre></td></tr></table></figure><p>可以配合线程池使用，改进如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">3</span>);<br>ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>service.submit(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>sleep(<span class="hljs-number">1</span>);<br>latch.countDown();<br>log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>&#125;<br>);<br>service.submit(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>sleep(<span class="hljs-number">1.5</span>);<br>latch.countDown();<br>log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>&#125;<br>);<br>service.submit(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>sleep(<span class="hljs-number">2</span>);<br>latch.countDown();<br>log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>&#125;<br>);<br>service.submit(()-&gt;&#123;<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>latch.await();<br>log.debug(<span class="hljs-string">&quot;wait end...&quot;</span>);<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">25.831</span> c.TestCountDownLatch [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>] - begin... <br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">25.831</span> c.TestCountDownLatch [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - begin... <br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">25.831</span> c.TestCountDownLatch [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] - begin... <br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">25.831</span> c.TestCountDownLatch [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>] - waiting... <br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">26.835</span> c.TestCountDownLatch [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - end..<span class="hljs-number">.2</span> <br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">27.335</span> c.TestCountDownLatch [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] - end..<span class="hljs-number">.1</span> <br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">27.835</span> c.TestCountDownLatch [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>] - end..<span class="hljs-number">.0</span> <br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">27.835</span> c.TestCountDownLatch [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>] - wait end...<br></code></pre></td></tr></table></figure><h4 id="8-6-5-2-【应用】同步等待多线程准备完毕"><a href="#8-6-5-2-【应用】同步等待多线程准备完毕" class="headerlink" title="8.6.5.2 【应用】同步等待多线程准备完毕"></a>8.6.5.2 【应用】同步等待多线程准备完毕</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicInteger num = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">10</span>, (r) -&gt; &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;t&quot;</span> + num.getAndIncrement());<br>&#125;);<br><br>CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">10</span>);<br>String[] all = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br>Random r = <span class="hljs-keyword">new</span> Random();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br><span class="hljs-keyword">int</span> x = j;<br>service.submit(() -&gt; &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(r.nextint(<span class="hljs-number">100</span>));<br>&#125;<span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>all[x] = Thread.currentThread().getName() + <span class="hljs-string">&quot;(&quot;</span> + (i + <span class="hljs-string">&quot;%&quot;</span>) + <span class="hljs-string">&quot;)&quot;</span>;<br>System.out.print(<span class="hljs-string">&quot;r&quot;</span> + Arrays.toString(all));<br> &#125;<br> latch.countDown();<br> &#125;);<br>&#125;<br>latch.await();<br>System.out.println(<span class="hljs-string">&quot;n游戏开始...&quot;</span>);<br>service.shutdown();<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[t0(<span class="hljs-number">100</span>%), t1(<span class="hljs-number">100</span>%), t2(<span class="hljs-number">100</span>%), t3(<span class="hljs-number">100</span>%), t4(<span class="hljs-number">100</span>%), t5(<span class="hljs-number">100</span>%), t6(<span class="hljs-number">100</span>%), t7(<span class="hljs-number">100</span>%), t8(<span class="hljs-number">100</span>%), <br>t9(<span class="hljs-number">100</span>%)] <br>游戏开始...<br></code></pre></td></tr></table></figure><h3 id="8-6-6-CyclicBarrier"><a href="#8-6-6-CyclicBarrier" class="headerlink" title="8.6.6 CyclicBarrier"></a>8.6.6 CyclicBarrier</h3><p>[ˈsaɪklɪk ˈbæriɚ] 循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">CyclicBarrier cb = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 个数为2时才会继续执行</span><br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>System.out.println(<span class="hljs-string">&quot;线程1开始..&quot;</span>+<span class="hljs-keyword">new</span> Date());<br><span class="hljs-keyword">try</span> &#123;<br>cb.await();<br><span class="hljs-comment">// 当个数不足时，等待</span><br>&#125;<span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>e.printStackTrace();<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;线程1继续向下运行...&quot;</span>+<span class="hljs-keyword">new</span> Date());<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>System.out.println(<span class="hljs-string">&quot;线程2开始..&quot;</span>+<span class="hljs-keyword">new</span> Date());<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">2000</span>);<br>&#125;<span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>cb.await();<br><span class="hljs-comment">// 2 秒后，线程个数够2，继续运行</span><br>&#125;<span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>e.printStackTrace();<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;线程2继续向下运行...&quot;</span>+<span class="hljs-keyword">new</span> Date());<br>&#125;).start()<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的 CyclicBarrier 可以被比喻为『人满发车』</p><p>线程数和计数要一样！</p></blockquote><h2 id="8-7-线程安全集合类概述"><a href="#8-7-线程安全集合类概述" class="headerlink" title="8.7 线程安全集合类概述"></a>8.7 线程安全集合类概述</h2><p><img src="http://image.cryptomartin.top/img/image-20220125221907757.png" alt="image-20220125221907757"></p><p>线程安全集合类可以分为三大类：</p><ul><li>遗留的线程安全集合如 Hashtable ， Vector</li><li>使用 Collections 装饰的线程安全集合，如：<ul><li>Collections.synchronizedCollection</li><li>Collections.synchronizedList</li><li>Collections.synchronizedMap</li><li>Collections.synchronizedSet</li><li>Collections.synchronizedNavigableMap</li><li>Collections.synchronizedNavigableSet </li><li>Collections.synchronizedSortedMap</li><li>Collections.synchronizedSortedSet</li></ul></li><li>java.util.concurrent.*</li></ul><p>重点介绍<code>java.util.concurrent.*</code>下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：<code>Blocking</code>、<code>CopyOnWrite</code>、<code>Concurrent</code></p><ul><li>Blocking 大部分实现基于锁(reentrantlock)，并提供用来阻塞的方法</li><li>CopyOnWrite 之类容器修改开销相对较重</li><li>Concurrent 类型的容器<ul><li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量</li><li>弱一致性<ul><li>遍历时 弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li><li>求大小 弱一致性，size 操作未必是 100% 准确</li><li>读取 弱一致性</li></ul></li></ul></li></ul><blockquote><p>遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛ConcurrentModificationException，不再继续遍历</p></blockquote><h2 id="8-8-ConcurrentHashMap"><a href="#8-8-ConcurrentHashMap" class="headerlink" title="8.8 ConcurrentHashMap"></a>8.8 ConcurrentHashMap</h2><h3 id="8-8-1-练习：单词计数"><a href="#8-8-1-练习：单词计数" class="headerlink" title="8.8.1 练习：单词计数"></a>8.8.1 练习：单词计数</h3><p>生成测试数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ALPHA = <span class="hljs-string">&quot;abcedfghijklmnopqrstuvwxyz&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> length = ALPHA.length();<br><span class="hljs-keyword">int</span> count = <span class="hljs-number">200</span>;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(length * count);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br><span class="hljs-keyword">char</span> ch = ALPHA.charAt(i);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; count; j++) &#123;<br>list.add(String.valueOf(ch));<br>&#125;<br>&#125;<br>Collections.shuffle(list);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br><span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<br> <span class="hljs-keyword">new</span> OutputStreamWriter(<br> <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;tmp/&quot;</span> + (i+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;.txt&quot;</span>)))) &#123;<br>String collect = list.subList(i * count, (i + <span class="hljs-number">1</span>) * count).stream()<br> .collect(Collectors.joining(<span class="hljs-string">&quot;n&quot;</span>));<br>out.print(collect);<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException e) &#123;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模版代码，模版代码中封装了多线程读取文件的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;V&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Supplier&lt;Map&lt;String,V&gt;&gt; supplier, </span></span><br><span class="hljs-params"><span class="hljs-function">BiConsumer&lt;Map&lt;String,V&gt;,List&lt;String&gt;&gt; consumer)</span> </span>&#123;<br>Map&lt;String, V&gt; counterMap = supplier.get();<br>List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">26</span>; i++) &#123;<br><span class="hljs-keyword">int</span> idx = i;<br>Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>List&lt;String&gt; words = readFromFile(idx);<br>consumer.accept(counterMap, words);<br>&#125;<br>);<br>ts.add(thread);<br>&#125;<br>ts.forEach(t-&gt;t.start());<br>ts.forEach(t-&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>t.join();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>);<br>System.out.println(counterMap);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">readFromFile</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>ArrayList&lt;String&gt; words = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">try</span> (BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;tmp/&quot;</span><br>+ i +<span class="hljs-string">&quot;.txt&quot;</span>)))) &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>String word = in.readLine();<br><span class="hljs-keyword">if</span>(word == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>words.add(word);<br>&#125;<br><span class="hljs-keyword">return</span> words;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你要做的是实现两个参数</p><ul><li>一是提供一个 map 集合，用来存放每个单词的计数结果，key 为单词，value 为计数</li><li>二是提供一组操作，保证计数的安全性，会传递 map 集合以及 单词 List</li></ul><p>正确结果输出应该是每个单词出现 200 次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;a=<span class="hljs-number">200</span>, b=<span class="hljs-number">200</span>, c=<span class="hljs-number">200</span>, d=<span class="hljs-number">200</span>, e=<span class="hljs-number">200</span>, f=<span class="hljs-number">200</span>, g=<span class="hljs-number">200</span>, h=<span class="hljs-number">200</span>, i=<span class="hljs-number">200</span>, j=<span class="hljs-number">200</span>, k=<span class="hljs-number">200</span>, l=<span class="hljs-number">200</span>, m=<span class="hljs-number">200</span>, <br>n=<span class="hljs-number">200</span>, o=<span class="hljs-number">200</span>, p=<span class="hljs-number">200</span>, q=<span class="hljs-number">200</span>, r=<span class="hljs-number">200</span>, s=<span class="hljs-number">200</span>, t=<span class="hljs-number">200</span>, u=<span class="hljs-number">200</span>, v=<span class="hljs-number">200</span>, w=<span class="hljs-number">200</span>, x=<span class="hljs-number">200</span>, y=<span class="hljs-number">200</span>, z=<span class="hljs-number">200</span>&#125;<br></code></pre></td></tr></table></figure><p>下面的实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br> <span class="hljs-comment">// 创建 map 集合</span><br><span class="hljs-comment">// 创建 ConcurrentHashMap 对不对？</span><br>() -&gt; <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;(),<br> <span class="hljs-comment">// 进行计数</span><br>(map, words) -&gt; &#123;<br><span class="hljs-keyword">for</span> (String word : words) &#123;<br>Integer counter = map.get(word);<br><span class="hljs-keyword">int</span> newValue = counter == <span class="hljs-keyword">null</span> ? <span class="hljs-number">1</span> : counter + <span class="hljs-number">1</span>;<br>map.put(word, newValue);<br>&#125;<br>&#125;<br>);<br></code></pre></td></tr></table></figure><p>改进1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br> () -&gt; <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, LongAdder&gt;(),<br> (map, words) -&gt; &#123;<br><span class="hljs-keyword">for</span> (String word : words) &#123;<br><span class="hljs-comment">// 注意不能使用 putIfAbsent，此方法返回的是上一次的 value，首次调用返回 null</span><br>map.computeIfAbsent(word, (key) -&gt; <span class="hljs-keyword">new</span> LongAdder()).increment();<br>&#125;<br>&#125;<br>);<br></code></pre></td></tr></table></figure><blockquote><p>computeIfAbsent() 方法对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hashMap 中.</p><p>返回值：</p><p>如果 key 对应的 value 不存在，则使用获取 remappingFunction 重新计算后的值，并保存为该 key 的 value；否则返回 value。</p></blockquote><h3 id="8-8-2-【原理】ConcurrentHashMap"><a href="#8-8-2-【原理】ConcurrentHashMap" class="headerlink" title="8.8.2 【原理】ConcurrentHashMap"></a>8.8.2 【原理】ConcurrentHashMap</h3><p><strong>JDK7 HashMap并发死链</strong></p><ul><li><p><a href="https://www.bilibili.com/video/BV16J411h7Rd?p=277&share_source=copy_web">hashmap并发死链IDEA调式过程P277-P280</a></p></li><li><p>jdk1.7中 hashmap为什么会发生死链？ - 磊哥的回答 - 知乎 <a href="https://www.zhihu.com/question/394039290/answer/2314917909">https://www.zhihu.com/question/394039290/answer/2314917909</a></p></li></ul><p><strong>JDK8 ConcurrentHashMap</strong></p><ul><li><a href="https://www.bilibili.com/video/BV16J411h7Rd?p=281">JDK8 ConcurrentHashMap P281-289</a></li></ul><p><strong>JDK7 ConcurrentHashMap</strong></p><ul><li><a href="https://www.bilibili.com/video/BV16J411h7Rd?p=290">JDK7 ConcurrentHashMap P290-P296</a></li></ul><h2 id="8-9-LinkedBlockingQueue"><a href="#8-9-LinkedBlockingQueue" class="headerlink" title="8.9 LinkedBlockingQueue"></a>8.9 LinkedBlockingQueue</h2><h3 id="8-9-1-基本的入队出队"><a href="#8-9-1-基本的入队出队" class="headerlink" title="8.9.1 基本的入队出队"></a>8.9.1 基本的入队出队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class"> <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>E item;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 下列三种情况之一</span><br><span class="hljs-comment">         * - 真正的后继节点</span><br><span class="hljs-comment">         * - 自己, 发生在出队时</span><br><span class="hljs-comment">         * - null, 表示是没有后继节点, 是最后了</span><br><span class="hljs-comment">         */</span><br>Node&lt;E&gt; next;<br>Node(E x) &#123;<br>item = x;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化链表<code>last = head = new Node&lt;E&gt;(null);</code>Dummy 节点用来占位，item 为<code>null</code></p><p><img src="http://image.cryptomartin.top/img/image-20220126162436633.png" alt="image-20220126162436633"></p><p>当一个节点入队<code>last = last.next = node;</code></p><p><img src="http://image.cryptomartin.top/img/image-20220126162523059.png" alt="image-20220126162523059"></p><p>再来一个节点入队<code>last = last.next = node;</code></p><p><img src="http://image.cryptomartin.top/img/image-20220126162613412.png" alt="image-20220126162613412"></p><p>出队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Node&lt;E&gt; h = head;<br>Node&lt;E&gt; first = h.next; <br>h.next = h; <span class="hljs-comment">// help GC</span><br>head = first; <br>E x = first.item;<br>first.item = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">return</span> x;<br></code></pre></td></tr></table></figure><p><code>Node&lt;E&gt; h = head;</code></p><p><img src="http://image.cryptomartin.top/img/image-20220126162650414.png" alt="image-20220126162650414"></p><p><code>Node&lt;E&gt; first = h.next; </code></p><p><img src="http://image.cryptomartin.top/img/image-20220126162807975.png" alt="image-20220126162807975"></p><p><code>h.next = h;</code></p><p><img src="http://image.cryptomartin.top/img/image-20220126162834085.png" alt="image-20220126162834085"></p><p><code>head = first; </code></p><p><img src="http://image.cryptomartin.top/img/image-20220126162914943.png" alt="image-20220126162914943"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">E x = first.item;<br>first.item = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">return</span> x;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20220126162934056.png" alt="image-20220126162934056"></p><h3 id="8-9-2-加锁分析"><a href="#8-9-2-加锁分析" class="headerlink" title="8.9.2 加锁分析"></a>8.9.2 加锁分析</h3><p>==高明之处==在于用了两把锁和 dummy 节点</p><ul><li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li><li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行<ul><li>消费者与消费者线程仍然串行</li><li>生产者与生产者线程仍然串行</li></ul></li></ul><p>线程安全分析</p><ul><li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是head 节点的线程安全。两把锁保证了入队和出队没有竞争</li><li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</li><li>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于 put(阻塞) offer(非阻塞)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">// 用户 take(阻塞) poll(非阻塞)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">new</span> ReentrantLock();<br></code></pre></td></tr></table></figure><p><strong>put操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;<br>    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> Node&lt;E&gt;(e);<br>    <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;<br>    <span class="hljs-comment">// count 用来维护元素计数</span><br>    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;<br>    putLock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 满了等待</span><br>        <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;<br>            <span class="hljs-comment">// 倒过来读就好: 等待 notFull</span><br>            notFull.await();<br>        &#125;<br>        <span class="hljs-comment">// 有空位, 入队且计数加一</span><br>        enqueue(node);<br>        c = count.getAndIncrement();<br>        <span class="hljs-comment">// 除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程</span><br>        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)<br>         notFull.signal();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        putLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 如果队列中有一个元素, 叫醒 take 线程</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>     <span class="hljs-comment">// 这里调用的是 notEmpty.signal() 而不是 notEmpty.signalAll() 是为了减少竞争</span><br>    signalNotEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>take操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    E x;<br>    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;<br>    <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;<br>    takeLock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;<br>            notEmpty.await();<br>        &#125;<br>        x = dequeue();<br>        c = count.getAndDecrement();<br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)<br>         notEmpty.signal();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        takeLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 如果队列中只有一个空位时, 叫醒 put 线程</span><br>    <span class="hljs-comment">// 如果有多个线程进行出队, 第一个线程满足 c == capacity, 但后续线程 c &lt; capacity</span><br>    <span class="hljs-keyword">if</span> (c == capacity)<br>     <span class="hljs-comment">// 这里调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争</span><br>    signalNotFull()<br>      <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由 put 唤醒 put <strong>是为了避免信号不足</strong></p></blockquote><h3 id="8-9-3-性能比较"><a href="#8-9-3-性能比较" class="headerlink" title="8.9.3 性能比较"></a>8.9.3 性能比较</h3><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较</p><ul><li>Linked 支持有界，Array 强制有界</li><li>Linked 实现是链表，Array 实现是数组</li><li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li><li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li><li>Linked 两把锁，Array 一把锁</li></ul><h2 id="8-10-ConcurrentLinkedQueue"><a href="#8-10-ConcurrentLinkedQueue" class="headerlink" title="8.10 ConcurrentLinkedQueue"></a>8.10 ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是</p><ul><li>两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</li><li>dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争</li><li>只是这【锁】使用了 cas 来实现</li></ul><p>事实上，ConcurrentLinkedQueue 应用还是非常广泛的</p><p>例如之前讲的 Tomcat 的 Connector 结构时，Acceptor 作为生产者向 Poller 消费者传递事件信息时，正是采用了<br>ConcurrentLinkedQueue 将 SocketChannel 给 Poller 使用</p><p><img src="http://image.cryptomartin.top/img/image-20220126164738074.png" alt="image-20220126164738074"></p><h2 id="8-11-CopyOnWriteArrayList"><a href="#8-11-CopyOnWriteArrayList" class="headerlink" title="8.11 CopyOnWriteArrayList"></a>8.11 CopyOnWriteArrayList</h2><p><code>CopyOnWriteArraySet</code>是它的马甲 底层实现采用了<code>写入时拷贝</code>的思想，增删改操作会将底层数组拷贝一份，更改操作在新数组上执行，这时不影响其它线程的并发读，读写分离。 以新增为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        <span class="hljs-comment">// 获取旧的数组</span><br>        Object[] es = getArray();<br>        <span class="hljs-keyword">int</span> len = es.length;<br>        <span class="hljs-comment">// 拷贝新的数组（这里是比较耗时的操作，但不影响其它读线程）</span><br>        es = Arrays.copyOf(es, len + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 添加新元素</span><br>        es[len] = e;<br>        <span class="hljs-comment">// 替换旧的数组</span><br>        setArray(es);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里的源码版本是 Java 11，在 Java 1.8 中使用的是可重入锁而不是 synchronized</p></blockquote><p>其它读操作并未加锁，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;<br> Objects.requireNonNull(action);<br> <span class="hljs-keyword">for</span> (Object x : getArray()) &#123;<br> <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) x;<br> action.accept(e);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>适合『读多写少』的应用场景</p></blockquote><p><strong>get 弱一致性</strong></p><p><img src="http://image.cryptomartin.top/img/image-20220126164944526.png" alt="image-20220126164944526"></p><p><img src="http://image.cryptomartin.top/img/image-20220126164952906.png" alt="image-20220126164952906"></p><p><strong>迭代器弱一致性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">CopyOnWriteArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br>Iterator&lt;Integer&gt; iter = list.iterator();<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    list.remove(<span class="hljs-number">0</span>);<br>    System.out.println(list);<br>&#125;).start();<br><br>sleep1s();<br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>    System.out.println(iter.next());<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>不要觉得弱一致性就不好</p><ul><li>数据库的 MVCC 都是弱一致性的表现</li><li>并发高和一致性是矛盾的，需要权衡</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第七章 共享模型之不可变</title>
    <link href="/2022/02/01/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <url>/2022/02/01/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<h1 id="第七章-共享模型之不可变"><a href="#第七章-共享模型之不可变" class="headerlink" title="第七章 共享模型之不可变"></a>第七章 共享模型之不可变</h1><p><strong>本章内容</strong></p><ul><li>不可变类的使用</li><li>不可变类设计</li><li>无状态类设计</li></ul><h2 id="7-1-日期转换问题"><a href="#7-1-日期转换问题" class="headerlink" title="7.1 日期转换问题"></a>7.1 日期转换问题</h2><h3 id="7-1-1-问题提出"><a href="#7-1-1-问题提出" class="headerlink" title="7.1.1 问题提出"></a>7.1.1 问题提出</h3><p>下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>));<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception e) &#123;<br>log.error(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);<br>&#125;<br>&#125;<br>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>有很大几率出现 java.lang.NumberFormatException 或者出现不正确的日期解析结果，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">19</span>:<span class="hljs-number">10</span>:<span class="hljs-number">40.859</span> [Thread-<span class="hljs-number">2</span>] c.TestDateParse - &#123;&#125; <br>java.lang.NumberFormatException: For input string: <span class="hljs-string">&quot;&quot;</span> <br> at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="hljs-number">65</span>) <br> at java.lang.Long.parseLong(Long.java:<span class="hljs-number">601</span>) <br> at java.lang.Long.parseLong(Long.java:<span class="hljs-number">631</span>) <br> at java.text.DigitList.getLong(DigitList.java:<span class="hljs-number">195</span>) <br> at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="hljs-number">2084</span>) <br> at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="hljs-number">2162</span>) <br> at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="hljs-number">1514</span>) <br> at java.text.DateFormat.parse(DateFormat.java:<span class="hljs-number">364</span>) <br> at cn.itcast.n7.TestDateParse.lambda$test1$<span class="hljs-number">0</span>(TestDateParse.java:<span class="hljs-number">18</span>) <br> at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>) <br><span class="hljs-number">19</span>:<span class="hljs-number">10</span>:<span class="hljs-number">40.859</span> [Thread-<span class="hljs-number">1</span>] c.TestDateParse - &#123;&#125; <br>java.lang.NumberFormatException: empty String <br> at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:<span class="hljs-number">1842</span>) <br> at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:<span class="hljs-number">110</span>) <br> at java.lang.Double.parseDouble(Double.java:<span class="hljs-number">538</span>) <br> at java.text.DigitList.getDouble(DigitList.java:<span class="hljs-number">169</span>) <br> at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="hljs-number">2089</span>) <br> at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="hljs-number">2162</span>) <br> at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="hljs-number">1514</span>) <br> at java.text.DateFormat.parse(DateFormat.java:<span class="hljs-number">364</span>) <br> at cn.itcast.n7.TestDateParse.lambda$test1$<span class="hljs-number">0</span>(TestDateParse.java:<span class="hljs-number">18</span>) <br> at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>) <br><span class="hljs-number">19</span>:<span class="hljs-number">10</span>:<span class="hljs-number">40.857</span> [Thread-<span class="hljs-number">8</span>] c.TestDateParse - Sat Apr <span class="hljs-number">21</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> CST <span class="hljs-number">1951</span> <br><span class="hljs-number">19</span>:<span class="hljs-number">10</span>:<span class="hljs-number">40.857</span> [Thread-<span class="hljs-number">9</span>] c.TestDateParse - Sat Apr <span class="hljs-number">21</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> CST <span class="hljs-number">1951</span> <br><span class="hljs-number">19</span>:<span class="hljs-number">10</span>:<span class="hljs-number">40.857</span> [Thread-<span class="hljs-number">6</span>] c.TestDateParse - Sat Apr <span class="hljs-number">21</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> CST <span class="hljs-number">1951</span><br></code></pre></td></tr></table></figure><h3 id="7-1-2-思路-同步锁"><a href="#7-1-2-思路-同步锁" class="headerlink" title="7.1.2 思路-同步锁"></a>7.1.2 思路-同步锁</h3><p>这样虽能解决问题，但带来的是性能上的损失，并不算很好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span> (sdf) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>));<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception e) &#123;<br>log.error(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);<br>&#125;<br>&#125;<br>&#125;<br>).start();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-1-3-思路-使用不可变类"><a href="#7-1-3-思路-使用不可变类" class="headerlink" title="7.1.3 思路-使用不可变类"></a>7.1.3 思路-使用不可变类</h3><p>如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！这样的对象在Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>TemporalAccessor parse = dtf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>);<br>log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,parse);<br>&#125;<br>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看 DateTimeFormatter 的文档：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Implementation Requirements:This <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">is</span> <span class="hljs-title">immutable</span> <span class="hljs-title">and</span> <span class="hljs-title">thread</span>-<span class="hljs-title">safe</span>.</span><br></code></pre></td></tr></table></figure><p>不可变对象，实际是另一种避免竞争的方式。</p><h2 id="7-2-不可变设计思想"><a href="#7-2-不可变设计思想" class="headerlink" title="7.2 不可变设计思想"></a>7.2 不可变设计思想</h2><h3 id="7-2-1-String"><a href="#7-2-1-String" class="headerlink" title="7.2.1 String"></a>7.2.1 String</h3><p>一个大家更为熟悉的 String 类也是不可变的，以它为例，说明一下不可变设计的要素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class"> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br><span class="hljs-comment">/** The value is used for character storage. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br><span class="hljs-comment">/** Cache the hash code for the string */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash;<br><span class="hljs-comment">// Default to 0</span><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-2-final的使用"><a href="#7-2-2-final的使用" class="headerlink" title="7.2.2 final的使用"></a>7.2.2 final的使用</h3><p>发现该类、类中所有属性都是 fifinal 的</p><ul><li>属性用 final 修饰保证了该属性是只读的，不能修改</li><li>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li></ul><h3 id="7-2-3-保护性拷贝"><a href="#7-2-3-保护性拷贝" class="headerlink" title="7.2.3 保护性拷贝"></a>7.2.3 保护性拷贝</h3><p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是如何实现的，就以 substring 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);<br>&#125;<br><span class="hljs-keyword">int</span> subLen = value.length - beginIndex;<br><span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);<br>&#125;<br><span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);<br>&#125;<br></code></pre></td></tr></table></figure><p>发现其内部是调用 String 的构造方法创建了一个新字符串，再进入这个构造看看，是否对 final char[] value 做出了修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);<br>&#125;<br><span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(count);<br>&#125;<br><span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;<br><span class="hljs-keyword">this</span>.value = <span class="hljs-string">&quot;&quot;</span>.value;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + count);<br>&#125;<br><span class="hljs-keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果发现也没有，构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】</p><h2 id="7-3-【模式】模式之享元模式"><a href="#7-3-【模式】模式之享元模式" class="headerlink" title="7.3 【模式】模式之享元模式"></a>7.3 【模式】模式之享元模式</h2><h3 id="7-3-1-介绍"><a href="#7-3-1-介绍" class="headerlink" title="7.3.1 介绍"></a>7.3.1 介绍</h3><p>享元（Flyweight）模式的定义：运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p><p>享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p><p>其主要缺点是：</p><ol><li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li><li>读取享元模式的外部状态会使得运行时间稍微变长。</li></ol><h3 id="7-3-2-体现"><a href="#7-3-2-体现" class="headerlink" title="7.3.2 体现"></a>7.3.2 体现</h3><p><strong>包装类</strong></p><p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">long</span> l)</span> </span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset = <span class="hljs-number">128</span>;<br><span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123;<br><span class="hljs-comment">// will cache</span><br><span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-keyword">int</span>)l + offset];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>(l);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li>Byte, Short, Long 缓存的范围都是 -128~127</li><li>Character 缓存的范围是 0~127</li><li>Integer的默认范围是 -128~127</li><li>最小值不能变</li><li>但最大值可以通过调整虚拟机参数 <code>  -Djava.lang.Integer.IntegerCache.high</code> 来改变</li><li>Boolean 缓存了 TRUE 和 FALSE</li></ul></blockquote><p><strong>String 串池</strong></p><p><strong>BigDecimal BigInteger</strong></p><blockquote><p>单个线程BigDecimal是thread-safe，但是多个线程并不能保证BigDecimal是thread-safe。每个是原子的，但组合操作不一定是原子的。所以要使用原子引用类来保护。</p></blockquote><h3 id="7-3-3-DIY"><a href="#7-3-3-DIY" class="headerlink" title="7.3.3 DIY"></a>7.3.3 DIY</h3><p>例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span> </span>&#123;<br><span class="hljs-comment">// 1. 连接池大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> poolSize;<br><span class="hljs-comment">// 2. 连接对象数组</span><br><span class="hljs-keyword">private</span> Connection[] connections;<br><span class="hljs-comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span><br><span class="hljs-keyword">private</span> AtomicIntegerArray states;<br><span class="hljs-comment">// 4. 构造方法初始化</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolSize)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.poolSize = poolSize;<br><span class="hljs-keyword">this</span>.connections = <span class="hljs-keyword">new</span> Connection[poolSize];<br><span class="hljs-keyword">this</span>.states = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[poolSize]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>connections[i] = <span class="hljs-keyword">new</span> MockConnection(<span class="hljs-string">&quot;连接&quot;</span> + (i+<span class="hljs-number">1</span>));<br>&#125;<br>&#125;<br><span class="hljs-comment">// 5. 借连接</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">borrow</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br><span class="hljs-comment">// 获取空闲连接</span><br><span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br><span class="hljs-keyword">return</span> connections[i];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 如果没有空闲连接，当前线程进入等待</span><br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;wait...&quot;</span>);<br><span class="hljs-keyword">this</span>.wait();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 6. 归还连接</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(Connection conn)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br><span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>states.set(i, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br><span class="hljs-keyword">this</span>.notifyAll();<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Connection</span> </span>&#123;<br><span class="hljs-comment">// 实现略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用连接池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Pool pool = <span class="hljs-keyword">new</span> Pool(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>Connection conn = pool.borrow();<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-keyword">new</span> Random().nextint(<span class="hljs-number">1000</span>));<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>pool.free(conn);<br>&#125;<br>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>以上实现没有考虑：</p><ul><li>连接的动态增长与收缩</li><li>连接保活（可用性检测）</li><li>等待超时处理</li><li>分布式 hash</li></ul><p>对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apache commons pool，例如redis连接池可以参考jedis中关于连接池的实现</p><h2 id="7-4-final-原理"><a href="#7-4-final-原理" class="headerlink" title="7.4 final 原理"></a>7.4 final 原理</h2><h3 id="7-4-1-设置-final-变量的原理"><a href="#7-4-1-设置-final-变量的原理" class="headerlink" title="7.4.1  设置 final 变量的原理"></a>7.4.1  设置 final 变量的原理</h3><p>理解了 volatile 原理，再对比 fifinal 的实现就比较简单了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFinal</span> </span>&#123;<br> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: aload_0<br><span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span> <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-number">4</span>: aload_0<br><span class="hljs-number">5</span>: bipush <span class="hljs-number">20</span><br><span class="hljs-number">7</span>: putfield #<span class="hljs-number">2</span>     <span class="hljs-comment">// Field a:I</span><br> &lt;-- 写屏障   <span class="hljs-comment">//1.保证写屏障之前的指令不会重排序到写屏障之后；2.保证写屏障的修改/赋值操作，在写屏障之后，会同步到主存，其他线程可见</span><br><span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>发现 final 变量的赋值也会通过 putfifield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFinal</span> </span>&#123;<br> <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>不加final，初始值是为0，赋值20是第二步；如果其他线程看到赋值之前的，那就是0。final保证在其它线程读到它的值时不会出现为 0 的情况。</p><h3 id="7-4-2-获取-final-变量的原理"><a href="#7-4-2-获取-final-变量的原理" class="headerlink" title="7.4.2  获取 final 变量的原理"></a>7.4.2  获取 final 变量的原理</h3><p><strong>加final关键字</strong></p><p><img src="http://image.cryptomartin.top/img/image-20220105172644587.png" alt="image-20220105172644587"></p><p>并没有到<code>TestFinal</code>类中读取A变量，而是把A变量10复制到 <code>UseFinal1</code>类的栈中。</p><p><code>final</code>修饰的值，会被赋值一份到其他类中。没有共享的操作。</p><p><strong>不加final关键字</strong></p><p><img src="http://image.cryptomartin.top/img/image-20220105173010903.png" alt="image-20220105173010903"></p><p>相当于<code>UseFinal1</code>类 到 <code>TestFinal</code> 中去获取静态成员变量，这实际上走的是共享内存。比栈内存性能低。</p><h2 id="7-5-无状态"><a href="#7-5-无状态" class="headerlink" title="7.5 无状态"></a>7.5 无状态</h2><p>在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的。</p><p>不可变类是成员变量不可变，而无状态类是更进一步，不设置成员变量。</p><blockquote><p>因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】</p></blockquote><h2 id="7-6-本章小结"><a href="#7-6-本章小结" class="headerlink" title="7.6 本章小结"></a>7.6 本章小结</h2><p>不可变类使用<br>不可变类设计</p><ul><li>原理方面<ul><li>final</li></ul></li><li>模式方面<ul><li>享元模式</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第六章 共享模型之无锁</title>
    <link href="/2022/02/01/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81/"/>
    <url>/2022/02/01/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="第六章-共享模型之无锁"><a href="#第六章-共享模型之无锁" class="headerlink" title="第六章 共享模型之无锁"></a>第六章 共享模型之无锁</h1><p>本章内容</p><ul><li>CAS与volatile</li><li>原子整数</li><li>原子引用</li><li>原子累加器</li><li>Unsafe</li></ul><h2 id="6-1-案例改进-由加锁到无锁"><a href="#6-1-案例改进-由加锁到无锁" class="headerlink" title="6.1 案例改进-由加锁到无锁"></a>6.1 案例改进-由加锁到无锁</h2><h3 id="6-1-1-问题提出"><a href="#6-1-1-问题提出" class="headerlink" title="6.1.1 问题提出"></a>6.1.1 问题提出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAccount</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Account account = <span class="hljs-keyword">new</span> AccountUnsafe(<span class="hljs-number">10000</span>);<br>        Account.demo(account);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Integer balance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = balance;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance-=amount;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-comment">// 获取余额</span><br>    <span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 取款</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                account.withdraw(<span class="hljs-number">10</span>);<br>            &#125;));<br>        &#125;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        ts.forEach(Thread::start);<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(account.getBalance()<br>                + <span class="hljs-string">&quot; cost: &quot;</span> + (end-start)/<span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">430</span> cost: <span class="hljs-number">113</span> ms<br></code></pre></td></tr></table></figure><h3 id="6-1-2-解决思路：加锁"><a href="#6-1-2-解决思路：加锁" class="headerlink" title="6.1.2 解决思路：加锁"></a>6.1.2 解决思路：加锁</h3><p>首先想到的是给 Account 对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer balance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = balance;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>)&#123;<br>            <span class="hljs-keyword">this</span>.balance -= amount;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> cost: <span class="hljs-number">113</span> ms<br></code></pre></td></tr></table></figure><h3 id="6-1-3-解决思路-无锁"><a href="#6-1-3-解决思路-无锁" class="headerlink" title="6.1.3 解决思路-无锁"></a>6.1.3 解决思路-无锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicInteger balance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-comment">//获取最新值</span><br>            <span class="hljs-keyword">int</span> prev = balance.get();<br>            <span class="hljs-comment">//要修改的余额</span><br>            <span class="hljs-keyword">int</span> next = prev - amount;<br>            <span class="hljs-comment">//真正修改，同步到主存</span><br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> cost: <span class="hljs-number">107</span> ms<br></code></pre></td></tr></table></figure><h2 id="6-2-CAS与volatile"><a href="#6-2-CAS与volatile" class="headerlink" title="6.2 CAS与volatile"></a>6.2 CAS与volatile</h2><h3 id="6-2-1-CAS分析"><a href="#6-2-1-CAS分析" class="headerlink" title="6.2.1 CAS分析"></a>6.2.1 CAS分析</h3><p>前面看到的 <code>AtomicInteger</code> 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">int</span> prev = balance.<span class="hljs-built_in">get</span>();<br>            <span class="hljs-keyword">int</span> next = prev - amount;<br>            <span class="hljs-comment">//比较并设置</span><br>            <span class="hljs-keyword">if</span> (balance.<span class="hljs-built_in">compareAndSet</span>(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p><p><img src="http://image.cryptomartin.top/img/image-20220103174310686.png" alt="image-20220103174310686"></p><blockquote><p><strong>注意</strong></p><p>其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。</p><p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p></blockquote><h3 id="6-2-2-CAS必须配合volatile使用"><a href="#6-2-2-CAS必须配合volatile使用" class="headerlink" title="6.2.2 CAS必须配合volatile使用"></a>6.2.2 CAS必须配合volatile使用</h3><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。</p><p><img src="http://image.cryptomartin.top/img/image-20220103175134654.png" alt="image-20220103175134654"></p><p>它可以用来修饰成员变量和静态成员变量，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p><blockquote><p><strong>注意</strong></p><p>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p></blockquote><p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</p><h3 id="6-2-3-为什么无锁效率高"><a href="#6-2-3-为什么无锁效率高" class="headerlink" title="6.2.3 为什么无锁效率高"></a>6.2.3 为什么无锁效率高</h3><ul><li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻</li><li>线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大</li><li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</li></ul><h3 id="6-2-4-CAS的特点"><a href="#6-2-4-CAS的特点" class="headerlink" title="6.2.4 CAS的特点"></a>6.2.4 CAS的特点</h3><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p><ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li><li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思<ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h2 id="6-3-Atomic"><a href="#6-3-Atomic" class="headerlink" title="6.3 Atomic"></a>6.3 Atomic</h2><h3 id="6-3-1-原子整数"><a href="#6-3-1-原子整数" class="headerlink" title="6.3.1 原子整数"></a>6.3.1 原子整数</h3><p>J.U.C 并发包提供了：</p><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><p>以 AtomicInteger 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test34</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>        System.out.println(i.incrementAndGet()); <span class="hljs-comment">//++i 自增再在打印1</span><br>        System.out.println(i.getAndIncrement()); <span class="hljs-comment">//i++ 先打印1再自增</span><br><br>        System.out.println(i.getAndAdd(<span class="hljs-number">5</span>)); <span class="hljs-comment">//打印2，7</span><br>        System.out.println(i.addAndGet(<span class="hljs-number">5</span>)); <span class="hljs-comment">//12,打印12</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p><strong>updateAndGet()原理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test34</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">//             读取到    设置值</span><br>        i.updateAndGet(value -&gt; value * <span class="hljs-number">10</span>);<br>        System.out.println(i.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>手动实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test34</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        //             读取到    设置值</span><br><span class="hljs-comment">        i.updateAndGet(value -&gt; value * 10);</span><br><span class="hljs-comment">        System.out.println(i.get());</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//手动实现updateAndGet</span><br>        System.out.println(updateAndGet(i, p -&gt; p / <span class="hljs-number">2</span>));<br>        System.out.println(i.get());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateAndGet</span><span class="hljs-params">(AtomicInteger i, IntUnaryOperator operator)</span></span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">int</span> prev = i.get();<br>            <span class="hljs-keyword">int</span> next = operator.applyAsInt(prev);<br>            <span class="hljs-keyword">if</span> (i.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">return</span> next;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-2-原子引用"><a href="#6-3-2-原子引用" class="headerlink" title="6.3.2 原子引用"></a>6.3.2 原子引用</h3><p>为什么需要原子引用类型？–为了线程安全和高效</p><ul><li>AtomicReference</li><li>AtomicMarkableReference</li><li>AtomicStampedReference</li></ul><h4 id="6-3-2-1-安全实现-使用-CAS"><a href="#6-3-2-1-安全实现-使用-CAS" class="headerlink" title="6.3.2.1 安全实现-使用 CAS"></a>6.3.2.1 安全实现-使用 CAS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test35</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        DecimalAccountCas dac = <span class="hljs-keyword">new</span> DecimalAccountCas(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;10000&quot;</span>));<br>        DecimalAccount.demo(dac);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountCas</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(balance);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            BigDecimal prev = balance.get();<br>            BigDecimal next = prev.subtract(amount);<br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br>    <span class="hljs-comment">// 获取余额</span><br>    <span class="hljs-function">BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 取款</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(DecimalAccount account)</span> </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                account.withdraw(BigDecimal.TEN);<br>            &#125;));<br>        &#125;<br>        ts.forEach(Thread::start);<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        System.out.println(account.getBalance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="6-3-2-2-ABA问题"><a href="#6-3-2-2-ABA问题" class="headerlink" title="6.3.2.2 ABA问题"></a>6.3.2.2 ABA问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test36&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test36</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        <span class="hljs-comment">// 获取值 A</span><br>        <span class="hljs-comment">// 这个共享变量被它线程修改过？</span><br>        String prev = ref.get();<br>        other();<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 尝试改为 C</span><br>        log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;B&quot;</span>));<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        sleep(<span class="hljs-number">0.5</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;A&quot;</span>));<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">33</span>:<span class="hljs-number">55</span> [main] c.Test36 - main start...<br><span class="hljs-number">11</span>:<span class="hljs-number">33</span>:<span class="hljs-number">55</span> [t1] c.Test36 - change A-&gt;B <span class="hljs-keyword">true</span><br><span class="hljs-number">11</span>:<span class="hljs-number">33</span>:<span class="hljs-number">55</span> [t2] c.Test36 - change B-&gt;A <span class="hljs-keyword">true</span><br><span class="hljs-number">11</span>:<span class="hljs-number">33</span>:<span class="hljs-number">56</span> [main] c.Test36 - change A-&gt;C <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><blockquote><p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：</p><p>只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号</p></blockquote><h4 id="6-3-2-3-ASR"><a href="#6-3-2-3-ASR" class="headerlink" title="6.3.2.3 ASR"></a>6.3.2.3 ASR</h4><p><strong>AtomicStampedReference</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test36&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test36</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        <span class="hljs-comment">// 获取值 A</span><br>        <span class="hljs-comment">// 这个共享变量被它线程修改过？</span><br>        String prev = ref.getReference();<br>        <span class="hljs-comment">//main线程获取版本号</span><br>        <span class="hljs-keyword">int</span> stamp = ref.getStamp();<br>        log.debug(<span class="hljs-string">&quot;main线程在调用other()方法之前的stamp:&#123;&#125;&quot;</span>, stamp);<br>        other();<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 尝试改为 C</span><br>        log.debug(<span class="hljs-string">&quot;main线程在调用other()方法之后的stamp:&#123;&#125;&quot;</span>, stamp);<br>        log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">int</span> stamp = ref.getStamp();<br>            log.debug(<span class="hljs-string">&quot;t1线程获取stamp：&#123;&#125;&quot;</span>, stamp);<br>            log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">0.5</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">int</span> stamp = ref.getStamp();<br>            log.debug(<span class="hljs-string">&quot;t2线程获取stamp：&#123;&#125;&quot;</span>, stamp);<br>            log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">44</span> [main] c.Test36 - main start...<br><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">44</span> [main] c.Test36 - main线程在调用other()方法之前的stamp:<span class="hljs-number">0</span><br><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">44</span> [t1] c.Test36 - t1线程获取stamp：<span class="hljs-number">0</span><br><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">44</span> [t1] c.Test36 - change A-&gt;B <span class="hljs-keyword">true</span><br><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">44</span> [t2] c.Test36 - t2线程获取stamp：<span class="hljs-number">1</span><br><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">44</span> [t2] c.Test36 - change B-&gt;A <span class="hljs-keyword">true</span><br><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">45</span> [main] c.Test36 - main线程在调用other()方法之后的stamp:<span class="hljs-number">0</span><br><span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">45</span> [main] c.Test36 - change A-&gt;C <span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： <code>A -&gt; B -&gt; A -&gt; C</code> ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。</p><p>但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了AtomicMarkableReference</p><h4 id="6-3-2-4-AMR"><a href="#6-3-2-4-AMR" class="headerlink" title="6.3.2.4 AMR"></a>6.3.2.4 AMR</h4><pre><code class=" mermaid">graph TDs(保洁阿姨)m(主人)g1(垃圾袋)g2(新垃圾袋)s -. 倒空 .-&gt;g1m -- 检查 --&gt;g1g1 -- 已满 --&gt;g2g1 -- 还空 --&gt;g1</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GarbageBag</span> </span>&#123;<br>String desc;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GarbageBag</span><span class="hljs-params">(String desc)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.desc = desc;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDesc</span><span class="hljs-params">(String desc)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.desc = desc;<br>&#125;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString() + <span class="hljs-string">&quot; &quot;</span> + desc;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestABAAtomicMarkableReference</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>GarbageBag bag = <span class="hljs-keyword">new</span> GarbageBag(<span class="hljs-string">&quot;装满了垃圾&quot;</span>);<br><span class="hljs-comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span><br>AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(bag, <span class="hljs-keyword">true</span>);<br>log.debug(<span class="hljs-string">&quot;主线程 start...&quot;</span>);<br>GarbageBag prev = ref.getReference();<br>log.debug(prev.toString());<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;打扫卫生的线程 start...&quot;</span>);<br>bag.setDesc(<span class="hljs-string">&quot;空垃圾袋&quot;</span>);<br><span class="hljs-keyword">while</span> (!ref.compareAndSet(bag, bag, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>)) &#123;<br>&#125;<br>log.debug(bag.toString());<br>&#125;<br>).start();<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>log.debug(<span class="hljs-string">&quot;主线程想换一只新垃圾袋？&quot;</span>);<br>Boolean success = ref.compareAndSet(prev, <span class="hljs-keyword">new</span> GarbageBag(<span class="hljs-string">&quot;空垃圾袋&quot;</span>), <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>log.debug(<span class="hljs-string">&quot;换了么？&quot;</span> + success);<br>log.debug(ref.getReference().toString());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">09.264</span> [main] 主线程 start... <br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">09.270</span> [main] cn.itcast.GarbageBag@5f0fd5a0 装满了垃圾<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">09.293</span> [Thread-<span class="hljs-number">1</span>] 打扫卫生的线程 start... <br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">09.294</span> [Thread-<span class="hljs-number">1</span>] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">10.294</span> [main] 主线程想换一只新垃圾袋？<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">10.294</span> [main] 换了么？<span class="hljs-keyword">false</span> <br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">10.294</span> [main] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋<br></code></pre></td></tr></table></figure><h3 id="6-3-3-原子数组"><a href="#6-3-3-原子数组" class="headerlink" title="6.3.3 原子数组"></a>6.3.3 原子数组</h3><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test39</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//不安全数组</span><br>        demo(<br>                () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>],<br>                (array) -&gt; array.length,<br>                (array, index) -&gt; array[index]++,<br>                array -&gt; System.out.println(Arrays.toString(array))<br>        );<br><span class="hljs-comment">//原子数组</span><br>        demo(<br>                () -&gt; <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>),<br>                (array) -&gt; array.length(),<br>                (array, index) -&gt; array.getAndIncrement(index),<br>                array -&gt; System.out.println(array)<br>        );<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 参数1，提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment">     * 参数2，获取数组长度的方法</span><br><span class="hljs-comment">     * 参数3，自增方法，回传 array, index</span><br><span class="hljs-comment">     * 参数4，打印数组的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// supplier 提供者 无中生有  ()-&gt;结果</span><br>    <span class="hljs-comment">// function 函数   一个参数一个结果   (参数)-&gt;结果  ,  BiFunction (参数1,参数2)-&gt;结果</span><br>    <span class="hljs-comment">// consumer 消费者 一个参数没结果  (参数)-&gt;void,      BiConsumer (参数1,参数2)-&gt;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            Supplier&lt;T&gt; arraySupplier,</span></span><br><span class="hljs-params"><span class="hljs-function">            Function&lt;T, Integer&gt; lengthFun,</span></span><br><span class="hljs-params"><span class="hljs-function">            BiConsumer&lt;T, Integer&gt; putConsumer,</span></span><br><span class="hljs-params"><span class="hljs-function">            Consumer&lt;T&gt; printConsumer)</span> </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        T array = arraySupplier.get();<br>        <span class="hljs-keyword">int</span> length = lengthFun.apply(array);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-comment">// 每个线程对数组作 10000 次操作</span><br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    putConsumer.accept(array, j % length);<br>                &#125;<br>            &#125;));<br>        &#125;<br><br>        ts.forEach(t -&gt; t.start()); <span class="hljs-comment">// 启动所有线程</span><br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);     <span class="hljs-comment">// 等所有线程结束</span><br>        printConsumer.accept(array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>]<br></code></pre></td></tr></table></figure><h3 id="6-3-4-字段更新器"><a href="#6-3-4-字段更新器" class="headerlink" title="6.3.4 字段更新器"></a>6.3.4 字段更新器</h3><ul><li>AtomicReferenceFieldUpdater // 域 字段</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Must be <span class="hljs-keyword">volatile</span> type<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test40&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test40</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student stu = <span class="hljs-keyword">new</span> Student();<br><br>        AtomicReferenceFieldUpdater updater =<br>                AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);<br><br>        System.out.println(updater.compareAndSet(stu, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;张三&quot;</span>));<br>        System.out.println(stu);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> String name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">true</span><br>Student&#123;name=<span class="hljs-string">&#x27;张三&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-5-原子累加器"><a href="#6-3-5-原子累加器" class="headerlink" title="6.3.5 原子累加器"></a>6.3.5 原子累加器</h3><h4 id="6-3-5-1-累加器性能比较"><a href="#6-3-5-1-累加器性能比较" class="headerlink" title="6.3.5.1 累加器性能比较"></a>6.3.5.1 累加器性能比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test41</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(<br>                    () -&gt; <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>),<br>                    (adder) -&gt; adder.getAndIncrement()<br>            );<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(<br>                    () -&gt; <span class="hljs-keyword">new</span> LongAdder(),<br>                    adder -&gt; adder.increment()<br>            );<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    () -&gt; 结果    提供累加器对象</span><br><span class="hljs-comment">    (参数) -&gt;     执行累加操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> </span>&#123;<br>        T adder = adderSupplier.get();<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 4 个线程，每人累加 50 万</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">500000</span>; j++) &#123;<br>                    action.accept(adder);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        ts.forEach(t -&gt; t.start());<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(adder + <span class="hljs-string">&quot; cost:&quot;</span> + (end - start) / <span class="hljs-number">1000_000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1000000</span> cost:<span class="hljs-number">31</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">27</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">28</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">24</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">22</span><br><br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">43</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">9</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">7</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">7</span> <br><span class="hljs-number">1000000</span> cost:<span class="hljs-number">7</span> <br></code></pre></td></tr></table></figure><p>性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p><h4 id="6-3-5-2-源码之LongAdder"><a href="#6-3-5-2-源码之LongAdder" class="headerlink" title="6.3.5.2 *源码之LongAdder"></a>6.3.5.2 *源码之LongAdder</h4><p>LongAdder 是并发大师 @author Doug Lea （大哥李）的作品，设计的非常精巧<br>LongAdder 类有几个关键域:</p><p>transient是为了防止序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 累加单元数组, 懒惰初始化</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br><span class="hljs-comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> base;<br><span class="hljs-comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> cellsBusy;<br></code></pre></td></tr></table></figure><h4 id="6-3-5-3-CAS实现锁"><a href="#6-3-5-3-CAS实现锁" class="headerlink" title="6.3.5.3 CAS实现锁"></a>6.3.5.3 CAS实现锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test42&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockCas</span> </span>&#123;<br>    <span class="hljs-comment">// 0 没加锁</span><br>    <span class="hljs-comment">// 1 加锁</span><br>    <span class="hljs-keyword">private</span> AtomicInteger state = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (state.compareAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;unlock...&quot;</span>);<br>        state.set(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LockCas lock = <span class="hljs-keyword">new</span> LockCas();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;lock...&quot;</span>);<br>                sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;lock...&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">07.198</span> c.Test42 [Thread-<span class="hljs-number">0</span>] - begin... <br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">07.202</span> c.Test42 [Thread-<span class="hljs-number">0</span>] - lock... <br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">07.198</span> c.Test42 [Thread-<span class="hljs-number">1</span>] - begin... <br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">08.204</span> c.Test42 [Thread-<span class="hljs-number">0</span>] - unlock... <br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">08.204</span> c.Test42 [Thread-<span class="hljs-number">1</span>] - lock... <br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">08.204</span> c.Test42 [Thread-<span class="hljs-number">1</span>] - unlock...<br></code></pre></td></tr></table></figure><h4 id="6-3-5-4-原理之为伪共享"><a href="#6-3-5-4-原理之为伪共享" class="headerlink" title="6.3.5.4 *原理之为伪共享"></a>6.3.5.4 *原理之为伪共享</h4><p><a href="https://zhuanlan.zhihu.com/p/135462276">CPU中的缓存、缓存一致性、伪共享和缓存行填充 - 破执的文章 - 知乎</a></p><p>其中 Cell 即为累加单元</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 防止缓存行伪共享</span><br><span class="hljs-meta">@sun</span>.misc.Contended<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cell</span> </span>&#123;<br><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> value;<br>Cell(<span class="hljs-keyword">long</span> x) &#123;<br>value = x;<br>&#125;<br><span class="hljs-comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> Boolean <span class="hljs-title">cas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> prev, <span class="hljs-keyword">long</span> next)</span> </span>&#123;<br><span class="hljs-keyword">return</span> UNSAFE.compareAndSwaplong(<span class="hljs-keyword">this</span>, valueOffset, prev, next);<br>&#125;<br><span class="hljs-comment">// 省略不重要代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>得从缓存说起</p><p>缓存与内存的速度比较</p><p><img src="http://image.cryptomartin.top/img/image-20220104165053031.png" alt="image-20220104165053031"></p><p><img src="http://image.cryptomartin.top/img/image-20220104165105291.png" alt="image-20220104165105291"></p><p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。<br>而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long）<br>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中<br>CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效</p><p><img src="http://image.cryptomartin.top/img/image-20220104165532132.png" alt="image-20220104165532132"></p><p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p><ul><li>Core-0 要修改 Cell[0]</li><li>Core-1 要修改 Cell[1]</li></ul><p>无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 <code>Cell[0]=6000, Cell[1]=8000</code> 要累加<code>Cell[0]=6001, Cell[1]=8000</code> ，这时会让 Core-1 的缓存行失效</p><p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效—为什么是128字节，不太懂。总之是填充，让累计单元数组不在同一个缓存行中。</p><p><img src="http://image.cryptomartin.top/img/image-20220104170215432.png" alt="image-20220104170215432"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;<br><span class="hljs-comment">// as 为累加单元数组</span><br><span class="hljs-comment">// b 为基础值</span><br><span class="hljs-comment">// x 为累加值</span><br>Cell[] as;<br><span class="hljs-keyword">long</span> b, v;<br><span class="hljs-keyword">int</span> m;<br>Cell a;<br><span class="hljs-comment">// 进入 if 的两个条件</span><br><span class="hljs-comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span><br><span class="hljs-comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span><br><span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;<br><span class="hljs-comment">// uncontended 表示 cell 没有竞争</span><br>Boolean uncontended = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">if</span> (<br> <span class="hljs-comment">// as 还没有创建</span><br>as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br> <span class="hljs-comment">// 当前线程对应的 cell 还没有</span><br>(a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||<br> <span class="hljs-comment">// cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span><br>!(uncontended = a.cas(v = a.value, v + x))<br> ) &#123;<br><span class="hljs-comment">// 进入 cell 数组创建、cell 创建的流程</span><br>longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20220104171057811.png" alt="image-20220104171057811"></p><p><strong>longAccumulate</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">longAccumulate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, LongBinaryOperator fn,</span></span><br><span class="hljs-params"><span class="hljs-function"> Boolean wasUncontended)</span> </span>&#123;<br><span class="hljs-keyword">int</span> h;<br><span class="hljs-comment">// 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell</span><br><span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 初始化 probe</span><br>ThreadLocalRandom.current();<br><span class="hljs-comment">// h 对应新的 probe 值, 用来对应 cell</span><br>h = getProbe();<br>wasUncontended = <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-comment">// collide 为 true 表示需要扩容</span><br>Boolean collide = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">for</span> (;;) &#123;<br>Cell[] as;<br>Cell a;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">long</span> v;<br><span class="hljs-comment">// 已经有了 cells</span><br><span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 还没有 cell</span><br><span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x</span><br><span class="hljs-comment">// 成功则 break, 否则继续 continue 循环</span><br>&#125;<br><span class="hljs-comment">// 有竞争, 改变线程对应的 cell 来重试 cas else if (!wasUncontended)</span><br> wasUncontended = <span class="hljs-keyword">true</span>;<br><span class="hljs-comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAslong(v, x))))</span><br> <span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas else if (n &gt;= NCPU || cells != as)</span><br> collide = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了 else if (!collide)</span><br> collide = <span class="hljs-keyword">true</span>;<br><span class="hljs-comment">// 加锁 else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;</span><br><span class="hljs-comment">// 加锁成功, 扩容</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">// 改变线程对应的 cell</span><br>h = advanceProbe(h);<br>&#125;<br><span class="hljs-comment">// 还没有 cells, 尝试给 cellsBusy 加锁 else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="hljs-comment">// 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell</span><br><span class="hljs-comment">// 成功则 break;</span><br>&#125;<br><span class="hljs-comment">// 上两种情况失败, 尝试给 base 累加 else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAslong(v, x))))</span><br> <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20220104215525524.png" alt="image-20220104215525524"></p><p><img src="http://image.cryptomartin.top/img/image-20220104215534207.png" alt="image-20220104215534207"></p><p><img src="http://image.cryptomartin.top/img/image-20220104215542435.png" alt="image-20220104215542435"></p><p>获取最终结果通过 sum 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>&#123;<br>Cell[] as = cells;<br>Cell a;<br><span class="hljs-keyword">long</span> sum = base;<br><span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br><span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)<br> sum += a.value;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-4-Unsafe"><a href="#6-4-Unsafe" class="headerlink" title="6.4 Unsafe"></a>6.4 Unsafe</h2><h3 id="6-4-1-概述"><a href="#6-4-1-概述" class="headerlink" title="6.4.1 概述"></a>6.4.1 概述</h3><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestUnsafe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;<br>        Field theUnsafe = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        theUnsafe.setAccessible(<span class="hljs-keyword">true</span>);<br>        Unsafe unsafe= (Unsafe)theUnsafe.get(<span class="hljs-keyword">null</span>);<br><br>        System.out.println(unsafe);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sun.misc.Unsafe@2503dbd3<br></code></pre></td></tr></table></figure><h3 id="6-4-2-Unsafe-CAS-操作"><a href="#6-4-2-Unsafe-CAS-操作" class="headerlink" title="6.4.2 Unsafe CAS 操作"></a>6.4.2 Unsafe CAS 操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestUnsafe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;<br>        Field theUnsafe = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        theUnsafe.setAccessible(<span class="hljs-keyword">true</span>);<br>        Unsafe unsafe = (Unsafe) theUnsafe.get(<span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">// 获得成员变量的偏移量</span><br>        <span class="hljs-keyword">long</span> idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>));<br>        <span class="hljs-keyword">long</span> nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>));<br>        <span class="hljs-comment">// CAS操作</span><br>        Teacher teacher = <span class="hljs-keyword">new</span> Teacher();<br>        unsafe.compareAndSwapInt(teacher, idOffset, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        unsafe.compareAndSwapObject(teacher, nameOffset, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br><br>        <span class="hljs-comment">//验证</span><br>        System.out.println(teacher);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">volatile</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Teacher(id=<span class="hljs-number">1</span>, name=张三)<br></code></pre></td></tr></table></figure><h3 id="6-4-3-Unsafe模拟原子整数"><a href="#6-4-3-Unsafe模拟原子整数" class="headerlink" title="6.4.3 Unsafe模拟原子整数"></a>6.4.3 Unsafe模拟原子整数</h3><p>使用自定义的 AtomicData 实现之前线程安全的原子整数 Account 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicData</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> data;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> DATA_OFFSET;<br><span class="hljs-keyword">static</span> &#123;<br>unsafe = UnsafeAccessor.getUnsafe();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性</span><br>DATA_OFFSET = unsafe.objectFieldOffset(AtomicData.class.getDeclaredField(<span class="hljs-string">&quot;data&quot;</span>));<br>&#125;<br><span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AtomicData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.data = data;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br><span class="hljs-keyword">int</span> oldValue;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-comment">// 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解</span><br>oldValue = data;<br><span class="hljs-comment">// cas 尝试修改 data 为 旧值 + amount，如果期间旧值被别的线程改了，返回 false</span><br><span class="hljs-keyword">if</span> (unsafe.compareAndSwapint(<span class="hljs-keyword">this</span>, DATA_OFFSET, oldValue, oldValue - amount)) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> data;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>account实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Account.demo(<span class="hljs-keyword">new</span> Account() &#123;<br>AtomicData atomicData = <span class="hljs-keyword">new</span> AtomicData(<span class="hljs-number">10000</span>);<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> atomicData.getData();<br>&#125;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>atomicData.decrease(amount);<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="6-5-本章小结"><a href="#6-5-本章小结" class="headerlink" title="6.5 本章小结"></a>6.5 本章小结</h2><ul><li>CAS 与 volatile</li><li>API<ul><li>原子整数</li><li>原子引用</li><li>原子数组</li><li>字段更新器</li><li>原子累加器</li></ul></li><li>Unsafe</li><li>*原理方面<ul><li>LongAdder 源码</li><li>伪共享</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第五章 共享模型之内存</title>
    <link href="/2022/02/01/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98/"/>
    <url>/2022/02/01/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="第五章-共享模型之内存"><a href="#第五章-共享模型之内存" class="headerlink" title="第五章 共享模型之内存"></a>第五章 共享模型之内存</h1><p>上一章讲解的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性</p><p>这一章我们进一步深入学习共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题</p><h2 id="5-1-Java内存模型"><a href="#5-1-Java内存模型" class="headerlink" title="5.1 Java内存模型"></a>5.1 Java内存模型</h2><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。主要是简化复杂的底层的管理。</p><blockquote><p>主存：指所有线程共享的数据，包括静态成员变量，成员变量等<br>工作内存：指每个线程私有的数据，对应局部变量。</p></blockquote><p>JMM 体现在以下几个方面：</p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h2 id="5-2-可见性"><a href="#5-2-可见性" class="headerlink" title="5.2 可见性"></a>5.2 可见性</h2><h3 id="5-2-1-引出问题-退不出的循环"><a href="#5-2-1-引出问题-退不出的循环" class="headerlink" title="5.2.1 引出问题-退不出的循环"></a>5.2.1 引出问题-退不出的循环</h3><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Thread t = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">while</span>(run)&#123;<br><span class="hljs-comment">// ....</span><br>&#125;<br>&#125;<br>);<br>    <br>t.start();<br>sleep(<span class="hljs-number">1</span>);<br>run = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 线程t不会如预想的停下来</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-2-分析问题"><a href="#5-2-2-分析问题" class="headerlink" title="5.2.2 分析问题"></a>5.2.2 分析问题</h3><p>为什么呢？分析一下：</p><ol><li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。<br><img src="http://image.cryptomartin.top/img/image-20220101095311191.png" alt="image-20220101095311191"></li></ol><ol start="2"><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至t线程工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率<br><img src="http://image.cryptomartin.top/img/image-20220101095504243.png" alt="image-20220101095504243"></li></ol><ol start="3"><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li></ol><p><img src="http://image.cryptomartin.top/img/image-20220101095705858.png" alt="image-20220101095705858"></p><h3 id="5-2-3-解决问题"><a href="#5-2-3-解决问题" class="headerlink" title="5.2.3 解决问题"></a>5.2.3 解决问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<br></code></pre></td></tr></table></figure><p><code>volatile</code>（易变关键字）</p><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p><p>也可以用<code>sychronized</code>,但是<code>sychronized</code>会创建monitor，实在属于重量级。而<code>volatile</code>属于轻量级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Thread t = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>sychronized(lock)&#123;<br>                <span class="hljs-keyword">if</span>(!run)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>&#125;<br>&#125;);<br>    <br>t.start();<br>sleep(<span class="hljs-number">1</span>);<br>    sychronized(lock)&#123;<br>        run = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-4-可见性与原子性"><a href="#5-2-4-可见性与原子性" class="headerlink" title="5.2.4 可见性与原子性"></a>5.2.4 可见性与原子性</h3><p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况。</p><p>上例从字节码理解是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic run <span class="hljs-comment">// 线程 t 获取 run true </span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true </span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true </span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true </span><br>putstatic run <span class="hljs-comment">// 线程 main 修改 run 为 false， 仅此一次</span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run false</span><br></code></pre></td></tr></table></figure><p>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到最新值，不能解决指令交错:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0 </span><br>getstatic i <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0 </span><br>    <br>getstatic i <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0 </span><br>iconst_1 <span class="hljs-comment">// 线程1-准备常量1 </span><br>iadd <span class="hljs-comment">// 线程1-自增 线程内i=1 </span><br>putstatic i <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1 </span><br>    <br>iconst_1 <span class="hljs-comment">// 线程2-准备常量1 </span><br>isub <span class="hljs-comment">// 线程2-自减 线程内i=-1 </span><br>putstatic i <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是</p><p>synchronized 是属于重量级操作，性能相对更低</p><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到</p><p>对 run 变量的修改了，想一想为什么？println()调用newLine(),newLine()中使用了synchronized。</p></blockquote><p><img src="http://image.cryptomartin.top/img/image-20220101103206363.png" alt="image-20220101103206363"></p><p><img src="http://image.cryptomartin.top/img/image-20220101103223788.png" alt="image-20220101103223788"></p><h3 id="5-2-5-【模式】模式之两阶段终止"><a href="#5-2-5-【模式】模式之两阶段终止" class="headerlink" title="5.2.5 【模式】模式之两阶段终止"></a>5.2.5 【模式】模式之两阶段终止</h3><p> 利用停止标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//监控类</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTermination2</span> </span>&#123;<br>    <span class="hljs-comment">// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</span><br>    <span class="hljs-comment">// 我们的例子中，即主线程把它修改为 true 对 t1 线程可见</span><br>    <span class="hljs-keyword">private</span> Thread monitor;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">//开启监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">//不断执行</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (stop) &#123;<br>                    <span class="hljs-comment">//如果被打断</span><br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//如果当前线程没有被打断,睡眠1秒</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    <span class="hljs-comment">//没被打断，且没有异常；记录日志</span><br>                    log.debug(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//开启线程</span><br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">//停止监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        stop = <span class="hljs-keyword">true</span>;<br>        monitor.interrupt(); <span class="hljs-comment">//sleep中，打断sleep</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        TwoPhaseTermination2 tpt = <span class="hljs-keyword">new</span> TwoPhaseTermination2();<br>        tpt.start();<br><br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        log.debug(<span class="hljs-string">&quot;停止监控&quot;</span>);<br>        tpt.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">16</span>:<span class="hljs-number">46</span>:<span class="hljs-number">49</span> [Thread-<span class="hljs-number">0</span>] c.TwoPhaseTermination - 执行监控记录<br><span class="hljs-number">16</span>:<span class="hljs-number">46</span>:<span class="hljs-number">50</span> [Thread-<span class="hljs-number">0</span>] c.TwoPhaseTermination - 执行监控记录<br><span class="hljs-number">16</span>:<span class="hljs-number">46</span>:<span class="hljs-number">51</span> [Thread-<span class="hljs-number">0</span>] c.TwoPhaseTermination - 执行监控记录<br><span class="hljs-number">16</span>:<span class="hljs-number">46</span>:<span class="hljs-number">51</span> [main] c.Test3 - 停止监控<br><span class="hljs-number">16</span>:<span class="hljs-number">46</span>:<span class="hljs-number">51</span> [Thread-<span class="hljs-number">0</span>] c.TwoPhaseTermination - 料理后事<br></code></pre></td></tr></table></figure><h3 id="5-2-6-【模式】同步模式之Balking"><a href="#5-2-6-【模式】同步模式之Balking" class="headerlink" title="5.2.6 【模式】同步模式之Balking"></a>5.2.6 【模式】同步模式之Balking</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;<br>        TwoPhaseTermination2 tpt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TwoPhaseTermination2</span>();<br>        tpt.<span class="hljs-built_in">start</span>();<br>        tpt.<span class="hljs-built_in">start</span>();<br><br>        Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">3500</span>);<br>        log.<span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;停止监控&quot;</span>);<br>        tpt.<span class="hljs-built_in">stop</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><p>tpt启动了两次，就会出现线程安全问题。</p><h4 id="5-2-6-1定义"><a href="#5-2-6-1定义" class="headerlink" title="5.2.6.1定义"></a>5.2.6.1定义</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p><h4 id="5-2-6-2-实现"><a href="#5-2-6-2-实现" class="headerlink" title="5.2.6.2 实现"></a>5.2.6.2 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTermination2</span> </span>&#123;<br>    <span class="hljs-comment">// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</span><br>    <span class="hljs-comment">// 我们的例子中，即主线程把它修改为 true 对 t1 线程可见</span><br>    <span class="hljs-keyword">private</span> Thread monitor;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">//判断是否执行过start()方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">//开启监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//        if (starting) &#123; //t1:false,t2:false.对此代码做保护。volatile可不可以用？不行，两个线程都是先读再写，还是会有线程安全问题。保证原子性而不是可见性。</span><br><span class="hljs-comment">//            return;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        starting = true;</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123; <span class="hljs-comment">//t1:false,t2:false.对此代码做保护。</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            starting = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        monitor = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;...&#125;);<br>        <span class="hljs-comment">//开启线程</span><br>        monitor.start();<br>    &#125;<br>    ...<br>&#125;    <br></code></pre></td></tr></table></figure><h4 id="5-2-6-3-应用1-web-开始按钮"><a href="#5-2-6-3-应用1-web-开始按钮" class="headerlink" title="5.2.6.3 应用1-web 开始按钮"></a>5.2.6.3 应用1-web 开始按钮</h4><p>当前端页面多次点击按钮调用 start 时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonitorService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> starting; <br>    <span class="hljs-keyword">private</span> Thread monitorThread;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 缩小同步范围，提升性能</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;该监控线程已启动?(&#123;&#125;)&quot;</span>, starting);<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            starting = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 由于之前的 balking 模式，以下代码只可能被一个线程执行，因此无需互斥</span><br>        monitorThread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (!stop) &#123;<br>                report();<br>                sleep(<span class="hljs-number">2</span>);<br>            &#125;<br>            <span class="hljs-comment">// 这里的监控线程只可能启动一个，因此只需要用 volatile 保证 starting 的可见性</span><br>            log.info(<span class="hljs-string">&quot;监控线程已停止...&quot;</span>);<br>            starting = <span class="hljs-keyword">false</span>;<br>        &#125;);<br><br>        stop = <span class="hljs-keyword">false</span>;<br>        log.info(<span class="hljs-string">&quot;监控线程已启动...&quot;</span>);<br>        monitorThread.start();<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-6-4-应用2-单例模式DCL"><a href="#5-2-6-4-应用2-单例模式DCL" class="headerlink" title="5.2.6.4 应用2-单例模式DCL"></a>5.2.6.4 应用2-单例模式DCL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br>    <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//balking模式，synchronized保证只创建一个。</span><br><span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>        <br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对比一下保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待。</p></blockquote><h2 id="5-3-有序性"><a href="#5-3-有序性" class="headerlink" title="5.3 有序性"></a>5.3 有序性</h2><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j;<br><span class="hljs-comment">// 在某个线程内执行如下赋值操作</span><br>i = ...; <br>j = ...;<br></code></pre></td></tr></table></figure><p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">i = ...; <br>j = ...;<br></code></pre></td></tr></table></figure><p>也可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">j = ...;<br>i = ...;<br></code></pre></td></tr></table></figure><p>这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。为什么要有重排指令这项优化呢？从 CPU</p><p>执行指令的原理来理解一下吧</p><h3 id="5-3-1-原理之指令级并行"><a href="#5-3-1-原理之指令级并行" class="headerlink" title="5.3.1 * 原理之指令级并行"></a>5.3.1 * 原理之指令级并行</h3><p>看《Java 并发编程的艺术》P21-P47</p><h3 id="5-3-2-指令重排导致诡异的结果"><a href="#5-3-2-指令重排导致诡异的结果" class="headerlink" title="5.3.2 指令重排导致诡异的结果"></a>5.3.2 指令重排导致诡异的结果</h3><p><strong>问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>Boolean ready = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(ready) &#123;<br>r.r1 = num + num;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r.r1 = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>num = <span class="hljs-number">2</span>;<br>ready = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？</p><p>有同学这么分析<br>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1<br>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1<br>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</p><p>但我告诉你，结果还有可能是 0 😁😁😁，信不信吧！<br>这种情况下是：线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2<br>相信很多人已经晕了 😵😵😵<br>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化。</p><p><strong>解决方法</strong></p><p>volatile 修饰的变量，可以禁用指令重排</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">volatile</span> Boolean ready = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(ready) &#123;<br>r.r1 = num + num;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r.r1 = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>num = <span class="hljs-number">2</span>;<br>ready = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>问：为什么不加在<code>int num=0;</code>上？</p><p>答：volatile 修饰 ready,在<code>ready=true;</code>之后会有写屏障，会保证它之前的代码不会排到它后面。所以加一个就行。</p></blockquote><h3 id="5-3-3-原理之-volatile"><a href="#5-3-3-原理之-volatile" class="headerlink" title="5.3.3 ***** 原理之 volatile"></a>5.3.3 ***** <strong>原理之</strong> volatile</h3><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence） </p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h4 id="5-3-3-1-如何保证可见性"><a href="#5-3-3-1-如何保证可见性" class="headerlink" title="5.3.3.1 如何保证可见性"></a>5.3.3.1 如何保证可见性</h4><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>num = <span class="hljs-number">2</span>;<br>ready = <span class="hljs-keyword">true</span>;<br><span class="hljs-comment">// ready 是 volatile 赋值带写屏障</span><br><span class="hljs-comment">// 赋值操作之后，加入一个写屏障；写屏障会把num和ready同步到主存中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br><span class="hljs-comment">// 读屏障</span><br><span class="hljs-comment">// ready 是 volatile 读取值带读屏障</span><br><span class="hljs-keyword">if</span>(ready) &#123;<br>r.r1 = num + num;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r.r1 = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20220103101002856.png" alt="image-20220103101002856"></p><h4 id="5-3-3-2-如何保证有序性"><a href="#5-3-3-2-如何保证有序性" class="headerlink" title="5.3.3.2 如何保证有序性"></a>5.3.3.2 如何保证有序性</h4><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后；</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前；</li></ul><p>但不能解决指令交错：</p><ul><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li><li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li></ul><p><img src="http://image.cryptomartin.top/img/image-20220103101558672.png" alt="image-20220103101558672"></p><blockquote><p>volatile只能保证有序性和可见性，不能保证原子性；</p><p>synchronized可以保证有序性、可见性、原子性。synchronized内部仍然会重排序。</p></blockquote><h4 id="5-3-3-3-double-checked-locking-问题"><a href="#5-3-3-3-double-checked-locking-问题" class="headerlink" title="5.3.3.3 double-checked locking 问题"></a>5.3.3.3 double-checked locking 问题</h4><p>以著名的 double-checked locking 单例模式为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// t2</span><br><span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span><br><span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br><span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// t1</span><br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的实现特点是：</p><ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li></ul><p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">3</span>: ifnonnull <span class="hljs-number">37</span><br><span class="hljs-number">6</span>: ldc #<span class="hljs-number">3</span> <span class="hljs-comment">// class cn/itcast/n5/Singleton</span><br><span class="hljs-number">8</span>: dup <span class="hljs-comment">//赋值一份类的引用指针，为了解锁用</span><br><span class="hljs-number">9</span>: astore_0 <br><span class="hljs-number">10</span>: monitorenter <span class="hljs-comment">//创建monitor对象，看看有没有owner,进行竞争</span><br><span class="hljs-number">11</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">14</span>: ifnonnull <span class="hljs-number">27</span><br><span class="hljs-number">17</span>: <span class="hljs-keyword">new</span> #<span class="hljs-number">3</span> <span class="hljs-comment">// class cn/itcast/n5/Singleton</span><br><span class="hljs-number">20</span>: dup <span class="hljs-comment">//赋值引用</span><br><span class="hljs-number">21</span>: invokespecial #<span class="hljs-number">4</span> <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V ;通过引用创建构造方法</span><br><span class="hljs-number">24</span>: putstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton; 将new Singleton()的引用指针赋值给静态变量INSTANCE</span><br><span class="hljs-number">27</span>: aload_0<br><span class="hljs-number">28</span>: monitorexit<br><span class="hljs-number">29</span>: goto <span class="hljs-number">37</span><br><span class="hljs-number">32</span>: astore_1<br><span class="hljs-number">33</span>: aload_0<br><span class="hljs-number">34</span>: monitorexit<br><span class="hljs-number">35</span>: aload_1<br><span class="hljs-number">36</span>: athrow<br><span class="hljs-number">37</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">40</span>: areturn<br></code></pre></td></tr></table></figure><p>其中</p><ul><li>17 表示创建对象，将对象引用入栈 // new Singleton</li><li>20 表示复制一份对象引用 // 引用地址</li><li>21 表示利用一个对象引用，调用构造方法</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><blockquote><p>临界区内部还会进行指令重排序，临界区只保证临界区执行前后的指令不会重排序</p><p>INSTANCE = new Singleton(); </p><p>说人话就是：</p><p>a.JVM为对象分配一块内存M</p><p>b.在内存M上为对象进行初始化</p><p>c.将内存的地址复制给singleton变量</p></blockquote><p><a href="https://juejin.cn/post/6844903920599302152">文章写得很清楚关于为什么要加volatile</a></p><p>也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：</p><p><img src="http://image.cryptomartin.top/img/image-20220103145517349.png" alt="image-20220103145517349"></p><p>关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取INSTANCE 变量的值</p><p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例</p><p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p><blockquote><p>完全把共享变量交给synchronized来管理，不会有 有序性问题的。</p><p>上面例子，共享变量没有完全被synchronized的保护。</p></blockquote><h4 id="5-3-3-4-double-checked-locking-解决-加volatile"><a href="#5-3-3-4-double-checked-locking-解决-加volatile" class="headerlink" title="5.3.3.4 double-checked locking 解决-加volatile"></a>5.3.3.4 double-checked locking 解决-加volatile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span><br><span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br><span class="hljs-comment">// t2</span><br><span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次</span><br><span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// t1</span><br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码上看不出来 volatile 指令的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障</span><br><span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br>    <span class="hljs-number">3</span>: ifnonnull <span class="hljs-number">37</span><br><span class="hljs-number">6</span>: ldc #<span class="hljs-number">3</span> <span class="hljs-comment">// class cn/itcast/n5/Singleton</span><br><span class="hljs-number">8</span>: dup<br><span class="hljs-number">9</span>: astore_0<br><span class="hljs-number">10</span>: monitorenter -----------------------&gt; 保证原子性、可见性<br><span class="hljs-number">11</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">14</span>: ifnonnull <span class="hljs-number">27</span><br><span class="hljs-number">17</span>: <span class="hljs-keyword">new</span> #<span class="hljs-number">3</span> <span class="hljs-comment">// class cn/itcast/n5/Singleton</span><br><span class="hljs-number">20</span>: dup<br><span class="hljs-number">21</span>: invokespecial #<span class="hljs-number">4</span> <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-number">24</span>: putstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障</span><br><span class="hljs-number">27</span>: aload_0<br><span class="hljs-number">28</span>: monitorexit ------------------------&gt; 保证原子性、可见性<br><span class="hljs-number">29</span>: goto <span class="hljs-number">37</span><br><span class="hljs-number">32</span>: astore_1<br><span class="hljs-number">33</span>: aload_0<br><span class="hljs-number">34</span>: monitorexit<br><span class="hljs-number">35</span>: aload_1<br><span class="hljs-number">36</span>: athrow<br><span class="hljs-number">37</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">40</span>: areturn<br></code></pre></td></tr></table></figure><p>如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点：</p><p>可见性</p><ul><li>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中</li><li>而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li></ul><p>有序性</p><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul><p>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性</p><p><img src="http://image.cryptomartin.top/img/image-20220103150835646.png" alt="image-20220103150835646"></p><h3 id="5-3-4-happens-before"><a href="#5-3-4-happens-before" class="headerlink" title="5.3.4 happens-before"></a>5.3.4 happens-before</h3><p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><ul><li>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">static</span> Object m = <span class="hljs-keyword">new</span> Object();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">synchronized</span>(m) &#123;<br>x = <span class="hljs-number">10</span>;<br>&#125;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">synchronized</span>(m) &#123;<br>System.out.println(x);<br>&#125;<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><ul><li>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><ul><li>线程 start 前对变量的写，对该线程开始后对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x; <br>x = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><ul><li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br>t1.join();<br>System.out.println(x);<br></code></pre></td></tr></table></figure><ul><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <br>Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>System.out.println(x);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br>    <br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>sleep(<span class="hljs-number">1</span>);<br>x = <span class="hljs-number">10</span>;<br>t2.interrupt();<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>    <br><span class="hljs-keyword">while</span>(!t2.isInterrupted()) &#123;<br>Thread.yield();<br>&#125;<br>System.out.println(x);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p></li><li><p>具有传递性，如果 <code>x hb-&gt; y</code> 并且 <code>y hb-&gt; z</code> 那么有 <code>x hb-&gt; z</code> ，配合 volatile 的防指令重排，有下面的例子</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> y;<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123; <br> y = <span class="hljs-number">10</span>;<br> x = <span class="hljs-number">20</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> <span class="hljs-comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见</span><br> System.out.println(x); <br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start()<br></code></pre></td></tr></table></figure><h2 id="5-4-习题"><a href="#5-4-习题" class="headerlink" title="5.4 习题"></a>5.4 习题</h2><h3 id="5-4-1-balking-模式习题"><a href="#5-4-1-balking-模式习题" class="headerlink" title="5.4.1 balking 模式习题"></a>5.4.1 balking 模式习题</h3><p>希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestVolatile</span> </span>&#123;<br><span class="hljs-keyword">volatile</span> Boolean initialized = <span class="hljs-keyword">false</span>;<br>    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (initialized) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>doInit();<br>initialized = <span class="hljs-keyword">true</span>;<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInit</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不能。volatile仅保证可见性有序性，不能保证原子性。</p><h3 id="5-4-2-线程安全单例习题"><a href="#5-4-2-线程安全单例习题" class="headerlink" title="5.4.2 线程安全单例习题"></a>5.4.2 线程安全单例习题</h3><p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance）时的线程安全，并思考注释中的问题</p><blockquote><p>饿汉式：类加载就会导致该单实例对象被创建<br>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></blockquote><p>实现1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：为什么加 final?因为怕子类不适当覆盖父类的方法，重写方法破坏单例</span><br><span class="hljs-comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例？实现了序列化接口，将来反序列化也会创建新对象。会破坏单例。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><span class="hljs-comment">// 问题3：为什么设置为私有? 是否能防止反射创建新的实例?防止别的类创建对象；不能，可以暴力反射。</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><span class="hljs-comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?能，静态成员变量是在类加载时完成的，线程安全的。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br><span class="hljs-comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。用方法封装可以实现更多的控制。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//问题2解决。反序列化时会调用readResolve()，重写此方法返回我们创建的单例。</span><br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：枚举单例是如何限制实例个数的--枚举类，静态成员变量。</span><br><span class="hljs-comment">// 问题2：枚举单例在创建时是否有并发问题--在类加载时完成的，线程安全。</span><br><span class="hljs-comment">// 问题3：枚举单例能否被反射破坏单例--不能</span><br><span class="hljs-comment">// 问题4：枚举单例能否被反序列化破坏单例--不能</span><br><span class="hljs-comment">// 问题5：枚举单例属于懒汉式还是饿汉式--饿汉式，类加载时完成</span><br><span class="hljs-comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做--加构造方法</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123; <br> INSTANCE; <br>&#125;<br></code></pre></td></tr></table></figure><p>实现3：懒汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">// 分析这里的线程安全, 并说明有什么缺点--锁粒度大，性能低</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>( INSTANCE != <span class="hljs-keyword">null</span> )&#123;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现4：DCL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><span class="hljs-comment">// 问题1：解释为什么要加 volatile ?--创建对象时，可能指令重排序。加volatile防止synchronized内指令重排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">// 问题2：对比实现3, 说出这样做的意义 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br><span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br><span class="hljs-comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗</span><br><span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// t2 </span><br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现5：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><span class="hljs-comment">// 问题1：属于懒汉式还是饿汉式--懒汉式</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>&#123;<span class="hljs-comment">//静态内部类</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>&#125;<br><span class="hljs-comment">// 问题2：在创建时是否有并发问题--</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-5-本章小结"><a href="#5-5-本章小结" class="headerlink" title="5.5 本章小结"></a>5.5 本章小结</h2><p>本章重点讲解了 JMM 中的</p><ul><li>可见性 - 由 JVM 缓存优化引起</li><li>有序性 - 由 JVM 指令重排序优化引起</li><li>happens-before 规则</li><li>原理方面<ul><li>CPU 指令并行</li><li>volatile</li></ul></li><li>模式方面<ul><li>两阶段终止模式的 volatile 改进</li><li>同步模式之 balking</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四章 共享模型之管程</title>
    <link href="/2021/12/31/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B/"/>
    <url>/2021/12/31/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第四章-共享模型之管程"><a href="#第四章-共享模型之管程" class="headerlink" title="第四章 共享模型之管程"></a>第四章 共享模型之管程</h1><p><strong>本章内容</strong></p><ul><li>共享问题</li><li>synchronized</li><li>线程安全分析</li><li>Monitor</li><li>wait/notify</li><li>线程状态转换</li><li>活跃性</li><li>Lock</li></ul><h2 id="4-1-共享带来的问题以及分析"><a href="#4-1-共享带来的问题以及分析" class="headerlink" title="4.1 共享带来的问题以及分析"></a>4.1 共享带来的问题以及分析</h2><h3 id="4-1-1-线程安全问题"><a href="#4-1-1-线程安全问题" class="headerlink" title="4.1.1 线程安全问题"></a>4.1.1 线程安全问题</h3><p><img src="http://image.cryptomartin.top/img/image-20211220230105719.png" alt="image-20211220230105719"></p><p><img src="http://image.cryptomartin.top/img/image-20211220230304785.png" alt="image-20211220230304785"></p><h3 id="4-1-2-上下文切换-分析"><a href="#4-1-2-上下文切换-分析" class="headerlink" title="4.1.2 上下文切换-分析"></a>4.1.2 上下文切换-分析</h3><p>两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？–不一定是0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            counter++;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            counter--;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>    <br>    t1.start();<br>    t2.start();<br>    t1.join();<br>    t2.join();<br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, counter);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">23</span>:<span class="hljs-number">05</span>:<span class="hljs-number">50</span><span class="hljs-meta"> [main] c.Test17 - 43</span><br></code></pre></td></tr></table></figure><hr><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理解，必须从字节码来进行分析</p><p>例如对于<code>i++</code> 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic i <span class="hljs-comment">// 获取静态变量i的值</span><br>iconst_1 <span class="hljs-comment">// 准备常量1</span><br>iadd <span class="hljs-comment">// 自增</span><br>putstatic i <span class="hljs-comment">// 将修改后的值存入静态变量i</span><br></code></pre></td></tr></table></figure><p>而对应 <code>i--</code> 也是类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic i <span class="hljs-comment">// 获取静态变量i的值</span><br>iconst_1 <span class="hljs-comment">// 准备常量1</span><br>isub <span class="hljs-comment">// 自减</span><br>putstatic i <span class="hljs-comment">// 将修改后的值存入静态变量i</span><br></code></pre></td></tr></table></figure><p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：</p><p><img src="http://image.cryptomartin.top/img/image-20211220231346817.png" alt="image-20211220231346817"></p><p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：</p><p><img src="http://image.cryptomartin.top/img/image-20211220231419050.png" alt="image-20211220231419050"></p><p>但多线程下这 8 行代码可能交错运行：<br>出现负数的情况：</p><p><img src="http://image.cryptomartin.top/img/image-20211220231502024.png" alt="image-20211220231502024"></p><h3 id="4-1-3-临界区与竞态条件"><a href="#4-1-3-临界区与竞态条件" class="headerlink" title="4.1.3 临界区与竞态条件"></a>4.1.3 临界区与竞态条件</h3><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问共享资源<ul><li>多个线程读共享资源其实也没有问题</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区(Critical Section)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<span class="hljs-comment">//共享资源</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区</span></span><br><span class="hljs-function"></span>&#123;<br>counter++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区</span></span><br><span class="hljs-function"></span>&#123;<br>counter--;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>竞态条件</strong></p><p>多个线程在临界区内执行，由于代码的<strong>执行序列不同</strong>而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h2 id="4-2-解决共享带来的问题-synchronized解决方案"><a href="#4-2-解决共享带来的问题-synchronized解决方案" class="headerlink" title="4.2 解决共享带来的问题-synchronized解决方案"></a>4.2 解决共享带来的问题-synchronized解决方案</h2><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p><blockquote><p>注意<br>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li><li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li></ul></blockquote><h3 id="4-2-1-synchronized"><a href="#4-2-1-synchronized" class="headerlink" title="4.2.1 synchronized"></a>4.2.1 synchronized</h3><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) <span class="hljs-comment">// 线程1， 线程2(blocked)</span><br>&#123;<br> 临界区<br>&#125;<br></code></pre></td></tr></table></figure><p>解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test17&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test17</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//必须有一个共享的对象。因为synchronized关键字加锁必须由多个线程共享的对象来完成的。</span><br>    <span class="hljs-keyword">static</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-comment">//加锁</span><br>                <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                    counter++;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-comment">//加锁</span><br>                <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                    counter--;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, counter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>必须有一个共享的对象lock。因为synchronized关键字加锁必须由多个线程共享的对象来完成的。</li></ul><h3 id="4-2-2-synchronized的底层原理分析"><a href="#4-2-2-synchronized的底层原理分析" class="headerlink" title="4.2.2 synchronized的底层原理分析"></a>4.2.2 synchronized的底层原理分析</h3><p><img src="http://image.cryptomartin.top/img/image-20211221110418763.png" alt="image-20211221110418763"></p><p><strong>思考</strong></p><p>synchronized 实际是用<code>对象锁</code>保证了<code>临界区内代码的原子性</code>，临界区内的代码对外是不可分割的，不会被线程切<br>换所打断。</p><p>为了加深理解，请思考下面的问题:</p><ul><li>如果把 <code>synchronized(obj)</code> 放在 for 循环的外面，如何理解？– 原子性</li><li>如果 t1 <code>synchronized(obj1)</code> 而 <code>t2 synchronized(obj2)</code> 会怎样运作？不行。– 锁对象</li><li>如果 t1 <code>synchronized(obj)</code> 而 t2 没有加会怎么样？如何理解？不行– 锁对象</li></ul><h3 id="4-2-3-面向对象改进"><a href="#4-2-3-面向对象改进" class="headerlink" title="4.2.3 面向对象改进"></a>4.2.3 面向对象改进</h3><p>把需要保护的共享变量放入一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test17&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test17</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//创建Room对象</span><br>        Room room = <span class="hljs-keyword">new</span> Room();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-comment">//调用room的increment方法</span><br>                room.increment();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-comment">//调用room对象的decrement方法</span><br>                room.decrement();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, room.getCount());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Room</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            count--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-4-synchronized放在方法上"><a href="#4-2-4-synchronized放在方法上" class="headerlink" title="4.2.4 synchronized放在方法上"></a>4.2.4 synchronized放在方法上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br>&#125;<br>等价于<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br>&#125;<br>等价于<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(Test.class) &#123;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>public synchronized void test()</code>：<code>synchronized</code>加在非静态方法上，锁住的是<code>this对象</code></p></li><li><p><code>public synchronized static void test()</code>:<code>synchronized</code>加在静态方法上，锁住的是<code>类对象</code></p></li><li><p><code>this对象</code>是this所在方法的类对象，只有一个实例对象；<code>类对象</code>是整个类，可以有多个对象。synchronized修饰不加static的方法，锁是加在单个对象上，不同的对象没有竞争关系；修饰加了static的方法，锁是加载类上，这个类所有的对象竞争一把锁。</p></li></ul><h3 id="4-2-5-练习题-”线程八锁“"><a href="#4-2-5-练习题-”线程八锁“" class="headerlink" title="4.2.5 练习题-”线程八锁“"></a>4.2.5 练习题-”线程八锁“</h3><p>其实就是考察 synchronized 锁住的是哪个对象</p><h4 id="情况1：非静态方法加锁"><a href="#情况1：非静态方法加锁" class="headerlink" title="情况1：非静态方法加锁"></a>情况1：非静态方法加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test8Locks&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test8Locks</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Number n1 = <span class="hljs-keyword">new</span> Number();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 两个线程锁住的是同一个对象</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;开始线程&quot;</span>);<br>            n1.a();<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;开始线程&quot;</span>);<br>            n1.b();<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 为非static方法，锁住的是this对象-&gt;Number对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">11:41:27 [Thread-1] c.Test8Locks - 开始线程<br>11:41:27 [Thread-0] c.Test8Locks - 开始线程<br>11:41:27 [Thread-1] c.Number - 2<br>11:41:27 [Thread-0] c.Number - 1<br></code></pre></td></tr></table></figure><p>ps: <code>a()</code> 方法，<code>b()</code>方法加上了<code>synchronized</code></p><p>可能的结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">12或者21<br></code></pre></td></tr></table></figure><h4 id="情况2：添加sleep"><a href="#情况2：添加sleep" class="headerlink" title="情况2：添加sleep"></a>情况2：添加sleep</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Number n1 = <span class="hljs-keyword">new</span> Number();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>n1.a();<br>&#125;<br>).start();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>n1.b();<br>&#125;<br>).start();<br>&#125;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>sleep(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:在情况1的基础上，给<code>a()</code>方法睡眠了1秒钟</p><p>可能的结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1秒后 1 2<br>2 1秒后 1<br></code></pre></td></tr></table></figure><h4 id="情况3：添加一个c方法，不加锁"><a href="#情况3：添加一个c方法，不加锁" class="headerlink" title="情况3：添加一个c方法，不加锁"></a>情况3：添加一个c方法，不加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Number n1 = <span class="hljs-keyword">new</span> Number();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.b(); &#125;).start();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.c(); &#125;).start();<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;3&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps: 在情况3的基础上加了<code>c()</code>方法，没有加<code>synchronized</code></p><p>可能的结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">3 1秒后 12<br>32 1秒后 1<br>23 1秒后 1<br></code></pre></td></tr></table></figure><h4 id="情况4：两个线程调用不同的对象"><a href="#情况4：两个线程调用不同的对象" class="headerlink" title="情况4：两个线程调用不同的对象"></a>情况4：两个线程调用不同的对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Number n1 = <span class="hljs-keyword">new</span> Number();<br> Number n2 = <span class="hljs-keyword">new</span> Number();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:在情况2的基础上，创建一个新的Number对象。两个对象，锁住的对象不是同一个对象</p><p>可能的结果只有一种:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">2 1秒后 1<br></code></pre></td></tr></table></figure><h4 id="情况5：synchronized加在静态方法和非静态方法上"><a href="#情况5：synchronized加在静态方法和非静态方法上" class="headerlink" title="情况5：synchronized加在静态方法和非静态方法上"></a>情况5：synchronized加在静态方法和非静态方法上</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Number n1 = <span class="hljs-keyword">new</span> Number();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.b(); &#125;).start();<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:<code>a()</code>方法为非静态方法；<code>a()</code>方法锁住的是<code>整个Number对象</code>；而<code>b()</code>方法锁住的是<code>n1实例对象</code>;两个锁住的不是同一个对象</p><p>只有一种结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">2 1秒后 1<br></code></pre></td></tr></table></figure><h4 id="情况6：synchronized加在同一个类中的两个静态方法上"><a href="#情况6：synchronized加在同一个类中的两个静态方法上" class="headerlink" title="情况6：synchronized加在同一个类中的两个静态方法上"></a>情况6：synchronized加在同一个类中的两个静态方法上</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Number n1 = <span class="hljs-keyword">new</span> Number();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.b(); &#125;).start();<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps: <code>synchronized</code>加载非静态方法<code>a()</code>方法和<code>b()</code>方法上，则锁住的是同一个类对象<code>Number类对象</code>，类对象整个内存中只有一份。</p><p>可能的结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1秒后 12<br>2 1秒后 1<br></code></pre></td></tr></table></figure><h4 id="情况7：synchronized加在静态方法和非静态方法上，两个线程各自调用两个不同的实例"><a href="#情况7：synchronized加在静态方法和非静态方法上，两个线程各自调用两个不同的实例" class="headerlink" title="情况7：synchronized加在静态方法和非静态方法上，两个线程各自调用两个不同的实例"></a>情况7：synchronized加在静态方法和非静态方法上，两个线程各自调用两个不同的实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Number n1 = <span class="hljs-keyword">new</span> Number();<br> Number n2 = <span class="hljs-keyword">new</span> Number();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:<code>a()</code>方法是静态方法，锁住的是<code>Number类对象</code>；<code>b()</code>方法非静态方法，锁住的是<code>this对象</code>-&gt;<code>n2对象</code>；连个锁住的不是同一个对象</p><p>唯一的结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">2 1秒后 1<br></code></pre></td></tr></table></figure><h4 id="情况8：synchronized加在两个静态方法，两个线程各自调用两个不同的实例"><a href="#情况8：synchronized加在两个静态方法，两个线程各自调用两个不同的实例" class="headerlink" title="情况8：synchronized加在两个静态方法，两个线程各自调用两个不同的实例"></a>情况8：synchronized加在两个静态方法，两个线程各自调用两个不同的实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Number n1 = <span class="hljs-keyword">new</span> Number();<br> Number n2 = <span class="hljs-keyword">new</span> Number();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();<br> <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:<code>a()</code>方法，<code>b()</code>方法都是<code>static</code>,<code>synchronized</code>锁住的是<code>Number类对象</code>，为同一个对象；虽然创建了<code>n1</code>，<code>n2</code>对象，但是<code>线程1</code>调用时，锁住的是<code>Number类对象</code>，只有一个；由此可知，<code>线程2</code>调用时，锁住的是<code>Number类对象</code></p><p>可能的结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1秒后 1 2<br>2 1秒后 1<br></code></pre></td></tr></table></figure><h2 id="4-3-变量的线程安全分析"><a href="#4-3-变量的线程安全分析" class="headerlink" title="4.3 变量的线程安全分析"></a>4.3 变量的线程安全分析</h2><h3 id="4-3-1-线程安全分析"><a href="#4-3-1-线程安全分析" class="headerlink" title="4.3.1 线程安全分析"></a>4.3.1 线程安全分析</h3><p><strong>成员变量和静态变量是否线程安全？</strong></p><ul><li><p>如果没有变量没有在线程间共享，那么变量是安全的</p></li><li><p>如果变量在线程间共享</p><ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h3 id="4-3-2-局部变量是否线程安全？"><a href="#4-3-2-局部变量是否线程安全？" class="headerlink" title="4.3.2 局部变量是否线程安全？"></a>4.3.2 局部变量是否线程安全？</h3><ul><li>局部变量是线程安全的</li><li>但局部变量引用的对象则未必<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><p><strong>局部变量线程安全分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown">public static void test1();<br>descriptor: ()V<br> flags: ACC<span class="hljs-emphasis">_PUBLIC, ACC_</span>STATIC<br> Code:<br> stack=1, locals=1, args<span class="hljs-emphasis">_size=0</span><br><span class="hljs-emphasis"> 0: bipush 10</span><br><span class="hljs-emphasis"> 2: istore_</span>0<br> 3: iinc 0, 1<br> 6: return<br> LineNumberTable:<br> line 10: 0<br> line 11: 3<br> line 12: 6<br> LocalVariableTable:<br> Start Length Slot Name Signature<br> 3 4 0 i I<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20211221150447532.png" alt="image-20211221150447532"></p><blockquote><p>局部变量的引用稍有不同</p></blockquote><p>先看一个成员变量的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafe</span> </span>&#123;<br>    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//共享资源list</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-comment">// &#123; 临界区, 会产生竞态条件</span><br>            method2();<br>            method3();<br>            <span class="hljs-comment">// &#125; 临界区</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THREAD_NUMBER = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LOOP_NUMBER = <span class="hljs-number">200</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ThreadUnsafe test = <span class="hljs-keyword">new</span> ThreadUnsafe();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            test.method1(LOOP_NUMBER);<br>        &#125;<br>        , <span class="hljs-string">&quot;Thread&quot;</span> + i).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;Thread1&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IndexOutOfBoundsException</span>: Index: <span class="hljs-number">0</span>, Size: <span class="hljs-number">0</span> <br> at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.rangeCheck</span>(ArrayList<span class="hljs-selector-class">.java</span>:<span class="hljs-number">657</span>) <br> at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.remove</span>(ArrayList<span class="hljs-selector-class">.java</span>:<span class="hljs-number">496</span>) <br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n6</span><span class="hljs-selector-class">.ThreadUnsafe</span><span class="hljs-selector-class">.method3</span>(TestThreadSafe<span class="hljs-selector-class">.java</span>:<span class="hljs-number">35</span>) <br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n6</span><span class="hljs-selector-class">.ThreadUnsafe</span><span class="hljs-selector-class">.method1</span>(TestThreadSafe<span class="hljs-selector-class">.java</span>:<span class="hljs-number">26</span>) <br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n6</span><span class="hljs-selector-class">.TestThreadSafe</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(TestThreadSafe<span class="hljs-selector-class">.java</span>:<span class="hljs-number">14</span>) <br> at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">748</span>)<br></code></pre></td></tr></table></figure><ul><li>分析</li><li>无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量</li><li>method3 与 method2 分析相同</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211221152126278.png" alt="image-20211221152126278"></p><p>将 list 修改为局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//为局部变量</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么就不会有上述问题了</p><p>分析：</p><ul><li>list 是局部变量，每个线程调用时会创建其不同实例，没有共享</li><li>而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象</li><li>method3 的参数分析与 method2 相同</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211221152337025.png" alt="image-20211221152337025"></p><p>方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？</p><ul><li>情况1：有其它线程调用 method2 和 method3</li><li>情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span>/<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">private</span>/<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadSafe</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            list.remove(<span class="hljs-number">0</span>);<br>        &#125;<br>        ).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:子类<code>ThreadSafeSubClass</code>继承父类<code>ThreadSafe</code>，子类重写<code>method3(ArrayList&lt;String&gt; list)</code>方法;子类重写后，重新启动了一个新的线程，新的线程使用了<code>list</code>来执行一个<code>remove()</code>操作，会出现问题！</p><p>因为：假如<code>线程1</code>创建了一个<code>list</code>，当调用<code>method3(list);</code>时；此时，又有一个<code>新的线程2</code>，访问到了<code>线程1</code>创建的<code>list</code>;这个<code>list</code>对于<code>新的线程2</code>和<code>线程1</code>来说是一个共享的资源，所以会出现线程安全的问题。</p><p>问题分析：这个由于创建了子类，子类的方案不能由我们控制，子类可能另起一个新的线程，访问一些对象，造成了局部变量的引用暴露给其他线程，从而引起线程安全问题。</p><blockquote><p>一些启示：</p><p>方法的访问修饰符private是有意义的，一定程度上可以保护我们的线程安全</p><p>private限制了子类不能覆盖它</p><p>公共方法可以加个final，防止公共方法被子类影响行为，防止子类重写方法，导致线程安全问题</p></blockquote><h3 id="4-3-3-常见的线程安全类"><a href="#4-3-3-常见的线程安全类" class="headerlink" title="4.3.3  常见的线程安全类"></a>4.3.3  常见的线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为</p><ul><li>它们的每个方法是原子的</li><li>但注意它们多个方法的组合不是原子的，见后面分析</li></ul><h4 id="线程安全类方法的组合"><a href="#线程安全类方法的组合" class="headerlink" title="线程安全类方法的组合"></a>线程安全类方法的组合</h4><p>分析下面代码是否线程安全？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Hashtable table = <span class="hljs-keyword">new</span> Hashtable();<br><span class="hljs-comment">// 线程1，线程2</span><br><span class="hljs-keyword">if</span>( table.get(<span class="hljs-string">&quot;key&quot;</span>) == <span class="hljs-keyword">null</span>) &#123;<br> table.put(<span class="hljs-string">&quot;key&quot;</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20211221154636586.png" alt="image-20211221154636586"></p><p><code>Hashtable</code>的多个方法组合，导致<code>put</code>执行了两次，后一个结果把前一个给覆盖了。不是我们预期的效果。</p><h4 id="不可变类的线程安全性"><a href="#不可变类的线程安全性" class="headerlink" title="不可变类的线程安全性"></a>不可变类的线程安全性</h4><p>String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的</p><p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安</p><p>全的呢？<code>replace</code>，<code>substring </code>内部是新创建了一个String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Immutable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Immutable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想增加一个增加的方法呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Immutable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Immutable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Immutable <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Immutable(<span class="hljs-keyword">this</span>.value + v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-4-实例分析"><a href="#4-3-4-实例分析" class="headerlink" title="4.3.4 实例分析"></a>4.3.4 实例分析</h3><h4 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全？不是，HashMap线程不安全</span><br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">// 是否安全？是！不可变类</span><br>    String S1 = <span class="hljs-string">&quot;...&quot;</span>;<br>    <span class="hljs-comment">// 是否安全？是！</span><br>    <span class="hljs-keyword">final</span> String S2 = <span class="hljs-string">&quot;...&quot;</span>;<br>    <span class="hljs-comment">// 是否安全？不是，会被共享。</span><br>    Date D1 = <span class="hljs-keyword">new</span> Date();<br>    <span class="hljs-comment">// 是否安全？不是，final引用值不能变，但日期里的年月日是可以变的。</span><br>    <span class="hljs-keyword">final</span> Date D2 = <span class="hljs-keyword">new</span> Date();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用上述变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全？不安全！因为servlet只有一份，userService是我的成员变量，也只有一份；也是会有多个线程共享访问它。</span><br>    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        userService.update(...);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-comment">// 记录调用次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//属于共享资源</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...要做线程安全的保护！</span><br>        count++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:对提交到同一个servlet类的多个业务请求，共享一个servlet对象（即这个servlet类只被实例化一次）</p><h4 id="例3："><a href="#例3：" class="headerlink" title="例3："></a>例3：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全？不安全！spring里每家额外说明，每个对象都是单例的。单例，即被共享。里面的成员变量也是被共享的。因此有线程安全问题</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> start = <span class="hljs-number">0L</span>;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(* *(..))&quot;)</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        start = System.nanoTime(); <span class="hljs-comment">//开始时间</span><br>    &#125;<br>    <br>    <span class="hljs-meta">@After(&quot;execution(* *(..))&quot;)</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<span class="hljs-comment">//结束时间</span><br>        System.out.println(<span class="hljs-string">&quot;cost time:&quot;</span> + (end-start)); <span class="hljs-comment">//求一个差值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决办法：做成环绕通知。</p><h4 id="例4："><a href="#例4：" class="headerlink" title="例4："></a>例4：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全？线程安全！虽然有一个成员变量userService，但是userService是私有的，也没有其他地方能修改它，因此MyServlet属于不可变，线程安全。</span><br>    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        userService.update(...);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全？线程安全！虽然userDao是成员变量，被共享，但是userDao没有可更改的成员变量/属性--无状态</span><br>    <span class="hljs-keyword">private</span> UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        userDao.update();<br>    &#125;<br>&#125;<br><br> <span class="hljs-comment">// dao是否安全,线程安全！没有成员变量，即使多个线程访问，也没有能修改它的属性/状态。---无状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>        <span class="hljs-comment">// Connection是否安全,线程安全！Connection属于方法内的局部变量，多个线程访问，互不干扰。</span><br>        <span class="hljs-keyword">try</span> (Connection conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>))&#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例5："><a href="#例5：" class="headerlink" title="例5："></a>例5：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全？不安全！</span><br>    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        userService.update(...);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全？不安全！</span><br>    <span class="hljs-keyword">private</span> UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        userDao.update();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全?不安全！</span><br>    <span class="hljs-keyword">private</span> Connection conn = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>        conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// ...</span><br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:需要把<code>Connection</code>做成局部变量！</p><h4 id="例6："><a href="#例6：" class="headerlink" title="例6："></a>例6：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全</span><br>    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        userService.update(...);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<br>        userDao.update();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全</span><br>    <span class="hljs-keyword">private</span> Connection = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>        conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// ...</span><br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:例5和例6区别：<code>UserDao userDao = new UserDaoImpl();</code>例6每次调用都会创建一个新的<code>userDao</code> ,而不是把它当作service的成员变量。</p><p>此方法线程安全！<code>UserDao userDao = new UserDaoImpl();</code> <code>userDao</code>是作为方法内的局部变量存在的，所以：线程1调用<code>update()</code>会创建新的一个<code>userDao</code>,<code>UserDaoImpl</code>中的<code>Connection</code>也是新的；线程2调用<code>update()</code>会创建新的一个<code>userDao</code>,<code>UserDaoImpl</code>中的<code>Connection</code>也是新的！所以线程安全！</p><p>不推荐这种写法！</p><h4 id="例7："><a href="#例7：" class="headerlink" title="例7："></a>例7：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-comment">//抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title">foo</span><span class="hljs-params">(SimpleDateFormat sdf)</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Test().bar();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 是否安全？不安全！</span><br>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        foo(sdf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:有机会把局部变量的对象传递给抽象方法，可能存在子类有不恰当的行为！</p><p>其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为外星方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jav">public void foo(SimpleDateFormat sdf) &#123;<br>    String dateStr = &quot;1999-10-11 00:00:00&quot;;<br>    for (int i = 0; i &lt; 20; i++) &#123;<br>        new Thread(() -&gt; &#123;<br>            try &#123;<br>                sdf.parse(dateStr);<br>            &#125;<br>            catch (ParseException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        ).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就造成，子类新的线程，跟<code>bar()</code>方法的主线程并发访问了同一个<code>SimpleDateFormat</code>对象</p><h2 id="4-4-习题"><a href="#4-4-习题" class="headerlink" title="4.4 习题"></a>4.4 习题</h2><h3 id="4-4-1-买票练习"><a href="#4-4-1-买票练习" class="headerlink" title="4.4.1 买票练习"></a>4.4.1 买票练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.ExerciseSell&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExerciseSell</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        TicketWindow ticketWindow = <span class="hljs-keyword">new</span> TicketWindow(<span class="hljs-number">10000</span>);<br><br><br>        <span class="hljs-comment">// 用来存储买出去多少张票</span><br>        List&lt;Integer&gt; sellCount = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>        <span class="hljs-comment">//所有线程的集合</span><br>        List&lt;Thread&gt; threadList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++) &#123;<br>            Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-comment">// 分析这里的竞态条件</span><br>                <span class="hljs-keyword">int</span> count = ticketWindow.sell(randomAmount());<br>                sellCount.add(count);<br>            &#125;<br>            );<br>            threadList.add(t);<br>            t.start();<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 主线程必须等到所有线程运行结束，才统计数量</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span> (Thread thread : threadList) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                thread.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 买出去的票求和</span><br>        log.debug(<span class="hljs-string">&quot;买出去的票求和:&#123;&#125;&quot;</span>, sellCount.stream().mapToInt(c -&gt; c).sum());<br>        <span class="hljs-comment">// 剩余票数</span><br>        log.debug(<span class="hljs-string">&quot;剩余票数:&#123;&#125;&quot;</span>, ticketWindow.getCount());<br>    &#125;<br><br>    <span class="hljs-comment">// Random 为线程安全</span><br>    <span class="hljs-keyword">static</span> Random random = <span class="hljs-keyword">new</span> Random();<br><br>    <span class="hljs-comment">// 随机 1~5</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomAmount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> random.nextInt(<span class="hljs-number">5</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//售票窗口类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TicketWindow</span> </span>&#123;<br>    <span class="hljs-comment">//余票数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TicketWindow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.count = count;<br>    &#125;<br><br>    <span class="hljs-comment">//获取余票数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-comment">//售票，amount：购买数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sell</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &gt;= amount) &#123;<br>            <span class="hljs-keyword">this</span>.count -= amount;<br>            <span class="hljs-keyword">return</span> amount;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会出线程安全问题！</p><p>解决办法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//售票，amount：购买数量</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sell</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &gt;= amount) &#123;<br>        <span class="hljs-keyword">this</span>.count -= amount;<br>        <span class="hljs-keyword">return</span> amount;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-2-转账练习"><a href="#4-4-2-转账练习" class="headerlink" title="4.4.2 转账练习"></a>4.4.2 转账练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.ExerciseTransfer&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExerciseTransfer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Account a = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">1000</span>);<br>        Account b = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">1000</span>);<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                a.transfer(b, randomAmount());<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                b.transfer(a, randomAmount());<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br><br>        <span class="hljs-comment">// 查看转账2000次后的总金额</span><br>        log.debug(<span class="hljs-string">&quot;total:&#123;&#125;&quot;</span>, (a.getMoney() + b.getMoney()));<br>    &#125;<br><br>    <span class="hljs-comment">// Random 为线程安全</span><br>    <span class="hljs-keyword">static</span> Random random = <span class="hljs-keyword">new</span> Random();<br><br>    <span class="hljs-comment">// 随机 1~100</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomAmount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> random.nextInt(<span class="hljs-number">100</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> money;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Account</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMoney</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *a和b账户余额都需要保护；</span><br><span class="hljs-comment">     * 思路1：`transfer()`方法上加synchronized：这样不行！等价于锁住this对象，它只能保护this.money,无法保护target.money。</span><br><span class="hljs-comment">     * 改进思路：需要锁住this和target两个对象。--&gt; 锁住Account类！因为Account类是this和target共享的类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Account target, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (Account.class)&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.money &gt; amount) &#123;<br>                <span class="hljs-keyword">this</span>.setMoney(<span class="hljs-keyword">this</span>.getMoney() - amount);<br>                target.setMoney(target.getMoney() + amount);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">a和b账户余额都需要保护；<br>思路1：<span class="hljs-code">`transfer()`</span>方法上加synchronized：这样不行！等价于锁住this对象，它只能保护this.money,无法保护target.money。<br>改进思路：需要锁住this和target两个对象。--&gt; 锁住Account类！因为Account类是this和target共享的类<br></code></pre></td></tr></table></figure><h2 id="4-5-管程-Monitor"><a href="#4-5-管程-Monitor" class="headerlink" title="4.5 管程 Monitor"></a>4.5 管程 Monitor</h2><h3 id="4-5-1-Java-对象头"><a href="#4-5-1-Java-对象头" class="headerlink" title="4.5.1 Java 对象头"></a>4.5.1 Java 对象头</h3><p>以 32 位虚拟机为例</p><p>Integer 8+4=12</p><p>int 4Byte</p><p><strong>普通对象</strong></p><p>每个对象都有一个类型，例如<code>Student stu = new Student()</code>为<code>Student</code>类型。</p><p><code>Mark Word</code>：包含很多信息</p><p><code>Klass Word</code>：是一个指针，指向对应的Class类对象。</p><p><img src="http://image.cryptomartin.top/img/image-20211222093252680.png" alt="image-20211222093252680"></p><p><strong>数组对象</strong></p><p><img src="http://image.cryptomartin.top/img/image-20211222094149228.png" alt="image-20211222094149228"></p><p><img src="http://image.cryptomartin.top/img/image-20211222093646949.png" alt="image-20211222093646949"></p><p><strong>正常状态 Mark Word 结构</strong></p><ul><li><p><code>age</code>:垃圾回收时的分代年龄</p></li><li><p><code>biased_lock</code>:代表它是不是偏向锁</p></li><li><p><code>01</code>：代表加锁状态</p></li></ul><p><strong>其他状态Mark Word结构</strong></p><ul><li>会有相应改变</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211222094549510.png" alt="image-20211222094549510"></p><h3 id="4-5-2-Monitor-锁"><a href="#4-5-2-Monitor-锁" class="headerlink" title="4.5.2 Monitor(锁)"></a>4.5.2 Monitor(锁)</h3><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong></p><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p><p><img src="http://image.cryptomartin.top/img/image-20211222095808262.png" alt="image-20211222095808262"></p><ul><li>刚开始 Monitor 中 Owner 为 null</li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner</li><li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入EntryList BLOCKED</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲<br>wait-notify 时会分析</li></ul><blockquote><p>注意：</p><ul><li>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</li><li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li></ul></blockquote><h2 id="4-6-原理之synchronized"><a href="#4-6-原理之synchronized" class="headerlink" title="4.6 * 原理之synchronized"></a>4.6 * 原理之synchronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock=<span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        counter++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br> descriptor: ([Ljava/lang/String;)V<br> flags: ACC_PUBLIC, ACC_STATIC<br> Code:<br> stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// &lt;- lock引用 （synchronized开始）</span><br>         <span class="hljs-number">3</span>: dup<br>         <span class="hljs-number">4</span>: astore_1 <span class="hljs-comment">// lock引用 -&gt; slot 1,临时变量slot1，为了解锁是处理异常</span><br>                  <br>         <span class="hljs-comment">// synchronized (lock)    </span><br>         <span class="hljs-number">5</span>: monitorenter <span class="hljs-comment">// 将 lock对象 MarkWord 置为 Monitor 指针</span><br>         <span class="hljs-number">6</span>: getstatic #<span class="hljs-number">3</span> <span class="hljs-comment">// &lt;- i</span><br>         <span class="hljs-number">9</span>: iconst_1 <span class="hljs-comment">// 准备常数 1</span><br>         <span class="hljs-number">10</span>: iadd <span class="hljs-comment">// +1</span><br>         <span class="hljs-number">11</span>: putstatic #<span class="hljs-number">3</span> <span class="hljs-comment">// -&gt; i</span><br>         <span class="hljs-number">14</span>: aload_1 <span class="hljs-comment">// &lt;- lock引用</span><br>         <span class="hljs-number">15</span>: monitorexit <span class="hljs-comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList;Mark Word 存储Monitor指针，现在需要重新改为原来的信息，原来的信息都存在临时变量slot中。</span><br>         <span class="hljs-number">16</span>: goto <span class="hljs-number">24</span><br>                  <br>          <span class="hljs-comment">//同步代码快发生异常</span><br>         <span class="hljs-number">19</span>: astore_2 <span class="hljs-comment">// e -&gt; slot 2;异常对象给临时变量slot</span><br>         <span class="hljs-number">20</span>: aload_1 <span class="hljs-comment">// &lt;- lock引用</span><br>         <span class="hljs-number">21</span>: monitorexit <span class="hljs-comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span><br>         <span class="hljs-number">22</span>: aload_2 <span class="hljs-comment">// &lt;- slot 2 (e)</span><br>         <span class="hljs-number">23</span>: athrow <span class="hljs-comment">// throw e</span><br>         <span class="hljs-number">24</span>: <span class="hljs-keyword">return</span><br>         Exception table:<br>         from to target type<br>             <span class="hljs-number">6</span> <span class="hljs-number">16</span> <span class="hljs-number">19</span> any <span class="hljs-comment">//发现异常，到19行执行</span><br>             <span class="hljs-number">19</span> <span class="hljs-number">22</span> <span class="hljs-number">19</span> any<br>         LineNumberTable:<br>             line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>             line <span class="hljs-number">9</span>: <span class="hljs-number">6</span><br>             line <span class="hljs-number">10</span>: <span class="hljs-number">14</span><br>             line <span class="hljs-number">11</span>: <span class="hljs-number">24</span><br>         LocalVariableTable:<br>             Start Length Slot Name Signature<br>             <span class="hljs-number">0</span> <span class="hljs-number">25</span> <span class="hljs-number">0</span> args [Ljava/lang/String;<br>         StackMapTable: number_of_entries = <span class="hljs-number">2</span><br>          frame_type = <span class="hljs-number">255</span> <span class="hljs-comment">/* full_frame */</span><br>            offset_delta = <span class="hljs-number">19</span><br>            locals = [ <span class="hljs-class"><span class="hljs-keyword">class</span> &quot;[<span class="hljs-title">Ljava</span>/<span class="hljs-title">lang</span>/<span class="hljs-title">String</span></span>;<span class="hljs-string">&quot;, class java/lang/Object ]</span><br><span class="hljs-string">            stack = [ class java/lang/Throwable ]</span><br><span class="hljs-string">          frame_type = 250 /* chop */</span><br><span class="hljs-string">            offset_delta = 4</span><br></code></pre></td></tr></table></figure><h2 id="4-7-原理之synchronized进阶（重点）"><a href="#4-7-原理之synchronized进阶（重点）" class="headerlink" title="4.7 *原理之synchronized进阶（重点）"></a>4.7 *原理之synchronized进阶（重点）</h2><p>Monitor锁由操作系统提供，使用成本较高，对于程序性能有影响。</p><p><strong>小故事</strong></p><p>故事角色</p><ul><li>老王 - JVM</li><li>小南 - 线程</li><li>小女 - 线程</li><li>房间 - 对象</li><li>房间门上 - 防盗锁 - Monitor</li><li>房间门上 - 小南书包 - 轻量级锁</li><li>房间门上 - 刻上小南大名 - 偏向锁</li><li>批量重刻名 - 一个类的偏向锁撤销到达 20 阈值</li><li>不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown">小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样，<br>即使他离开了，别人也进不了门，他的工作就是安全的。<br><br>但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女<br>晚上用。每次上锁太麻烦了，有没有更简单的办法呢？<br><br>小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因<br>此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是<br>自己的，那么就在门外等，并通知对方下次用锁门的方式。<br><br>后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍<br>然觉得麻烦。<br><br>于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那<br>么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦<br>掉，升级为挂书包的方式。<br><br>同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老<br>家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老<br>王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字<br><br>后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包<br></code></pre></td></tr></table></figure><h3 id="4-7-1-轻量级锁"><a href="#4-7-1-轻量级锁" class="headerlink" title="4.7.1 轻量级锁"></a>4.7.1 轻量级锁</h3><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p><p>轻量级锁对使用者是透明的，即语法仍然是 synchronized</p><p>假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 A</span><br>method2();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 B</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的<code>Mark Word</code></li></ul><p><img src="http://image.cryptomartin.top/img/image-20211222111033712.png" alt="image-20211222111033712"></p><p><code>Object reference</code>存储锁对象指针；<code>lock record 地址 00</code>用来存储加锁对象的<code>Mark Word</code></p><ul><li>让锁记录中 <code>Object reference</code> 指向锁对象，并尝试用 <code>cas</code> 替换 Object 的 <code>Mark Word</code>，将 <code>Mark Word</code> 的值存入锁记录</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211222111455243.png" alt="image-20211222111455243"></p><p>会把锁记录的<code>lcok record 地址 00</code>里的数据跟锁对象<code>Object</code>的<code>Mark Word</code>的数据做交换。</p><p><code>01</code>：表示无锁状态，<code>00</code>:表示轻量级锁的状态</p><ul><li>如果 <code>cas</code> 替换成功，对象头中存储了 锁记录地址和状态 <code>00</code> ，表示由该线程给对象加锁，</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211222111818064.png" alt="image-20211222111818064"></p><ul><li><p>如果 <code>cas</code> 失败，有两种情况</p><ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ul></li></ul><p><img src="http://image.cryptomartin.top/img/image-20211222141226403.png" alt="image-20211222141226403"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 A</span><br>method2();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 B</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>method1()调用method2(),synchronized( obj )又锁住ob对象，会在栈帧中创建新的锁记录，Object reference 指向Objct对象，也是执行cas操作，要把数据和对象投中Markd Word交换，结果失败！ 后两位为00，锁记录的地址指向第一个Lock Record。所以第二次加锁失败，不过这个失败没关系。能知道锁是同一个线程中的（通过lock record 地址 00）另一条锁记录，这种情况较<code>synchronized所重入</code></p><p><strong>解锁</strong></p><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p><p><img src="http://image.cryptomartin.top/img/image-20211222142159490.png" alt="image-20211222142159490"></p><ul><li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象<br>头<ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul><h3 id="4-7-2-锁膨胀"><a href="#4-7-2-锁膨胀" class="headerlink" title="4.7.2 锁膨胀"></a>4.7.2 锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20211222164407916.png" alt="image-20211222164407916"></p><ul><li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul><li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</li><li>然后自己进入 Monitor 的 EntryList BLOCKED</li></ul></li></ul><p><img src="http://image.cryptomartin.top/img/image-20211222164635328.png" alt="image-20211222164635328"></p><ul><li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁<br>流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ul><h3 id="4-7-3-自旋优化"><a href="#4-7-3-自旋优化" class="headerlink" title="4.7.3  自旋优化"></a>4.7.3  自旋优化</h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步<br>块，释放了锁），这时当前线程就可以避免阻塞。</p><p><img src="http://image.cryptomartin.top/img/image-20211222165318793.png" alt="image-20211222165318793"></p><p><img src="http://image.cryptomartin.top/img/image-20211222165342929.png" alt="image-20211222165342929"></p><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会<br>高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li><li>Java 7 之后不能控制是否开启自旋功能</li></ul><h3 id="4-7-4-偏向锁"><a href="#4-7-4-偏向锁" class="headerlink" title="4.7.4 偏向锁"></a>4.7.4 偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现<br>这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 A</span><br>m2();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 B</span><br>m3();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 C</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20211222170358505.png" alt="image-20211222170358505"></p><p><img src="http://image.cryptomartin.top/img/image-20211222170434074.png" alt="image-20211222170434074"></p><h4 id="4-7-4-1-偏向状态"><a href="#4-7-4-1-偏向状态" class="headerlink" title="4.7.4.1 偏向状态"></a>4.7.4.1 偏向状态</h4><p>回忆一下对象头格式</p><p><img src="http://image.cryptomartin.top/img/image-20211222170715668.png" alt="image-20211222170715668"></p><p>一个对象创建时：</p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的thread、epoch、age 都为 0</li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟</li><li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</li></ul><p>1） 测试延迟特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestBiased&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBiased</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        log.debug(ClassLayout.parseInstance(dog).toPrintable());<br>        Thread.sleep(<span class="hljs-number">4000</span>);<br>        log.debug(ClassLayout.parseInstance(<span class="hljs-keyword">new</span> Dog()).toPrintable());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://image.cryptomartin.top/img/image-20211222175202103.png" alt="image-20211222175202103"></p><p>2） 测试偏向锁 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestBiased&quot;)</span><br><span class="hljs-comment">// 添加虚拟机参数 -XX:BiasedLockingStartupDelay=0 </span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBiased</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>Dog d = <span class="hljs-keyword">new</span> Dog();<br>ClassLayout classLayout = ClassLayout.parseInstance(d);<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;synchronized 前&quot;</span>);<br>System.out.println(classLayout.toPrintableSimple(<span class="hljs-keyword">true</span>));<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(<span class="hljs-string">&quot;synchronized 中&quot;</span>);<br>System.out.println(classLayout.toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>log.debug(<span class="hljs-string">&quot;synchronized 后&quot;</span>);<br>System.out.println(classLayout.toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">11:08:58.117 c.TestBiased [t1] - synchronized 前<br>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101 <br>11:08:58.121 c.TestBiased [t1] - synchronized 中<br>00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101 <br>11:08:58.121 c.TestBiased [t1] - synchronized 后<br>00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>处于偏向锁的对象解锁后，线程 id 仍存储于对象头中;</p><p> dog对象就给主线程使用了，dog对象就从属于主线程；dog对象的对象头Mark Word始终存储主线程的线程id，除非是其他线程使用了dog对象才会改变。</p></blockquote><p>3）测试禁用</p><p>在上面测试代码运行时在添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</p><p>输出：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">11:13:10.018 c.TestBiased [t1] - synchronized 前<br>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>11:13:10.021 c.TestBiased [t1] - synchronized 中<br>00000000 00000000 00000000 00000000 00100000 00010100 11110011 10001000 <br>11:13:10.021 c.TestBiased [t1] - synchronized 后<br>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001<br></code></pre></td></tr></table></figure><blockquote><p>禁用偏向锁后，对象加锁后使用的是轻量级锁。</p><p>优先级：有偏向锁会采用偏向锁，如果其他线程使用了该对象，会撤销偏向锁变成轻量级锁；如果是轻量级锁，有线程竞争，会进行锁膨胀，成为重量级锁。</p></blockquote><p>4）测试 hashCode</p><p>正常状态对象一开始是没有 hashCode 的，第一次调用才生成</p><p>开启偏向锁，对象在加锁之前调用<code>hashCode()</code>，会禁用这个对象的偏向锁。</p><p>why?看对象头的mark word</p><p><img src="http://image.cryptomartin.top/img/image-20211226170317210.png" alt="image-20211226170317210"></p><p>一个可偏向的对象,调用hashcode，就不可偏向了，因为没地方存储hashcode了。偏向锁的对象头mark word 需要存储54位线程id，而hashcode有31位。mark word 只有64位。</p><p>问：为什么轻量级锁，重量级锁调用<code>hashcode()</code>不会有问题呢？</p><p>答：轻量级锁会将hashcode存储在线程栈帧的锁记录里；重量级锁会将hashcode存储在monitor对象里，解锁时会还原回来。</p><h4 id="4-7-4-2-撤销-调用对象-hashCode"><a href="#4-7-4-2-撤销-调用对象-hashCode" class="headerlink" title="4.7.4.2 撤销 - 调用对象 hashCode"></a>4.7.4.2 撤销 - 调用对象 hashCode</h4><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销</p><ul><li>轻量级锁会在锁记录中记录 hashCode</li><li>重量级锁会在 Monitor 中记录 hashCode</li></ul><p>在调用 hashCode 后使用偏向锁，记得去掉 <code>-XX:-UseBiasedLocking</code>（<code>-XX:-UseBiasedLocking</code>：是禁用偏向锁，我们这是测试调用对象的hashCode()方法）</p><p><code>输出</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mark">11:22:10.386 c.TestBiased [main] - 调用 hashCode:1778535015 <br>11:22:10.391 c.TestBiased [t1] - synchronized 前<br>00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001 <br>11:22:10.393 c.TestBiased [t1] - synchronized 中<br>00000000 00000000 00000000 00000000 00100000 11000011 11110011 01101000 <br>11:22:10.393 c.TestBiased [t1] - synchronized 后<br>00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001<br></code></pre></td></tr></table></figure><h4 id="4-7-4-3-撤销-其它线程使用对象"><a href="#4-7-4-3-撤销-其它线程使用对象" class="headerlink" title="4.7.4.3 撤销 - 其它线程使用对象"></a>4.7.4.3 撤销 - 其它线程使用对象</h4><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Dog d = <span class="hljs-keyword">new</span> Dog();<br>    <br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>        <br><span class="hljs-keyword">synchronized</span> (TestBiased.class) &#123;<br>TestBiased.class.notify();<br>&#125;<br><span class="hljs-comment">// 如果不用 wait/notify 使用 join 必须打开下面的注释</span><br><span class="hljs-comment">// 因为：t1 线程不能结束，否则底层线程可能被 jvm 重用作为 t2 线程，底层线程 id 是一样的</span><br><span class="hljs-comment">/*try &#123;</span><br><span class="hljs-comment">         System.in.read();</span><br><span class="hljs-comment">         &#125; catch (IOException e) &#123;</span><br><span class="hljs-comment">         e.printStackTrace();</span><br><span class="hljs-comment">         &#125;*/</span><br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>    <br>Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span> (TestBiased.class) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>TestBiased.class.wait();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>        <br>log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>t1线程必须和t2线程交错开，否则有交错会升级为重量级锁。</p><p>轻量级锁和偏向锁访问对象都是错开的。</p><p>如何错开？t2锁住类对象，等待。（类锁和对象锁不会产生竞争，二者的加锁方法不会相互影响）</p><p>wait会释放CPU和锁资源。</p><p>Wait() 会使当前线程A释放锁，并被加入到Waiting队列，进入Waiting状态。</p><p>另一个线程B调用Notify()之后，会将线程A从Waiting队列移动到Blocked队列中，即线程A从Waiting状态进入尝试获得锁的Blocked状态。之后B释放锁之后，A才有获得锁的机会。</p></blockquote><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[t1] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101 --偏向锁，包含t1线程id<br>[t2] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101 --t2线程没加锁前<br>[t2] - 00000000 00000000 00000000 00000000 00011111 10110101 11110000 01000000 --t2加锁，加的是轻量级锁，包含t2锁记录指针<br>[t2] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 --t2结束，变成不可偏向。<br></code></pre></td></tr></table></figure><h4 id="4-7-4-4-撤销-调用-wait-notify"><a href="#4-7-4-4-撤销-调用-wait-notify" class="headerlink" title="4.7.4.4 撤销 - 调用 wait/notify"></a>4.7.4.4 撤销 - 调用 wait/notify</h4><p>等待通知机制，只有重量级锁才有，都会把偏向锁/轻量级锁升级成重量级锁。</p><h4 id="4-7-4-5-批量重偏向"><a href="#4-7-4-5-批量重偏向" class="headerlink" title="4.7.4.5 批量重偏向"></a>4.7.4.5 批量重偏向</h4><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p><p>当撤销偏向锁阈值达到 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <br>Vector&lt;Dog&gt; list = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>    <br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>Dog d = <span class="hljs-keyword">new</span> Dog();<br>list.add(d);<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>&#125;<br><span class="hljs-keyword">synchronized</span> (list) &#123;<br>list.notify();<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>    <br>Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span> (list) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>list.wait();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>        <br>log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>Dog d = list.get(i);<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs mark">[t1] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t1] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - ===============&gt; <br>[t2] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 0 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 1 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 2 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 2 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 3 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 3 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 4 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 4 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 5 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 5 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 6 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 6 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101<br>[t2] - 7 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 7 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 8 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 8 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 9 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 9 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 10 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 10 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 11 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 11 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 12 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 12 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 13 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 13 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 14 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 14 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 15 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 15 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 16 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 16 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 17 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 17 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 18 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 18 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101<br>[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101<br></code></pre></td></tr></table></figure><p>注意到:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[t2] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 18 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 <br>[t2] - 18 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 <br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br>[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 <br></code></pre></td></tr></table></figure><p>第20次(序号19),t1的线程id和t2的线程id：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[t1] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 <br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 --t2没加锁之前，仍偏向t1<br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 --撤销次数达到20次，重新偏向t2<br>[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 --批量偏向<br></code></pre></td></tr></table></figure><h4 id="4-7-4-6-批量撤销"><a href="#4-7-4-6-批量撤销" class="headerlink" title="4.7.4.6 批量撤销"></a>4.7.4.6 批量撤销</h4><p><code>intx BiasedLockingBulkRebiasThreshold  = 20</code>  默认偏向锁批量重偏向阈值</p><p><code>intx BiasedLockingBulkRevokeThreshold = 40</code>  默认偏向锁批量撤销阈值</p><p>当撤销偏向锁阈值达到 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Thread t1,t2,t3;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Vector&lt;Dog&gt; list = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br><span class="hljs-keyword">int</span> loopNumber = <span class="hljs-number">39</span>;<br>t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>Dog d = <span class="hljs-keyword">new</span> Dog();<br>list.add(d);<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>&#125;<br>LockSupport.unpark(t2);<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>LockSupport.park();<br>log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>Dog d = list.get(i);<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>LockSupport.unpark(t3);<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br>t3 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>LockSupport.park();<br>log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>Dog d = list.get(i);<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br><span class="hljs-keyword">synchronized</span> (d) &#123;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>log.debug(i + <span class="hljs-string">&quot;t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t3&quot;</span>);<br>t3.start();<br>t3.join();<br>log.debug(ClassLayout.parseInstance(<span class="hljs-keyword">new</span> Dog()).toPrintableSimple(<span class="hljs-keyword">true</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>LockSupport.unpark</code>：停止当前线程，唤醒目标线程</p><ul><li><code>t1</code>线程中，0-39中的循环给每个d对象加上了偏向锁，使每个d对象保存了<code>t1</code>线程ID。</li><li><code>t2</code>线程中，0-18中的循环，撤销偏向锁，获得对象锁后为轻量级锁, 使每个d对象变成了不可偏向状态。19-39中的循环，<code>JVM</code>批量重偏向使该对象保存了<code>t2</code>线程ID</li><li><code>t3</code>线程中，0-18中的循环，每个d对象仍是不可偏向状态，获得对象锁后仍为轻量级锁。19-39中，撤销偏向锁，获得对象锁后为轻量级锁，使整个类的每个d对象变成了不可偏向状态。</li><li><code>t2</code>中的0-18中的循环和<code>t3</code>中19-39中的循环，一共撤销了40次偏向。此后Dog类之前创建的对象，或是新创建的对象都是不可偏向的。</li></ul><blockquote><p><a href="https://www.cnblogs.com/LemonFive/p/11246086.html">盘一盘 synchronized （一）—— 从打印Java对象头说起</a></p><p><a href="https://www.cnblogs.com/LemonFive/p/11248248.html">盘一盘 synchronized （二）—— 偏向锁批量重偏向与批量撤销</a></p></blockquote><h3 id="4-7-5-锁消除"><a href="#4-7-5-锁消除" class="headerlink" title="4.7.5 锁消除"></a>4.7.5 锁消除</h3><p><strong>锁消除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Fork(1)</span><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-meta">@Warmup(iterations=3)</span><br><span class="hljs-meta">@Measurement(iterations=5)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBenchmark</span> </span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-meta">@Benchmark</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>x++;<br>&#125;<br><span class="hljs-meta">@Benchmark</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>Object o = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">synchronized</span> (o) &#123;<br>x++;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行<code>java -jar benchmarks.jar</code></p><p><img src="http://image.cryptomartin.top/img/image-20211228151936221.png" alt="image-20211228151936221"></p><p>得分没什么区别，为什么呢？</p><p>因为有即时编译器JIT，热点的代码(反复执行)，JIT进行优化，其中的一个手段就是看局部变量能不能优化。发现局部变量逃离不了方法的范围，这种情况加局部变量就不能被共享，所以加锁没有意义。JIT就会把锁优化掉，真正执行是没有这个锁的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Benchmark</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>Object o = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">synchronized</span> (o) &#123;<br>x++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况，锁消除是打开的。</p><p><code>java -XX:-EliminateLocks -jar benchmarks.jar</code>:关闭锁消除</p><p><img src="http://image.cryptomartin.top/img/image-20211228152530932.png" alt="image-20211228152530932"></p><p>没进行JIT锁消除优化，性能差了10几倍。</p><p><strong>锁粗化</strong></p><p>对相同对象多次加锁，导致线程发生多次重入，可以使用锁粗化方式来优化，这不同于之前讲的细分锁的粒度。</p><h2 id="4-8-wait-notify"><a href="#4-8-wait-notify" class="headerlink" title="4.8 wait/notify"></a>4.8 wait/notify</h2><h3 id="4-8-1-小故事-为什么需要-wait"><a href="#4-8-1-小故事-为什么需要-wait" class="headerlink" title="4.8.1 小故事 - 为什么需要 wait"></a>4.8.1 小故事 - 为什么需要 wait</h3><p><img src="http://image.cryptomartin.top/img/image-20211228153111052.png" alt="image-20211228153111052"></p><p><img src="http://image.cryptomartin.top/img/image-20211228153126873.png" alt="image-20211228153126873"></p><h3 id="4-8-2-原理之wait-notify"><a href="#4-8-2-原理之wait-notify" class="headerlink" title="4.8.2 *原理之wait/notify"></a>4.8.2 *原理之wait/notify</h3><p><img src="http://image.cryptomartin.top/img/image-20211228161830111.png" alt="image-20211228161830111"></p><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li></ul><h3 id="4-8-3-API介绍"><a href="#4-8-3-API介绍" class="headerlink" title="4.8.3 API介绍"></a>4.8.3 API介绍</h3><ul><li><code>obj.wait()</code> 让进入 object 监视器的线程到 waitSet 等待</li><li><code>obj.notify()</code> 在 object 上正在 waitSet 等待的线程中挑一个唤醒</li><li><code>obj.notifyAll()</code> 让 object 上正在 waitSet 等待的线程全部唤醒</li></ul><p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            log.debug(<span class="hljs-string">&quot;执行....&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                obj.wait(); <span class="hljs-comment">// 让线程在obj上一直等待下去</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;其它代码....&quot;</span>);<br>        &#125;<br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            log.debug(<span class="hljs-string">&quot;执行....&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                obj.wait(); <span class="hljs-comment">// 让线程在obj上一直等待下去</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;其它代码....&quot;</span>);<br>        &#125;<br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    <span class="hljs-comment">// 主线程两秒后执行</span><br>    sleep(<span class="hljs-number">2</span>);<br>    log.debug(<span class="hljs-string">&quot;唤醒 obj 上其它线程&quot;</span>);<br><br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>        <span class="hljs-comment">//obj.notify(); // 唤醒obj上一个线程</span><br>        obj.notifyAll(); <span class="hljs-comment">// 唤醒obj上所有等待线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>notify()</code> 的一种结果:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:29:50 [t1] c.TestWaitNotify - 执行....<br>16:29:50 [t2] c.TestWaitNotify - 执行....<br>16:29:52 [main] c.TestWaitNotify - 唤醒 obj 上其它线程<br>16:29:52 [t1] c.TestWaitNotify - 其它代码....<br></code></pre></td></tr></table></figure><p><code>notifyAll()</code> 的结果:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:31:25 [t1] c.TestWaitNotify - 执行....<br>16:31:25 [t2] c.TestWaitNotify - 执行....<br>16:31:27 [main] c.TestWaitNotify - 唤醒 obj 上其它线程<br>16:31:27 [t2] c.TestWaitNotify - 其它代码....<br>16:31:27 [t1] c.TestWaitNotify - 其它代码....<br></code></pre></td></tr></table></figure><ul><li><code>wait()</code> 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止</li><li><code>wait(long n)</code> 有时限的等待, 到 n 毫秒后结束等待，或是被 notify</li></ul><h3 id="4-8-4-wait-notify-的正确使用方法"><a href="#4-8-4-wait-notify-的正确使用方法" class="headerlink" title="4.8.4 wait/notify 的正确使用方法"></a>4.8.4 wait/notify 的正确使用方法</h3><p>先看看</p><p><strong>sleep(long n) 和 wait(long n) 的区别</strong></p><ul><li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li></ul><ol start="2"><li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li><li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 </li><li>共同点：它们状态 TIMED_WAITING</li></ol><h4 id="4-8-4-1-step1-sleep"><a href="#4-8-4-1-step1-sleep" class="headerlink" title="4.8.4.1 step1 sleep"></a>4.8.4.1 step1 sleep</h4><p>思考下面的解决方案好不好，为什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestCorrectPostureStep1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCorrectPostureStep1</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasCigarette = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//没有烟</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasTakeout = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (!hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>                    sleep(<span class="hljs-number">2</span>);<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;其它人&quot;</span>).start();<br>        &#125;<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">// 这里能不能加 synchronized (room)？不能！获得不了锁</span><br>            hasCigarette = <span class="hljs-keyword">true</span>;<br>            log.debug(<span class="hljs-string">&quot;烟到了噢！&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;送烟的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:57:41 [其它人] c.TestCorrectPostureStep1 - 可以开始干活了<br>16:57:41 [小南] c.TestCorrectPostureStep1 - 有烟没？[false]<br>16:57:41 [小南] c.TestCorrectPostureStep1 - 没烟，先歇会！<br>16:57:42 [送烟的] c.TestCorrectPostureStep1 - 烟到了噢！<br>16:57:43 [小南] c.TestCorrectPostureStep1 - 有烟没？[true]<br>16:57:43 [小南] c.TestCorrectPostureStep1 - 可以开始干活了<br>16:57:43 [其它人] c.TestCorrectPostureStep1 - 可以开始干活了<br>16:57:43 [其它人] c.TestCorrectPostureStep1 - 可以开始干活了<br>16:57:43 [其它人] c.TestCorrectPostureStep1 - 可以开始干活了<br>16:57:43 [其它人] c.TestCorrectPostureStep1 - 可以开始干活了<br></code></pre></td></tr></table></figure><ul><li>其它干活的线程，都要一直阻塞，效率太低</li><li>小南线程必须睡足 2s 后才能醒来，就算烟提前送到，也无法立刻醒来</li><li>加了 synchronized (room) 后，就好比小南在里面反锁了门睡觉，烟根本没法送进门，main 加synchronized 就好像 main 线程是翻窗户进来的</li><li>解决方法，使用 wait - notify 机制</li></ul><h4 id="4-8-4-2-step2-wait-notify"><a href="#4-8-4-2-step2-wait-notify" class="headerlink" title="4.8.4.2 step2 wait/notify"></a>4.8.4.2 step2 wait/notify</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestCorrectPostureStep2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCorrectPostureStep2</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasCigarette = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//没有烟</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasTakeout = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (!hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<span class="hljs-comment">//别的线程调用interrupt(),向下执行</span><br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;其它人&quot;</span>).start();<br>        &#125;<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">// 这里能不能加 synchronized (room)？不能！获得不了锁</span><br>            <span class="hljs-keyword">synchronized</span> (room)&#123;<br>                hasCigarette = <span class="hljs-keyword">true</span>;<br>                log.debug(<span class="hljs-string">&quot;烟到了噢！&quot;</span>);<br>                room.notify();<br>            &#125;<br><br>        &#125;, <span class="hljs-string">&quot;送烟的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> <span class="hljs-selector-attr">[小南]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 有烟没？<span class="hljs-selector-attr">[false]</span><br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> <span class="hljs-selector-attr">[小南]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 没烟，先歇会！<br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> <span class="hljs-selector-attr">[其它人]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 可以开始干活了<br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> <span class="hljs-selector-attr">[其它人]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 可以开始干活了<br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> <span class="hljs-selector-attr">[其它人]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 可以开始干活了<br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> <span class="hljs-selector-attr">[其它人]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 可以开始干活了<br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> <span class="hljs-selector-attr">[其它人]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 可以开始干活了<br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">34</span> <span class="hljs-selector-attr">[送烟的]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 烟到了噢！<br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">34</span> <span class="hljs-selector-attr">[小南]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 有烟没？<span class="hljs-selector-attr">[true]</span><br><span class="hljs-number">17</span>:<span class="hljs-number">40</span>:<span class="hljs-number">34</span> <span class="hljs-selector-attr">[小南]</span> c<span class="hljs-selector-class">.TestCorrectPostureStep2</span> - 可以开始干活了<br></code></pre></td></tr></table></figure><ul><li>解决了其它干活的线程阻塞的问题</li><li>但如果有其它线程也在等待条件呢？会不会错误地叫醒其他线程？</li></ul><h4 id="4-8-4-3-step3-notify"><a href="#4-8-4-3-step3-notify" class="headerlink" title="4.8.4.3 step3 notify"></a>4.8.4.3 step3 notify</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestCorrectPostureStep3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCorrectPostureStep3</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasCigarette = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//没有烟</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasTakeout = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">//虚假唤醒</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (!hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<span class="hljs-comment">//别的线程调用interrupt(),向下执行</span><br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                Thread thread = Thread.currentThread();<br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);<br>                <span class="hljs-keyword">if</span> (!hasTakeout) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);<br>                <span class="hljs-keyword">if</span> (hasTakeout) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                hasTakeout = <span class="hljs-keyword">true</span>;<br>                log.debug(<span class="hljs-string">&quot;外卖到了噢！&quot;</span>);<br>                room.notify();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">17:48:14 [小南] c.TestCorrectPostureStep3 - 有烟没？[false]<br>17:48:14 [小南] c.TestCorrectPostureStep3 - 没烟，先歇会！<br>17:48:14 [小女] c.TestCorrectPostureStep3 - 外卖送到没？[false]<br>17:48:14 [小女] c.TestCorrectPostureStep3 - 没外卖，先歇会！<br>17:48:15 [送外卖的] c.TestCorrectPostureStep3 - 外卖到了噢！<br>17:48:15 [小南] c.TestCorrectPostureStep3 - 有烟没？[false]<br>17:48:15 [小南] c.TestCorrectPostureStep3 - 没干成活...<br></code></pre></td></tr></table></figure><ul><li>notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程，称之为【虚假唤醒】</li><li>解决方法，改为 notifyAll–&gt;小南还是没干成活</li></ul><h4 id="4-8-4-4-step4-notifyall"><a href="#4-8-4-4-step4-notifyall" class="headerlink" title="4.8.4.4 step4 notifyall"></a>4.8.4.4 step4 notifyall</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">sleep(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (room) &#123;<br>        hasTakeout = <span class="hljs-keyword">true</span>;<br>        log.debug(<span class="hljs-string">&quot;外卖到了噢！&quot;</span>);<br>        room.notifyAll();<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">17:55:48 [小南] c.TestCorrectPostureStep4 - 有烟没？[false]<br>17:55:48 [小南] c.TestCorrectPostureStep4 - 没烟，先歇会！<br>17:55:48 [小女] c.TestCorrectPostureStep4 - 外卖送到没？[false]<br>17:55:48 [小女] c.TestCorrectPostureStep4 - 没外卖，先歇会！<br>17:55:49 [送外卖的] c.TestCorrectPostureStep4 - 外卖到了噢！<br>17:55:49 [小女] c.TestCorrectPostureStep4 - 外卖送到没？[true]<br>17:55:49 [小女] c.TestCorrectPostureStep4 - 可以开始干活了<br>17:55:49 [小南] c.TestCorrectPostureStep4 - 有烟没？[false]<br>17:55:49 [小南] c.TestCorrectPostureStep4 - 没干成活...<br></code></pre></td></tr></table></figure><ul><li>用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新判断的机会了</li><li>解决方法，用 while + wait，当条件不成立，再次 wait</li></ul><h4 id="4-8-4-5-step-while-wait"><a href="#4-8-4-5-step-while-wait" class="headerlink" title="4.8.4.5 step while+wait"></a>4.8.4.5 step while+wait</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (room) &#123;<br>log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br><span class="hljs-keyword">while</span> (!hasCigarette) &#123;<br><span class="hljs-comment">//if改成while,就可以一直判断。</span><br>log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>room.wait();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">//别的线程调用interrupt(),向下执行</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br>log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br><span class="hljs-keyword">if</span> (hasCigarette) &#123;<br>log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">18:01:16 [小南] c.TestCorrectPostureStep5 - 有烟没？[false]<br>18:01:16 [小南] c.TestCorrectPostureStep5 - 没烟，先歇会！<br>18:01:16 [小女] c.TestCorrectPostureStep5 - 外卖送到没？[false]<br>18:01:16 [小女] c.TestCorrectPostureStep5 - 没外卖，先歇会！<br>18:01:17 [送外卖的] c.TestCorrectPostureStep5 - 外卖到了噢！<br>18:01:17 [小女] c.TestCorrectPostureStep5 - 外卖送到没？[true]<br>18:01:17 [小女] c.TestCorrectPostureStep5 - 可以开始干活了<br>18:01:17 [小南] c.TestCorrectPostureStep5 - 没烟，先歇会！<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) &#123;<br><span class="hljs-keyword">while</span>(条件不成立) &#123;<br>lock.wait();<br>&#125;<br><span class="hljs-comment">// 干活</span><br>&#125;<br><span class="hljs-comment">//另一个线程</span><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>lock.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-8-5-【模式】同步模式之保护性暂停"><a href="#4-8-5-【模式】同步模式之保护性暂停" class="headerlink" title="4.8.5 【模式】同步模式之保护性暂停"></a>4.8.5 【模式】同步模式之保护性暂停</h3><h4 id="4-8-5-1-定义"><a href="#4-8-5-1-定义" class="headerlink" title="4.8.5.1 定义"></a>4.8.5.1 定义</h4><p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果</p><p>要点</p><ul><li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li><li>因为要等待另一方的结果，因此归类到同步模式</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211228181410426.png" alt="image-20211228181410426"></p><h4 id="4-8-5-2-实现"><a href="#4-8-5-2-实现" class="headerlink" title="4.8.5.2 实现"></a>4.8.5.2 实现</h4><p>synchronized (this)：</p><p>当使用 synchronized 加锁 class 时，无论共享一个对象还是创建多个对象，它们用的都是同一把锁，而使用 synchronized 加锁 this 时，只有同一个对象会使用同一把锁，不同对象之间的锁是不同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test20&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test20</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        GuardedObject guardedObject = <span class="hljs-keyword">new</span> GuardedObject();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">//等待结果</span><br>            log.debug(<span class="hljs-string">&quot;等待结果&quot;</span>);<br>            List&lt;String&gt; list = (List&lt;String&gt;) guardedObject.getResponse();<br>            log.debug(<span class="hljs-string">&quot;结果大小：&#123;&#125;&quot;</span>, list.size());<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;执行下载...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                List&lt;String&gt; list = Downloader.download();<br>                guardedObject.setResponse(list);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObject</span> </span>&#123;<br>    <span class="hljs-comment">//结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">//获取结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">//没有结果</span><br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//产生结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResponse</span><span class="hljs-params">(Object response)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123; <span class="hljs-comment">//this-&gt;实例对象。实例对象不同，锁不同！</span><br>            <span class="hljs-keyword">this</span>.response = response;<br>            <span class="hljs-keyword">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13</span>:<span class="hljs-number">14</span>:<span class="hljs-number">22</span> [t2] c.Test20 - 执行下载...<br><span class="hljs-number">13</span>:<span class="hljs-number">14</span>:<span class="hljs-number">22</span> [t1] c.Test20 - 等待结果<br><span class="hljs-number">13</span>:<span class="hljs-number">14</span>:<span class="hljs-number">23</span> [t1] c.Test20 - 结果大小：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><blockquote><p>为什么不用<code>join()</code>? </p><p>答：1.必须等待线程结束，保护性暂停执行完后，可以继续干其他事情；2. <code>join()</code>方法只能设置位全局的，不能局部。</p></blockquote><h4 id="4-8-5-3-带超时版-GuardedObject"><a href="#4-8-5-3-带超时版-GuardedObject" class="headerlink" title="4.8.5.3 带超时版 GuardedObject"></a>4.8.5.3 带超时版 GuardedObject</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//结果</span><br><span class="hljs-keyword">private</span> Object response;<br><br><span class="hljs-comment">//获取结果</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-comment">//记录一个开始时间</span><br>        <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.wait(timeout);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>注：this.wait(timeout);//每次等2秒后自己唤醒，不断循环;本质没什么区别</p><p>小知识 object.wait 和 object.wait(long timeout)</p><p>相同点：<br>都会在拥有锁的时候立即释放锁，线程会被系统挂起，失去cpu时间片，得不到调度。<br>不同点：<br>后者线程会在指定timeout的时间过去之后被唤醒</p></blockquote><p>改进思路：在等待前，记录一个什么时候等待的时刻(开始时间<code>begin</code>),<code>this.wait(n);</code>应该有个等待时间n，不能让线程无线等待；等待时间结束后，应该有个经历时间<code>passTime</code>，查看经历了多长时间。如果经历的时间<code>passTime</code>已经超过了参数<code>timeout</code>，就退出循环。</p><p>问题：<code>this.wait(?);</code>应该等多久？</p><p>答：写<code>this.wait(timeout);</code>，会有问题：如果被虚假唤醒，最大等待时间还有剩余，不需要每次等待 最大等待时间。应该设置每轮等待时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取结果</span><br>   <span class="hljs-comment">//timeout：最大等待时间 假设2000</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>           <span class="hljs-comment">//记录一个开始时间</span><br>           <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>           <span class="hljs-comment">//经历的时间</span><br>           <span class="hljs-keyword">long</span> passTime = <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>               <span class="hljs-comment">//推出无线循环的条件，经历时间大于等于最大等待时间</span><br>               <span class="hljs-keyword">if</span> (passTime&gt;=timeout)&#123;<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-keyword">this</span>.wait(timeout);<span class="hljs-comment">//1.虚假唤醒 15:00:01;  第二次进入循环3.this还需要等待2秒吗？不需要，最大时间是2秒，过了1秒，应该最多等1秒！</span><br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace();<br>               &#125;<br>               <span class="hljs-comment">//求得经历的时间</span><br>               passTime = System.currentTimeMillis()-begin; <span class="hljs-comment">//2. 15:00:01 passTime=1s</span><br>           &#125;<br>           <span class="hljs-keyword">return</span> response;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>改进：设置每一轮等待时间<code>waitTime</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//结果</span><br><span class="hljs-keyword">private</span> Object response;<br><span class="hljs-comment">//获取结果</span><br><span class="hljs-comment">//timeout：最大等待时间</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-comment">//记录一个开始时间</span><br><span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br><span class="hljs-comment">//经历的时间</span><br><span class="hljs-keyword">long</span> passTime = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">//这一轮应该等待时间waitTime</span><br><span class="hljs-keyword">long</span> waitTime = timeout - passTime;<br><span class="hljs-comment">//推出无线循环的条件，经历时间大于等于最大等待时间</span><br><span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">this</span>.wait(waitTime);<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//求得经历的时间</span><br>passTime = System.currentTimeMillis() - begin;<br>&#125;<br><span class="hljs-keyword">return</span> response;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试超时，仅等待2秒</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test20&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test20</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        GuardedObject guardedObject = <span class="hljs-keyword">new</span> GuardedObject();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;t1开始执行&quot;</span>);<br>            Object response = guardedObject.getResponse(<span class="hljs-number">2000</span>);<br>            log.debug(<span class="hljs-string">&quot;结果是：&#123;&#125;&quot;</span>,response);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;t2开始执行&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">3</span>);<br>            guardedObject.setResponse(<span class="hljs-keyword">null</span>);<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//增强超时效果</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObject</span> </span>&#123;<br>    <span class="hljs-comment">//结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">//获取结果</span><br>    <span class="hljs-comment">//timeout：最大等待时间</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">//记录一个开始时间</span><br>            <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>            <span class="hljs-comment">//经历的时间</span><br>            <span class="hljs-keyword">long</span> passTime = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//这一轮应该等待时间waitTime</span><br>                <span class="hljs-keyword">long</span> waitTime = timeout - passTime;<br>                <span class="hljs-comment">//推出无线循环的条件，经历时间大于等于最大等待时间</span><br>                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">this</span>.wait(waitTime);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-comment">//求得经历的时间</span><br>                passTime = System.currentTimeMillis() - begin;<br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//产生结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResponse</span><span class="hljs-params">(Object response)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123; <span class="hljs-comment">//this-&gt;实例对象。实例对象不同，锁不同！</span><br>            <span class="hljs-keyword">this</span>.response = response;<br>            <span class="hljs-keyword">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">45</span>:<span class="hljs-number">13</span> [t1] c.Test20 - t1开始执行<br><span class="hljs-number">15</span>:<span class="hljs-number">45</span>:<span class="hljs-number">13</span> [t2] c.Test20 - t2开始执行<br><span class="hljs-number">15</span>:<span class="hljs-number">45</span>:<span class="hljs-number">15</span> [t1] c.Test20 - 结果是：<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p><strong>测试超时，设置this.wait(timeout);花费3秒！</strong></p><p>等待1秒+最大等待时间2秒=3秒</p><p><code>输出</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">54</span>:<span class="hljs-number">38</span> [t2] c.Test20 - t2开始执行<br><span class="hljs-number">15</span>:<span class="hljs-number">54</span>:<span class="hljs-number">38</span> [t1] c.Test20 - t1开始执行<br><span class="hljs-number">15</span>:<span class="hljs-number">54</span>:<span class="hljs-number">41</span> [t1] c.Test20 - 结果是：<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h4 id="4-8-5-4-原理之join"><a href="#4-8-5-4-原理之join" class="headerlink" title="4.8.5.4 *原理之join"></a>4.8.5.4 *原理之join</h4><p><code>join()</code>方法应用了保护性暂停的模式。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">long</span> base = System.currentTimeMillis(); <span class="hljs-comment">//记录了一个开始时间</span><br>    <span class="hljs-keyword">long</span> now = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录一个经历时间</span><br><br>    <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            <span class="hljs-keyword">long</span> delay = millis - now; <span class="hljs-comment">//最大超时时间-经历时间=本轮等待时间</span><br>            <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            wait(delay);<br>            now = System.currentTimeMillis() - base; <span class="hljs-comment">//结束等待后，求得经历时间</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-8-5-5-多任务版-GuardedObject"><a href="#4-8-5-5-多任务版-GuardedObject" class="headerlink" title="4.8.5.5 多任务版 GuardedObject"></a>4.8.5.5 多任务版 GuardedObject</h4><p>图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员</p><p>如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理</p><p><img src="http://image.cryptomartin.top/img/image-20211229202432101.png" alt="image-20211229202432101"></p><p>新增 id 用来标识 Guarded Object</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObject</span> </span>&#123;<br><span class="hljs-comment">// 标识 Guarded Object</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GuardedObject</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> id;<br>&#125;<br><span class="hljs-comment">// 结果</span><br><span class="hljs-keyword">private</span> Object response;<br><span class="hljs-comment">// 获取结果</span><br><span class="hljs-comment">// timeout 表示要等待多久 2000</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-comment">// 开始时间 15:00:00</span><br><span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br><span class="hljs-comment">// 经历的时间</span><br><span class="hljs-keyword">long</span> passedTime = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// 这一轮循环应该等待的时间</span><br><span class="hljs-keyword">long</span> waitTime = timeout - passedTime;<br><span class="hljs-comment">// 经历的时间超过了最大等待时间时，退出循环</span><br><span class="hljs-keyword">if</span> (timeout - passedTime &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">this</span>.wait(waitTime);<br><span class="hljs-comment">// 虚假唤醒 15:00:01</span><br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">// 求得经历时间</span><br>passedTime = System.currentTimeMillis() - begin;<br><span class="hljs-comment">// 15:00:02 1s</span><br>&#125;<br><span class="hljs-keyword">return</span> response;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 产生结果</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">complete</span><span class="hljs-params">(Object response)</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-comment">// 给结果成员变量赋值</span><br><span class="hljs-keyword">this</span>.response = response;<br><span class="hljs-keyword">this</span>.notifyAll();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>中间解耦类(通用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mailboxes</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="hljs-keyword">new</span> Hashtable&lt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> id = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 产生唯一 id</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">generateId</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> id++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title">getGuardedObject</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br><span class="hljs-keyword">return</span> boxes.remove(id);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title">createGuardedObject</span><span class="hljs-params">()</span> </span>&#123;<br>GuardedObject go = <span class="hljs-keyword">new</span> GuardedObject(generateId());<br>boxes.put(go.getId(), go);<br><span class="hljs-keyword">return</span> go;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title">getIds</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> boxes.keySet();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>业务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 收信</span><br>GuardedObject guardedObject = Mailboxes.createGuardedObject();<br>log.debug(<span class="hljs-string">&quot;开始收信 id:&#123;&#125;&quot;</span>, guardedObject.getId());<br>Object mail = guardedObject.get(<span class="hljs-number">5000</span>);<br>log.debug(<span class="hljs-string">&quot;收到信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, guardedObject.getId(), mail);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br><span class="hljs-keyword">private</span> String mail;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Postman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String mail)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.mail = mail;<br>&#125;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>GuardedObject guardedObject = Mailboxes.getGuardedObject(id);<br>log.debug(<span class="hljs-string">&quot;送信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, id, mail);<br>guardedObject.complete(mail);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-keyword">new</span> People().start();<br>&#125;<br>Sleeper.sleep(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;<br><span class="hljs-keyword">new</span> Postman(id, <span class="hljs-string">&quot;内容&quot;</span> + id).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">10:35:05.689 c.People [Thread-1] - 开始收信 id:3<br>10:35:05.689 c.People [Thread-2] - 开始收信 id:1<br>10:35:05.689 c.People [Thread-0] - 开始收信 id:2<br>10:35:06.688 c.Postman [Thread-4] - 送信 id:2, 内容:内容2<br>10:35:06.688 c.Postman [Thread-5] - 送信 id:1, 内容:内容1<br>10:35:06.688 c.People [Thread-0] - 收到信 id:2, 内容:内容2<br>10:35:06.688 c.People [Thread-2] - 收到信 id:1, 内容:内容1<br>10:35:06.688 c.Postman [Thread-3] - 送信 id:3, 内容:内容3<br>10:35:06.689 c.People [Thread-1] - 收到信 id:3, 内容:内容3<br></code></pre></td></tr></table></figure><h3 id="4-8-6-【模式】异步模式之生产者-消费者"><a href="#4-8-6-【模式】异步模式之生产者-消费者" class="headerlink" title="4.8.6 【模式】异步模式之生产者/消费者"></a>4.8.6 【模式】异步模式之生产者/消费者</h3><h4 id="4-8-6-1-定义"><a href="#4-8-6-1-定义" class="headerlink" title="4.8.6.1 定义"></a>4.8.6.1 定义</h4><p>要点</p><ul><li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应</li><li>消费队列可以用来平衡生产和消费的线程资源</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211229203108502.png" alt="image-20211229203108502"></p><h4 id="4-8-6-2-实现"><a href="#4-8-6-2-实现" class="headerlink" title="4.8.6.2 实现"></a>4.8.6.2 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test21&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test21</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MessageQueue queue = <span class="hljs-keyword">new</span> MessageQueue(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> id = i;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                queue.put(<span class="hljs-keyword">new</span> Message(id, <span class="hljs-string">&quot;值&quot;</span> + id));<br>            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                sleep(<span class="hljs-number">1</span>);<br>                Message message = queue.take();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;消费者&quot;</span>).start();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 消息队列类 ， java 线程之间通信</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.MessageQueue&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageQueue</span> </span>&#123;<br>    <span class="hljs-comment">// 消息的队列集合</span><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// 队列容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capcity;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capcity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.capcity = capcity;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 检查队列是否为空</span><br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列为空, 消费者线程等待&quot;</span>);<br>                    list.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 从队列头部获取消息并返回</span><br>            Message message = list.removeFirst();<br>            log.debug(<span class="hljs-string">&quot;已消费消息 &#123;&#125;&quot;</span>, message);<br>            list.notifyAll();<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 存入消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Message message)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-comment">// 检查对象是否已满</span><br>            <span class="hljs-keyword">while</span> (list.size() == capcity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列已满, 生产者线程等待&quot;</span>);<br>                    list.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将消息加入队列尾部</span><br>            list.addLast(message);<br>            log.debug(<span class="hljs-string">&quot;已生产消息 &#123;&#125;&quot;</span>, message);<br>            list.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> Object value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Message&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, value=&quot;</span> + value +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">20:54:31 [生产者0] c.MessageQueue - 已生产消息 Message&#123;id=0, value=值0&#125;<br>20:54:31 [生产者1] c.MessageQueue - 已生产消息 Message&#123;id=1, value=值1&#125;<br>20:54:31 [生产者2] c.MessageQueue - 队列已满, 生产者线程等待<br>20:54:32 [消费者] c.MessageQueue - 已消费消息 Message&#123;id=0, value=值0&#125;<br>20:54:32 [生产者2] c.MessageQueue - 已生产消息 Message&#123;id=2, value=值2&#125;<br>20:54:33 [消费者] c.MessageQueue - 已消费消息 Message&#123;id=1, value=值1&#125;<br>20:54:34 [消费者] c.MessageQueue - 已消费消息 Message&#123;id=2, value=值2&#125;<br>20:54:35 [消费者] c.MessageQueue - 队列为空, 消费者线程等待<br></code></pre></td></tr></table></figure><h2 id="4-9-Park-Unpark"><a href="#4-9-Park-Unpark" class="headerlink" title="4.9 Park/Unpark"></a>4.9 Park/Unpark</h2><h3 id="4-9-1-基本使用"><a href="#4-9-1-基本使用" class="headerlink" title="4.9.1 基本使用"></a>4.9.1 基本使用</h3><p>它们是 <code>LockSupport</code> 类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 暂停当前线程</span><br>LockSupport.park(); <br><br><span class="hljs-comment">// 恢复某个线程的运行</span><br>LockSupport.unpark(暂停线程对象)<br></code></pre></td></tr></table></figure><p><strong>先 park 再 unpark</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>sleep(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>LockSupport.park();<br>log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);<br>&#125;<br>,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br>sleep(<span class="hljs-number">2</span>);<br>log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>LockSupport.unpark(t1);<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">52.585</span> c.TestParkUnpark [t1] - start... <br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">53.589</span> c.TestParkUnpark [t1] - park... <br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">54.583</span> c.TestParkUnpark [main] - unpark... <br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">54.583</span> c.TestParkUnpark [t1] - resume...<br></code></pre></td></tr></table></figure><p><strong>先 unpark 再 park</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>sleep(<span class="hljs-number">2</span>);<br>log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>LockSupport.park();<br>log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br>sleep(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>LockSupport.unpark(t1);<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">50.765</span> c.TestParkUnpark [t1] - start... <br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">51.764</span> c.TestParkUnpark [main] - unpark... <br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">52.769</span> c.TestParkUnpark [t1] - park... <br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">52.769</span> c.TestParkUnpark [t1] - resume...<br></code></pre></td></tr></table></figure><h3 id="4-9-2-特点"><a href="#4-9-2-特点" class="headerlink" title="4.9.2 特点"></a>4.9.2 特点</h3><p>与 Object 的 wait &amp; notify 相比</p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li><li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li></ul><h3 id="4-9-3-原理之park-amp-unpark"><a href="#4-9-3-原理之park-amp-unpark" class="headerlink" title="4.9.3 * 原理之park&amp;unpark"></a>4.9.3 * 原理之park&amp;unpark</h3><p>每个线程都有自己的一个 Parker 对象，由三部分组成 <code>_counter</code> ， <code>_cond</code> 和 <code>_mutex</code> 打个比喻</p><ul><li>线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中的备用干粮（0 为耗尽，1 为充足）</li><li>调用 park 就是要看需不需要停下来歇息<ul><li>如果备用干粮耗尽，那么钻进帐篷歇息</li><li>如果备用干粮充足，那么不需停留，继续前进</li></ul></li><li>调用 unpark，就好比令干粮充足<ul><li>如果这时线程还在帐篷，就唤醒让他继续前进</li><li>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进<ul><li>因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮</li></ul></li></ul></li></ul><p><img src="http://image.cryptomartin.top/img/image-20211230142714631.png" alt="image-20211230142714631"></p><ol><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁</li><li>线程进入 _cond 条件变量阻塞</li><li>设置 _counter = 0</li></ol><p><img src="http://image.cryptomartin.top/img/image-20211230142906331.png" alt="image-20211230142906331"></p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0</li><li>Thread_0 恢复运行</li><li>设置 _counter 为 0</li></ol><p><strong>调用unpark再调用park</strong></p><p><img src="http://image.cryptomartin.top/img/image-20211230143136595.png" alt="image-20211230143136595"></p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</li><li>设置 _counter 为 0</li></ol><h2 id="4-10-重新理解线程状态转换"><a href="#4-10-重新理解线程状态转换" class="headerlink" title="4.10 重新理解线程状态转换"></a>4.10 重新理解线程状态转换</h2><p><img src="http://image.cryptomartin.top/img/image-20211230143657808.png" alt="image-20211230143657808"></p><p>假设有线程 <code>Thread t</code></p><h3 id="4-10-1-情况1-NEW-–-gt-RUNNABLE"><a href="#4-10-1-情况1-NEW-–-gt-RUNNABLE" class="headerlink" title="4.10.1 情况1 NEW –&gt; RUNNABLE"></a>4.10.1 情况1 NEW –&gt; RUNNABLE</h3><p>当线程调用 <code>t.start()</code> 方法时，由 <code>NEW --&gt; RUNNABLE</code></p><p>RUNNABLE包含：</p><ul><li>可运行状态：可以获得CPU时间片的状态</li><li>运行状态：已经获得时间片，正在CPU执行的状态</li><li>阻塞状态：调用操作系统的阻塞IO的API，它会陷入阻塞，但在Java层面看不出来，依旧是RUNNABLE状态</li></ul><h3 id="4-10-2-情况2-RUNNABLE-lt-–-gt-WAITING"><a href="#4-10-2-情况2-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="4.10.2 情况2 RUNNABLE &lt;–&gt;WAITING"></a>4.10.2 情况2 RUNNABLE &lt;–&gt;WAITING</h3><p>t 线程用 <code>synchronized(obj) </code>获取了对象锁后</p><ul><li>调用 <code>obj.wait() </code>方法时，t 线程从 <code>RUNNABLE --&gt; WAITING</code></li><li>调用 <code>obj.notify()</code> ， <code>obj.notifyAll() </code>，<code> t.interrupt()</code> 时<ul><li>竞争锁成功，t 线程从 <code>WAITING --&gt; RUNNABLE</code></li><li>竞争锁失败，t 线程从 <code>WAITING --&gt; BLOCKED</code></li></ul></li></ul><blockquote><p>在entryList中排队竞争锁，这时线程是处于BLOCKED状态</p></blockquote><h3 id="4-10-3-情况3-RUNNABLE-lt-–-gt-WAITING"><a href="#4-10-3-情况3-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="4.10.3 情况3 RUNNABLE &lt;–&gt;WAITING"></a>4.10.3 情况3 RUNNABLE &lt;–&gt;WAITING</h3><ul><li>当前线程调用 <code>t.join()</code> 方法时，当前线程从 <code>RUNNABLE --&gt; WAITING</code><ul><li>注意是当前线程在t 线程对象的监视器上等待</li></ul></li><li>t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 <code>WAITING --&gt; RUNNABLE</code></li></ul><h3 id="4-10-4-情况4-RUNNABLE-lt-–-gt-WAITING"><a href="#4-10-4-情况4-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="4.10.4 情况4 RUNNABLE &lt;–&gt;WAITING"></a>4.10.4 情况4 RUNNABLE &lt;–&gt;WAITING</h3><ul><li><p>当前线程调用 <code>LockSupport.park()</code> 方法会让当前线程从 <code>RUNNABLE --&gt; WAITING</code></p></li><li><p>调用 <code>LockSupport.unpark</code>(目标线程) 或调用了线程 的 <code>interrupt()</code> ，会让目标线程从 <code>WAITING --&gt; RUNNABLE</code></p></li></ul><h3 id="4-10-5-情况5-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#4-10-5-情况5-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="4.10.5 情况5 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>4.10.5 情况5 RUNNABLE &lt;–&gt; TIMED_WAITING</h3><p>t 线程用 <code>synchronized(obj)</code> 获取了对象锁后</p><ul><li>调用 <code>obj.wait(long n)</code> 方法时，t 线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li><li>t 线程等待时间超过了 n 毫秒，或调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt()</code> 时<ul><li>竞争锁成功，t 线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li><li>竞争锁失败，t 线程从 <code>TIMED_WAITING --&gt; BLOCKED</code></li></ul></li></ul><h3 id="4-10-6-情况6-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#4-10-6-情况6-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="4.10.6 情况6 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>4.10.6 情况6 RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 <code>t.join(long n)</code> 方法时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code><ul><li>注意是当前线程在t 线程对象的监视器上等待</li></ul></li><li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从<code>TIMED_WAITING --&gt; RUNNABLE</code></li></ul><h3 id="4-10-7-情况7-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#4-10-7-情况7-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="4.10.7 情况7 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>4.10.7 情况7 RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 <code>Thread.sleep(long n)</code> ，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li><li>当前线程等待时间超过了 n 毫秒，当前线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li></ul><h3 id="4-10-8-情况8-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#4-10-8-情况8-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="4.10.8 情况8 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>4.10.8 情况8 RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis)</code> 时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li><li>调用 <code>LockSupport.unpark</code>(目标线程) 或调用了线程 的 <code>interrupt()</code> ，或是等待超时，会让目标线程从<code>TIMED_WAITING--&gt; RUNNABLE</code></li></ul><h3 id="4-10-9-情况9-RUNNABLE-lt-–-gt-BLOCKED"><a href="#4-10-9-情况9-RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="4.10.9 情况9 RUNNABLE &lt;–&gt; BLOCKED"></a>4.10.9 情况9 RUNNABLE &lt;–&gt; BLOCKED</h3><ul><li>t 线程用 <code>synchronized(obj)</code> 获取了对象锁时如果竞争失败，从 <code>RUNNABLE --&gt; BLOCKED</code></li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 <code>BLOCKED</code> 的线程重新竞争，如果其中 t 线程竞争成功，从 <code>BLOCKED --&gt; RUNNABLE</code> ，其它失败的线程仍然 <code>BLOCKED</code></li></ul><h3 id="4-10-10-RUNNABLE-lt-–-gt-TERMINATED"><a href="#4-10-10-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="4.10.10 RUNNABLE &lt;–&gt; TERMINATED"></a>4.10.10 RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线程所有代码运行完毕，进入 <code>TERMINATED</code></p><h2 id="4-11-多把锁"><a href="#4-11-多把锁" class="headerlink" title="4.11 多把锁"></a>4.11 多把锁</h2><p><strong>多把不相干的锁</strong></p><p>一间大屋子有两个功能：睡觉、学习，互不相干。<br>现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低<br>解决方法是：准备多个房间（多个对象锁）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>log.debug(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>Sleeper.sleep(<span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>log.debug(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>Sleeper.sleep(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">BigRoom bigRoom = <span class="hljs-keyword">new</span> BigRoom();<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>bigRoom.compute();<br>&#125;<br>,<span class="hljs-string">&quot;小南&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>bigRoom.sleep();<br>&#125;<br>,<span class="hljs-string">&quot;小女&quot;</span>).start();<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">12</span>:<span class="hljs-number">13</span>:<span class="hljs-number">54.471</span> [小南] c.BigRoom - study <span class="hljs-number">1</span> 小时<br><span class="hljs-number">12</span>:<span class="hljs-number">13</span>:<span class="hljs-number">55.476</span> [小女] c.BigRoom - sleeping <span class="hljs-number">2</span> 小时<br></code></pre></td></tr></table></figure><ul><li>两个线程都需要锁住<code>BigRoom</code>,导致一个线程陷入阻塞状态等待。</li></ul><p>改进,锁住不同的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object studyRoom = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object bedRoom = <span class="hljs-keyword">new</span> Object();<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (bedRoom) &#123;<br>log.debug(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>Sleeper.sleep(<span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (studyRoom) &#123;<br>log.debug(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>Sleeper.sleep(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">12</span>:<span class="hljs-number">15</span>:<span class="hljs-number">35.069</span> [小南] c.BigRoom - study <span class="hljs-number">1</span> 小时<br><span class="hljs-number">12</span>:<span class="hljs-number">15</span>:<span class="hljs-number">35.069</span> [小女] c.BigRoom - sleeping <span class="hljs-number">2</span> 小时<br></code></pre></td></tr></table></figure><p>将锁的粒度细分</p><ul><li>好处，是可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><h2 id="4-12-活跃性"><a href="#4-12-活跃性" class="headerlink" title="4.12 活跃性"></a>4.12 活跃性</h2><p>活跃性包括：死锁，活锁，饥饿</p><h3 id="4-12-1-死锁"><a href="#4-12-1-死锁" class="headerlink" title="4.12.1 死锁"></a>4.12.1 死锁</h3><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁<br><code>t1 线程</code> 获得 <code>A对象</code> 锁，接下来想获取 <code>B对象</code> 的锁<br><code>t2 线程</code> 获得 <code>B对象</code> 锁，接下来想获取 <code>A对象</code> 的锁 </p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">Object A = <span class="hljs-keyword">new</span> Object();<br>Object B = <span class="hljs-keyword">new</span> Object();<br><br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span> (A) &#123;<br>log.debug(<span class="hljs-string">&quot;lock A&quot;</span>);<br>sleep(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">synchronized</span> (B) &#123;<br>log.debug(<span class="hljs-string">&quot;lock B&quot;</span>);<br>log.debug(<span class="hljs-string">&quot;操作...&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span> (B) &#123;<br>log.debug(<span class="hljs-string">&quot;lock B&quot;</span>);<br>sleep(<span class="hljs-number">0.5</span>);<br><span class="hljs-keyword">synchronized</span> (A) &#123;<br>log.debug(<span class="hljs-string">&quot;lock A&quot;</span>);<br>log.debug(<span class="hljs-string">&quot;操作...&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>);<br>t1.start();<br>t2.start();<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">12</span>:<span class="hljs-number">22</span>:<span class="hljs-number">06.962</span> [t2] c.TestDeadLock - lock B <br><span class="hljs-number">12</span>:<span class="hljs-number">22</span>:<span class="hljs-number">06.962</span> [t1] c.TestDeadLock - lock A<br></code></pre></td></tr></table></figure><h3 id="4-12-2-定位死锁"><a href="#4-12-2-定位死锁" class="headerlink" title="4.12.2 定位死锁"></a>4.12.2 定位死锁</h3><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</p><p><img src="http://image.cryptomartin.top/img/image-20211230154805628.png" alt="image-20211230154805628"></p><p>进程id：11068</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;jstack 11068 //查看进程的线程信息<br>&gt;jconsole //线程 检测死锁<br></code></pre></td></tr></table></figure><h3 id="4-12-3-哲学家就餐问题"><a href="#4-12-3-哲学家就餐问题" class="headerlink" title="4.12.3 哲学家就餐问题"></a>4.12.3 哲学家就餐问题</h3><p><img src="http://image.cryptomartin.top/img/image-20211230163613155.png" alt="image-20211230163613155"></p><p>有五位哲学家，围坐在圆桌旁。</p><ul><li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</li><li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。</li><li>如果筷子被身边的人拿着，自己就得等待</li></ul><p>筷子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chopstick</span> </span>&#123;<br>String name;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chopstick</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>哲学家类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>Chopstick left;<br>Chopstick right;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;<br><span class="hljs-keyword">super</span>(name);<br><span class="hljs-keyword">this</span>.left = left;<br><span class="hljs-keyword">this</span>.right = right;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);<br>Sleeper.sleep(<span class="hljs-number">1</span>);<br>&#125;<br>    <br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-comment">// 获得左手筷子</span><br><span class="hljs-keyword">synchronized</span> (left) &#123;<br><span class="hljs-comment">// 获得右手筷子</span><br><span class="hljs-keyword">synchronized</span> (right) &#123;<br><span class="hljs-comment">// 吃饭</span><br>eat();<br>&#125;<br><span class="hljs-comment">// 放下右手筷子</span><br>&#125;<br><span class="hljs-comment">// 放下左手筷子</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就餐：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Chopstick c1 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;1&quot;</span>);<br>Chopstick c2 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;2&quot;</span>);<br>Chopstick c3 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;3&quot;</span>);<br>Chopstick c4 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;4&quot;</span>);<br>Chopstick c5 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;5&quot;</span>);<br><span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();<br><span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();<br><span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();<br><span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();<br><span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();<br></code></pre></td></tr></table></figure><p>执行不多会，就执行不下去了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">15.575</span> [苏格拉底] c.Philosopher - eating... <br><span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">15.575</span> [亚里士多德] c.Philosopher - eating... <br><span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">16.580</span> [阿基米德] c.Philosopher - eating... <br><span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">17.580</span> [阿基米德] c.Philosopher - eating... <br><span class="hljs-comment">// 卡在这里, 不向下运行</span><br></code></pre></td></tr></table></figure><p>可以使用 jconsole 检测死锁.</p><p>这种线程没有按预期结束，执行不下去的情况，归类为【活跃性】问题，除了死锁以外，还有活锁和饥饿者两种情况</p><h3 id="4-12-4-活锁"><a href="#4-12-4-活锁" class="headerlink" title="4.12.4 活锁"></a>4.12.4 活锁</h3><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLiveLock</span> </span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-comment">// 期望减到 0 退出循环</span><br><span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>sleep(<span class="hljs-number">0.2</span>);<br>count--;<br>log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-comment">// 期望超过 20 退出循环</span><br><span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>sleep(<span class="hljs-number">0.2</span>);<br>count++;<br>log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-12-5-饥饿"><a href="#4-12-5-饥饿" class="headerlink" title="4.12.5 饥饿"></a>4.12.5 饥饿</h3><p>很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不易演示，讲读写锁时会涉及饥饿问题</p><p><img src="http://image.cryptomartin.top/img/image-20211230164818269.png" alt="image-20211230164818269"></p><p>顺序加锁解锁方案：</p><p><img src="http://image.cryptomartin.top/img/image-20211230164840682.png" alt="image-20211230164840682"></p><p>每个线程都按锁AB的顺序来进行加锁！但会出现饥饿问题</p><h2 id="4-13-ReentrantLock"><a href="#4-13-ReentrantLock" class="headerlink" title="4.13 ReentrantLock"></a>4.13 ReentrantLock</h2><p>相对于 synchronized 它具备如下特点</p><ul><li><p>可中断：A线程拥有锁，B线程可以把锁取消掉</p></li><li><p>可以设置超时时间：规定时间内，得不到锁，就放弃锁了，去做其他事。</p></li><li><p>可以设置为公平锁：防止线程饥饿。FIFO</p></li><li><p>支持多个条件变量：相当于synchronized 的waitSet,waitSet相当于一个条件变量。细分条件</p></li></ul><p>与 synchronized 一样，都支持可重入</p><p>基本语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁</span><br>reentrantLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 临界区</span><br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 释放锁</span><br>reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-13-1-可重入特性"><a href="#4-13-1-可重入特性" class="headerlink" title="4.13.1 可重入特性"></a>4.13.1 可重入特性</h3><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</p><p>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>method1();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;execute method1&quot;</span>);<br>method2();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;execute method2&quot;</span>);<br>method3();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;execute method3&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">17</span>:<span class="hljs-number">59</span>:<span class="hljs-number">11.862</span> [main] c.TestReentrant - execute method1 <br><span class="hljs-number">17</span>:<span class="hljs-number">59</span>:<span class="hljs-number">11.865</span> [main] c.TestReentrant - execute method2 <br><span class="hljs-number">17</span>:<span class="hljs-number">59</span>:<span class="hljs-number">11.865</span> [main] c.TestReentrant - execute method3<br></code></pre></td></tr></table></figure><h3 id="4-13-2-可打断特性-lockInterruptibly"><a href="#4-13-2-可打断特性-lockInterruptibly" class="headerlink" title="4.13.2 可打断特性 -lockInterruptibly"></a>4.13.2 可打断特性 -lockInterruptibly</h3><p>被动防止没有获得锁的线程 无限制等待下去。</p><p>lock -&gt; 调用后一直阻塞到获得锁</p><p>lockInterruptibly -&gt; 调用后一直阻塞到获得锁 但是接受中断信号(题主用过Thread#sleep吧)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>lock.lockInterruptibly();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>log.debug(<span class="hljs-string">&quot;等锁的过程中被打断&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><br><span class="hljs-keyword">try</span> &#123;<br>sleep(<span class="hljs-number">1</span>);<br>t1.interrupt();<br>log.debug(<span class="hljs-string">&quot;执行打断&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">02</span>:<span class="hljs-number">40.520</span> [main] c.TestInterrupt - 获得了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">02</span>:<span class="hljs-number">40.524</span> [t1] c.TestInterrupt - 启动... <br><span class="hljs-number">18</span>:<span class="hljs-number">02</span>:<span class="hljs-number">41.530</span> [main] c.TestInterrupt - 执行打断<br>java.lang.InterruptedException <br> at <br>java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchr<br>onizer.java:<span class="hljs-number">898</span>) <br> at <br>java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron<br>izer.java:<span class="hljs-number">1222</span>) <br> at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="hljs-number">335</span>) <br> at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$<span class="hljs-number">0</span>(TestInterrupt.java:<span class="hljs-number">17</span>) <br> at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>) <br><span class="hljs-number">18</span>:<span class="hljs-number">02</span>:<span class="hljs-number">41.532</span> [t1] c.TestInterrupt - 等锁的过程中被打断<br></code></pre></td></tr></table></figure><ul><li>注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><br><span class="hljs-keyword">try</span> &#123;<br>sleep(<span class="hljs-number">1</span>);<br>t1.interrupt();<br>log.debug(<span class="hljs-string">&quot;执行打断&quot;</span>);<br>sleep(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>log.debug(<span class="hljs-string">&quot;释放了锁&quot;</span>);<br>lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">56.261</span> [main] c.TestInterrupt - 获得了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">56.265</span> [t1] c.TestInterrupt - 启动... <br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">57.266</span> [main] c.TestInterrupt - 执行打断 <span class="hljs-comment">// 这时 t1 并没有被真正打断, 而是仍继续等待锁</span><br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">58.267</span> [main] c.TestInterrupt - 释放了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">58.267</span> [t1] c.TestInterrupt - 获得了锁<br></code></pre></td></tr></table></figure><h3 id="4-13-3-锁超时-trylock"><a href="#4-13-3-锁超时-trylock" class="headerlink" title="4.13.3 锁超时-trylock"></a>4.13.3 锁超时-trylock</h3><p>主动方式避免死等。</p><p><strong>立即失败</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br><span class="hljs-keyword">if</span> (!lock.tryLock()) &#123;<br>log.debug(<span class="hljs-string">&quot;获取立刻失败，返回&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><span class="hljs-keyword">try</span> &#123;<br>sleep(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">15</span>:<span class="hljs-number">02.918</span> [main] c.TestTimeout - 获得了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">15</span>:<span class="hljs-number">02.921</span> [t1] c.TestTimeout - 启动... <br><span class="hljs-number">18</span>:<span class="hljs-number">15</span>:<span class="hljs-number">02.921</span> [t1] c.TestTimeout - 获取立刻失败，返回<br></code></pre></td></tr></table></figure><p><strong>超时失败</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>log.debug(<span class="hljs-string">&quot;获取等待 1s 后失败，返回&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><span class="hljs-keyword">try</span> &#123;<br>sleep(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">19</span>:<span class="hljs-number">40.537</span> [main] c.TestTimeout - 获得了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">19</span>:<span class="hljs-number">40.544</span> [t1] c.TestTimeout - 启动... <br><span class="hljs-number">18</span>:<span class="hljs-number">19</span>:<span class="hljs-number">41.547</span> [t1] c.TestTimeout - 获取等待 1s 后失败，返回<br></code></pre></td></tr></table></figure><p><strong>使用 tryLock 解决哲学家就餐问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chopstick</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> </span>&#123;<br>String name;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chopstick</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>Chopstick left;<br>Chopstick right;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;<br><span class="hljs-keyword">super</span>(name);<br><span class="hljs-keyword">this</span>.left = left;<br><span class="hljs-keyword">this</span>.right = right;<br>&#125;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-comment">// 尝试获得左手筷子</span><br><span class="hljs-keyword">if</span> (left.tryLock()) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 尝试获得右手筷子</span><br><span class="hljs-keyword">if</span> (right.tryLock()) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>eat();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>right.unlock();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>left.unlock(); <span class="hljs-comment">//尝试获得右手筷子失败</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);<br>Sleeper.sleep(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-13-4-公平锁"><a href="#4-13-4-公平锁" class="headerlink" title="4.13.4 公平锁"></a>4.13.4 公平锁</h3><p>ReentrantLock 默认是不公平</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">false</span>);<br>lock.lock();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t&quot;</span> + i).start();<br>&#125;<br><span class="hljs-comment">// 1s 之后去争抢锁</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; start...&quot;</span>);<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;强行插入&quot;</span>).start();<br>lock.unlock();<br></code></pre></td></tr></table></figure><p>强行插入，有机会在中间输出</p><blockquote><p><strong>注意</strong>：该实验不一定总能复现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">t39 running... <br>t40 running... <br>t41 running... <br>t42 running... <br>t43 running... <br>强行插入 start... <br>强行插入 running... <br>t44 running... <br>t45 running... <br>t46 running... <br>t47 running... <br>t49 running..<br></code></pre></td></tr></table></figure><p>改为公平锁后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><p>强行插入，总是在最后输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">t465 running... <br>t464 running... <br>t477 running... <br>t442 running... <br>t468 running... <br>t493 running... <br>t482 running... <br>t485 running... <br>t481 running... <br>强行插入 running...<br></code></pre></td></tr></table></figure><p>公平锁一般没有必要，会降低并发度，后面分析原理时会讲解</p><h3 id="4-13-5-条件变量"><a href="#4-13-5-条件变量" class="headerlink" title="4.13.5 条件变量"></a>4.13.5 条件变量</h3><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待<br>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li></ul><p>使用要点：</p><ul><li>await 前需要获得锁</li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-keyword">static</span> Condition waitCigaretteQueue = lock.newCondition();<br><span class="hljs-keyword">static</span> Condition waitbreakfastQueue = lock.newCondition();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Boolean hasCigrette = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Boolean hasBreakfast = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>lock.lock();<br><span class="hljs-keyword">while</span> (!hasCigrette) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>waitCigaretteQueue.await();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>log.debug(<span class="hljs-string">&quot;等到了它的烟&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>).start();<br>    <br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>lock.lock();<br><span class="hljs-keyword">while</span> (!hasBreakfast) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>waitbreakfastQueue.await();<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>log.debug(<span class="hljs-string">&quot;等到了它的早餐&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br>).start();<br>sleep(<span class="hljs-number">1</span>);<br>sendBreakfast();<br>sleep(<span class="hljs-number">1</span>);<br>sendCigarette();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendCigarette</span><span class="hljs-params">()</span> </span>&#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;送烟来了&quot;</span>);<br>hasCigrette = <span class="hljs-keyword">true</span>;<br>waitCigaretteQueue.signal();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendBreakfast</span><span class="hljs-params">()</span> </span>&#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;送早餐来了&quot;</span>);<br>hasBreakfast = <span class="hljs-keyword">true</span>;<br>waitbreakfastQueue.signal();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">27.680</span> [main] c.TestCondition - 送早餐来了<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">27.682</span> [Thread-<span class="hljs-number">1</span>] c.TestCondition - 等到了它的早餐<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">28.683</span> [main] c.TestCondition - 送烟来了<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">28.683</span> [Thread-<span class="hljs-number">0</span>] c.TestCondition - 等到了它的烟<br></code></pre></td></tr></table></figure><h2 id="4-14-【模式】同步模式之顺序控制"><a href="#4-14-【模式】同步模式之顺序控制" class="headerlink" title="4.14 【模式】同步模式之顺序控制"></a>4.14 【模式】同步模式之顺序控制</h2><h3 id="4-14-1-固定运行顺序"><a href="#4-14-1-固定运行顺序" class="headerlink" title="4.14.1 固定运行顺序"></a>4.14.1 固定运行顺序</h3><p>比如，必须先打印 2 后 1</p><h4 id="4-14-1-1-wait-notify-版"><a href="#4-14-1-1-wait-notify-版" class="headerlink" title="4.14.1.1 wait notify 版"></a>4.14.1.1 wait notify 版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test25&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test25</span> </span>&#123;<br>    <span class="hljs-comment">//锁对象</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-comment">//标记线程t2是否打印2？</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> t2runned = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//线程t1</span><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">while</span> (!t2runned)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">//线程t2</span><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                t2runned=<span class="hljs-keyword">true</span>;<br>                lock.notify();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">28</span>:<span class="hljs-number">47</span> [t2] c.Test25 - <span class="hljs-number">2</span><br><span class="hljs-number">11</span>:<span class="hljs-number">28</span>:<span class="hljs-number">47</span> [t1] c.Test25 - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="4-14-1-2-Park-Unpark-版"><a href="#4-14-1-2-Park-Unpark-版" class="headerlink" title="4.14.1.2  Park Unpark 版"></a>4.14.1.2  Park Unpark 版</h4><p>park 和 unpark 方法比较灵活，他俩谁先调用，谁后调用无所谓。并且是以线程为单位进行『暂停』和『恢复』，不需要『同步对象』和『运行标记』</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test26&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test26</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;);<br><br>        Thread t2= <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>            LockSupport.unpark(t1);<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-14-2-交替输出"><a href="#4-14-2-交替输出" class="headerlink" title="4.14.2 交替输出"></a>4.14.2 交替输出</h3><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现</p><h4 id="4-14-2-1-wait-notify-版"><a href="#4-14-2-1-wait-notify-版" class="headerlink" title="4.14.2.1 wait notify 版"></a>4.14.2.1 wait notify 版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test27&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test27</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        WaitNotify wn = <span class="hljs-keyword">new</span> WaitNotify(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br><br>        Thread a = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            wn.print(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        &#125;);<br><br>        Thread b = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            wn.print(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        &#125;);<br><br>        Thread c = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            wn.print(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>        &#125;);<br><br>        a.start();<br>        b.start();<br>        c.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    等待标记   下一次标记</span><br><span class="hljs-comment">a     1         2</span><br><span class="hljs-comment">b     2         3</span><br><span class="hljs-comment">c     3         1</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotify</span> </span>&#123;<br>    <span class="hljs-comment">//标记轮到哪个</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flag;<br>    <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WaitNotify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.flag = flag;<br>        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> waitFlag, <span class="hljs-keyword">int</span> nextFlag)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= loopNumber; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">while</span> (flag != waitFlag) &#123;<span class="hljs-comment">//判断是不是轮到waitFlag,如果没轮到就等待</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//如果轮到自己，就打印;并且修改 flag的值为nextFlag;唤醒其他线程</span><br>                System.out.print(str);<br>                flag = nextFlag;<br>                <span class="hljs-keyword">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-14-2-2-await-signal-版"><a href="#4-14-2-2-await-signal-版" class="headerlink" title="4.14.2.2 await signal 版"></a>4.14.2.2 await signal 版</h4><p>条件变量（Condition Variable）的一般用法是：线程 A 等待某个条件并挂起，直到线程 B 设置了这个条件，并通知条件变量，然后线程 A 被唤醒。经典的「生产者-消费者」问题就可以用条件变量来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test30&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test30</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        AwaitSignal as = <span class="hljs-keyword">new</span> AwaitSignal(<span class="hljs-number">5</span>);<br><br>        Condition aCondition = as.newCondition();<br>        Condition bCondition = as.newCondition();<br>        Condition cCondition = as.newCondition();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            as.print(<span class="hljs-string">&quot;a&quot;</span>, aCondition, bCondition);<br>        &#125;, <span class="hljs-string">&quot;a&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            as.print(<span class="hljs-string">&quot;b&quot;</span>, bCondition, cCondition);<br>        &#125;, <span class="hljs-string">&quot;b&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            as.print(<span class="hljs-string">&quot;c&quot;</span>, cCondition, aCondition);<br>        &#125;, <span class="hljs-string">&quot;c&quot;</span>).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        as.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            aCondition.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            as.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> </span>&#123;<br>    <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AwaitSignal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, Condition current, Condition next)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            lock();<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                current.await(); <span class="hljs-comment">//所有线程进入等待，释放锁</span><br>                <span class="hljs-comment">//被唤醒后，打印</span><br>                System.out.print(str);<br>                <span class="hljs-comment">//唤醒下一个线程</span><br>                next.signal();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-14-2-3-park-unpark-版"><a href="#4-14-2-3-park-unpark-版" class="headerlink" title="4.14.2.3 park unpark 版"></a>4.14.2.3 park unpark 版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test31&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test31</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Thread t1;<br>    <span class="hljs-keyword">static</span> Thread t2;<br>    <span class="hljs-keyword">static</span> Thread t3;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ParkUnPark parkUnPark = <span class="hljs-keyword">new</span> ParkUnPark(<span class="hljs-number">5</span>);<br>        t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            parkUnPark.print(<span class="hljs-string">&quot;a&quot;</span>, t2);<br>        &#125;);<br><br>        t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            parkUnPark.print(<span class="hljs-string">&quot;b&quot;</span>, t3);<br>        &#125;);<br><br>        t3 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            parkUnPark.print(<span class="hljs-string">&quot;c&quot;</span>, t1);<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>        LockSupport.unpark(t1);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkUnPark</span> </span>&#123;<br>    <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> looNumber;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParkUnPark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> looNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.looNumber = looNumber;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, Thread next)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; looNumber; i++) &#123;<br>            LockSupport.park();<span class="hljs-comment">//当前线程等待</span><br>            <span class="hljs-comment">//当前线程打印字符</span><br>            System.out.print(str);<br>            <span class="hljs-comment">//唤醒下一个线程</span><br>            LockSupport.unpark(next);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-15-本章小结"><a href="#4-15-本章小结" class="headerlink" title="4.15 本章小结"></a>4.15 本章小结</h2><p>本章我们需要重点掌握的是：</p><ul><li>分析多线程访问共享资源时，哪些代码片段属于临界区</li><li>使用 synchronized 互斥解决临界区的线程安全问题<ul><li>掌握 synchronized 锁对象语法</li><li>掌握 synchronzied 加载成员方法和静态方法语法</li><li>掌握 wait/notify 同步方法</li></ul></li><li>使用 lock 互斥解决临界区的线程安全问题<ul><li>掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量</li></ul></li><li>学会分析变量的线程安全性、掌握常见线程安全类的使用</li><li>了解线程活跃性问题：死锁、活锁、饥饿</li><li>应用方面<ul><li>互斥：使用 synchronized 或 Lock 达到共享资源互斥效果</li><li>同步：使用 wait/notify 或 Lock 的条件变量来达到线程间通信效果</li></ul></li><li>原理方面<ul><li>monitor、synchronized 、wait/notify 原理</li><li>synchronized 进阶原理</li><li>park &amp; unpark 原理</li></ul></li><li>模式方面<ul><li>同步模式之保护性暂停</li><li>异步模式之生产者消费者</li><li>同步模式之顺序控制</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 JVM的内存结构</title>
    <link href="/2021/12/24/%E7%AC%AC%E4%B8%80%E7%AB%A0-JVM%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/2021/12/24/%E7%AC%AC%E4%B8%80%E7%AB%A0-JVM%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-JVM的内存结构"><a href="#第一章-JVM的内存结构" class="headerlink" title="第一章 JVM的内存结构"></a>第一章 JVM的内存结构</h1><p><strong>本章内容</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li></ul><h2 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h2><p>所处位置</p><p><img src="http://image.cryptomartin.top/img/image-20211222083645693.png" alt="image-20211222083645693"></p><h3 id="1-1-1-定义"><a href="#1-1-1-定义" class="headerlink" title="1.1.1 定义"></a>1.1.1 定义</h3><p>Program Counter Register 程序计数器（寄存器）</p><ul><li><p>作用：记住下一条JVM指令的执行地址。</p></li><li><p>特点</p><ul><li>是线程私有的（每个线程都有自己的程序计数器）</li><li>不会存在内存溢出</li></ul></li></ul><p>物理上，是通过寄存器实现的。</p><h3 id="1-1-2-作用"><a href="#1-1-2-作用" class="headerlink" title="1.1.2 作用"></a>1.1.2 作用</h3><p><img src="http://image.cryptomartin.top/img/image-20211222084432356.png" alt="image-20211222084432356"></p><blockquote><p>1.java源代码不能直接被执行，得经过编译。编译成左侧的二进制的字节码，叫作JVM指令。</p><p>2.JVM指令直接交给CPU，还不能执行；必须经过解释器，解释成机器码，然后再交给CPU执行。</p></blockquote><p>作用：记住下一条JVM指令的执行地址。</p><ul><li><p>图中的数字，可以理解为JVM指令对应的内存地址，当这些JVM指令被加载到虚拟机内存后，会有一个地址信息，JVM根据地址信息可以找到JVM指令，来执行它。</p></li><li><p>当这些指令被加载JVM内存以后，JVM会有这些地址信息。根据地址信息找到第一条，当第一条<code>0: getstatic #20</code>执行，与此同时，会把下一条执行的地址<code>3</code>放入程序计数器；等第一条执行完以后，<code>解释器</code>会到<code>程序计数器</code>中找到下一条执行的指令地址<code>3</code>，在<code>3</code>指令执行的同时，会把<code>4</code>地址放入程序计数器。重复！</p></li></ul><h2 id="1-2-虚拟机栈"><a href="#1-2-虚拟机栈" class="headerlink" title="1.2 虚拟机栈"></a>1.2 虚拟机栈</h2><p><img src="http://image.cryptomartin.top/img/image-20211222204215587.png" alt="image-20211222204215587"></p><p>虚拟机栈，就是线程运行需要的内存空间。</p><p>栈帧，就是每个方法运行需要的内存空间。一个栈帧就对应一次方法的调用。</p><p>一个栈由多个栈帧组成。</p><h3 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1 定义"></a>1.2.1 定义</h3><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><ul><li>每个线程运行时所需要的内存，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p>问题辨析：</p><ol><li><p>垃圾回收是否涉及栈内存？不涉及，栈帧内存每次方法结束后，都会被弹出栈，会被自动回收，不需要垃圾回收管理。</p></li><li><p>栈内存分配越大越好吗？不是。栈越大，线程数会少。一般采用系统默认的栈内存1024kb就好了。</p></li><li><p>方法内的局部变量是否线程安全？</p><ul><li><p>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的</p></li><li><p>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</p></li></ul></li></ol><p><img src="http://image.cryptomartin.top/img/image-20211222225101335.png" alt="image-20211222225101335"></p><h3 id="1-2-2-栈溢出"><a href="#1-2-2-栈溢出" class="headerlink" title="1.2.2 栈溢出"></a>1.2.2 栈溢出</h3><p>什么情况下会导致栈溢出？</p><ul><li>栈帧过多导致栈内存溢出 （递归/对象相互引用…）</li><li>栈帧过大导致栈内存溢出</li></ul><h3 id="1-2-3-线程运行诊断"><a href="#1-2-3-线程运行诊断" class="headerlink" title="1.2.3 线程运行诊断"></a>1.2.3 线程运行诊断</h3><p>案例1： cpu 占用过多</p><p>定位</p><ul><li>用top定位哪个进程对cpu的占用过高，但定位不到是哪个线程导致问题</li><li>ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高）</li><li>jstack 进程id<ul><li>可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号（线程id 转为十六进制查看）</li></ul></li></ul><p>案例2：程序运行很长时间没有结果</p><p>可能发生死锁。可以使用案例1方法查看。</p><h2 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h2><p><img src="http://image.cryptomartin.top/img/image-20211222233156739.png" alt="image-20211222233156739"></p><p>本地方法：不是由java编写的代码。有时候需要通过调用操作系统，这时候需要c或者c++编写的本地方法来与操作系统底层API交流。</p><p>本地方法栈：给本地方法的调用提供内存空间</p><p>例如：<code>object</code>类里的<code>clone()</code>方法</p><p><img src="http://image.cryptomartin.top/img/image-20211222234406180.png" alt="image-20211222234406180"></p><h2 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4 堆"></a>1.4 堆</h2><p><img src="http://image.cryptomartin.top/img/image-20211222234505594.png" alt="image-20211222234505594"></p><p>堆和方法区是线程共享的区域；其他内存结构是线程私有的。</p><h3 id="1-4-1-定义"><a href="#1-4-1-定义" class="headerlink" title="1.4.1 定义"></a>1.4.1 定义</h3><p>Heap 堆</p><ul><li>通过 new 关键字，创建对象都会使用堆内存</li></ul><p>特点</p><ul><li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul><h3 id="1-4-2-堆内存溢出"><a href="#1-4-2-堆内存溢出" class="headerlink" title="1.4.2 堆内存溢出"></a>1.4.2 堆内存溢出</h3><p><code>java.lang.OutOfMemoryError: Java heap space</code></p><p><code>-Xmx8m</code>:设置堆内存大小</p><h3 id="1-4-3-堆内存诊断"><a href="#1-4-3-堆内存诊断" class="headerlink" title="1.4.3 堆内存诊断"></a>1.4.3 堆内存诊断</h3><ol><li><p>jps 工具<br>查看当前系统中有哪些 java 进程</p></li><li><p>jmap 工具<br>查看堆内存占用情况 jmap - heap 进程id</p></li><li><p>jconsole 工具<br>图形界面的，多功能的监测工具，可以连续监测</p></li></ol><h3 id="1-4-4-案例"><a href="#1-4-4-案例" class="headerlink" title="1.4.4 案例"></a>1.4.4 案例</h3><ul><li>垃圾回收后，内存占用仍然很高</li></ul><p><code>jvisualvm</code>:可以查看堆Dump,分析查找问题</p><h2 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h2><p><img src="http://image.cryptomartin.top/img/image-20211223152803582.png" alt="image-20211223152803582"> </p><h3 id="1-5-1-定义"><a href="#1-5-1-定义" class="headerlink" title="1.5.1 定义"></a>1.5.1 定义</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the &quot;text&quot; segment in an operating system process. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods (§2.9) used in class and instance initialization and interface initialization.<br><br>The method area is created on virtual machine start-up. Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it. This specification does not mandate the location of the method area or the policies used to manage compiled code. The method area may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger method area becomes unnecessary. The memory for the method area does not need to be contiguous.<br><br>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the method area, as well as, in the case of a varying-size method area, control over the maximum and minimum method area size.<br><br>The following exceptional condition is associated with the method area:<br><span class="hljs-bullet">-</span> If memory in the method area cannot be made available to satisfy an allocation request, the Java Virtual Machine throws an OutOfMemoryError.<br></code></pre></td></tr></table></figure><h3 id="1-5-2-组成"><a href="#1-5-2-组成" class="headerlink" title="1.5.2 组成"></a>1.5.2 组成</h3><p><img src="http://image.cryptomartin.top/img/image-20211223153516263.png" alt="image-20211223153516263"></p><p><strong>JVM内存结构1.6</strong></p><ul><li><p>有堆，Method area。</p></li><li><p><code>Method area</code> 是概念上的东西，1.6版本用<code>永久代</code>的方法作为实现。</p></li><li><p><code>永久代</code>包含:存储类的信息(field，method,构造器等等)，类加载器；还有一块运行时常量池，运行池常量池里有个重要的东西<code>StringTable</code>字符串表。</p></li></ul><p><img src="http://image.cryptomartin.top/img/image-20211223154117117.png" alt="image-20211223154117117"></p><p><strong>JVM内存结构1.8</strong></p><ul><li><code>Method area</code>还是概念上的东西</li><li>方法区的实现叫作<code>Metaspace</code>元空间，<code>Metaspace</code>里存储类，类加载器，常量池的信息。</li><li>方法区不占用堆内存了，不是由JVM来管理方法区的内存结构了；方法区被转移到<code>本地内存</code>当中！<code>本地内存</code>-&gt;<code>操作系统内存</code></li><li><code>StringTable</code>字符串表在堆里面</li></ul><h3 id="1-5-3-方法区内存溢出"><a href="#1-5-3-方法区内存溢出" class="headerlink" title="1.5.3 方法区内存溢出"></a>1.5.3 方法区内存溢出</h3><ul><li><p>1.8 以前会导致永久代内存溢出</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 演示永久代内存溢出 java.lang.OutOfMemoryError: PermGen space <br><span class="hljs-bullet">*</span> -XX:MaxPermSize=8m<br></code></pre></td></tr></table></figure></li><li><p>1.8 之后会导致元空间内存溢出</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace <br><span class="hljs-bullet">*</span> -XX:MaxMetaspaceSize=8m<br></code></pre></td></tr></table></figure></li></ul><p><strong>场景</strong></p><ul><li>Spring</li><li>mybatis</li></ul><p>字节码的动态生成。 </p><h3 id="1-5-4-运行时常量池"><a href="#1-5-4-运行时常量池" class="headerlink" title="1.5.4 运行时常量池"></a>1.5.4 运行时常量池</h3><p><code>javap -v HelloWorld.class</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//类的基本信息<br>Classfile /E:/JavaProject/cocurrent/Java<span class="hljs-emphasis">_concurrent/src/main/java/com/sunk/jvm/t1/t5/HelloWorld.class</span><br><span class="hljs-emphasis">  Last modified 2021-12-23; size 444 bytes</span><br><span class="hljs-emphasis">  MD5 checksum b00ce07193edf9b24a43ce9f1cc4d75a</span><br><span class="hljs-emphasis">  Compiled from &quot;HelloWorld.java&quot;</span><br><span class="hljs-emphasis">public class com.sunk.jvm.t1.t5.HelloWorld</span><br><span class="hljs-emphasis">  minor version: 0</span><br><span class="hljs-emphasis">  major version: 52</span><br><span class="hljs-emphasis">  flags: ACC_</span>PUBLIC, ACC<span class="hljs-emphasis">_SUPER</span><br><span class="hljs-emphasis">//常量池</span><br><span class="hljs-emphasis">Constant pool:</span><br><span class="hljs-emphasis">   #1 = Methodref          #6.#15         // java/lang/Object.&quot;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">init</span>&gt;</span></span>&quot;:()V</span><br><span class="hljs-emphasis">   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="hljs-emphasis">   #3 = String             #18            // hello world</span><br><span class="hljs-emphasis">   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="hljs-emphasis">   #5 = Class              #21            // com/sunk/jvm/t1/t5/HelloWorld</span><br><span class="hljs-emphasis">   #6 = Class              #22            // java/lang/Object</span><br><span class="hljs-emphasis">   #7 = Utf8               <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">init</span>&gt;</span></span></span><br><span class="hljs-emphasis">   #8 = Utf8               ()V</span><br><span class="hljs-emphasis">   #9 = Utf8               Code</span><br><span class="hljs-emphasis">  #10 = Utf8               LineNumberTable</span><br><span class="hljs-emphasis">  #11 = Utf8               main</span><br><span class="hljs-emphasis">  #12 = Utf8               ([Ljava/lang/String;)V</span><br><span class="hljs-emphasis">  #13 = Utf8               SourceFile</span><br><span class="hljs-emphasis">  #14 = Utf8               HelloWorld.java</span><br><span class="hljs-emphasis">  #15 = NameAndType        #7:#8          // &quot;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">init</span>&gt;</span></span>&quot;:()V</span><br><span class="hljs-emphasis">  #16 = Class              #23            // java/lang/System</span><br><span class="hljs-emphasis">  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;</span><br><span class="hljs-emphasis">  #18 = Utf8               hello world</span><br><span class="hljs-emphasis">  #19 = Class              #26            // java/io/PrintStream</span><br><span class="hljs-emphasis">  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V</span><br><span class="hljs-emphasis">  #21 = Utf8               com/sunk/jvm/t1/t5/HelloWorld</span><br><span class="hljs-emphasis">  #22 = Utf8               java/lang/Object</span><br><span class="hljs-emphasis">  #23 = Utf8               java/lang/System</span><br><span class="hljs-emphasis">  #24 = Utf8               out</span><br><span class="hljs-emphasis">  #25 = Utf8               Ljava/io/PrintStream;</span><br><span class="hljs-emphasis">  #26 = Utf8               java/io/PrintStream</span><br><span class="hljs-emphasis">  #27 = Utf8               println</span><br><span class="hljs-emphasis">  #28 = Utf8               (Ljava/lang/String;)V</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">//类的方法定义</span><br><span class="hljs-emphasis">&#123;</span><br><span class="hljs-emphasis">  public com.sunk.jvm.t1.t5.HelloWorld(); //构造方法</span><br><span class="hljs-emphasis">    descriptor: ()V</span><br><span class="hljs-emphasis">    flags: ACC_</span>PUBLIC<br><span class="hljs-code">    Code:</span><br><span class="hljs-code">      stack=1, locals=1, args_size=1</span><br><span class="hljs-code">         0: aload_0</span><br><span class="hljs-code">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-code">         4: return</span><br><span class="hljs-code">      LineNumberTable:</span><br><span class="hljs-code">        line 8: 0</span><br><span class="hljs-code"></span><br>  public static void main(java.lang.String[]); //main方法<br><span class="hljs-code">    descriptor: ([Ljava/lang/String;)V</span><br><span class="hljs-code">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="hljs-code">    Code:</span><br><span class="hljs-code">      stack=2, locals=1, args_size=1</span><br><span class="hljs-code">        //从这开始；虚拟机指令</span><br><span class="hljs-code">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;  //#2要去查常量池的表</span><br><span class="hljs-code">         3: ldc           #3                  // String hello world</span><br><span class="hljs-code">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="hljs-code">         8: return</span><br><span class="hljs-code">      LineNumberTable:</span><br><span class="hljs-code">        line 10: 0</span><br><span class="hljs-code">        line 11: 8</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code">SourceFile: &quot;HelloWorld.java&quot;</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><ul><li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li><li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为内存中的真实地址。程序运行时，常量池会放入本地内存中，变成运行时常量池。<code>#1</code>,<code>#2</code>也会变成内存中的地址。</li></ul><h3 id="1-5-5-StringTable"><a href="#1-5-5-StringTable" class="headerlink" title="1.5.5 StringTable"></a>1.5.5 StringTable</h3><ul><li><p>常量池中的字符串仅是符号，第一次用到时才变为对象</p></li><li><p>利用串池的机制，来避免重复创建字符串对象</p></li><li><p>字符串变量拼接的原理是 StringBuilder （1.8）</p></li><li><p>字符串常量拼接的原理是编译期优化</p></li><li><p>可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池</p><ul><li><p>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池;无论有没有，都 会把串池中的对象返回</p></li><li><p>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池； 会把串池中的对象返回</p></li></ul></li></ul><p>先看几道面试题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>String s3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>String s4 = s1 + s2;<br>String s5 = <span class="hljs-string">&quot;ab&quot;</span>;<br>String s6 = s4.intern();<br><br><span class="hljs-comment">// 问</span><br>System.out.println(s3 == s4);<br>System.out.println(s3 == s5);<br>System.out.println(s3 == s6);<br><br>String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>);<br>String x1 = <span class="hljs-string">&quot;cd&quot;</span>;<br>x2.intern();<br><br><span class="hljs-comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢 </span><br>System.out.println(x1 == x2);<br></code></pre></td></tr></table></figure><h4 id="1-5-5-1-常量池与串池的关系"><a href="#1-5-5-1-常量池与串池的关系" class="headerlink" title="1.5.5.1 常量池与串池的关系"></a>1.5.5.1 常量池与串池的关系</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_22</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>        String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译<code>javap -v Demo1_22.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java">Classfile /E:/JavaProject/cocurrent/Java_concurrent/src/main/java/com/sunk/jvm/t1/Demo1_22.class<br>  Last modified <span class="hljs-number">2021</span>-<span class="hljs-number">12</span>-<span class="hljs-number">24</span>; size <span class="hljs-number">320</span> bytes<br>  MD5 checksum 4cc52650a9c6199ee5039970ac0450c0<br>  Compiled from <span class="hljs-string">&quot;Demo1_22.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">sunk</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">t1</span>.<span class="hljs-title">Demo1_22</span></span><br><span class="hljs-class">  <span class="hljs-title">minor</span> <span class="hljs-title">version</span>: 0</span><br><span class="hljs-class">  <span class="hljs-title">major</span> <span class="hljs-title">version</span>: 52</span><br><span class="hljs-class">  <span class="hljs-title">flags</span>: <span class="hljs-title">ACC_PUBLIC</span>, <span class="hljs-title">ACC_SUPER</span></span><br><span class="hljs-class"><span class="hljs-title">Constant</span> <span class="hljs-title">pool</span>:</span><br><span class="hljs-class">   #1 </span>= Methodref          #<span class="hljs-number">6.</span>#<span class="hljs-number">15</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = String             #<span class="hljs-number">16</span>            <span class="hljs-comment">// a</span><br>   #<span class="hljs-number">3</span> = String             #<span class="hljs-number">17</span>            <span class="hljs-comment">// b</span><br>   #<span class="hljs-number">4</span> = String             #<span class="hljs-number">18</span>            <span class="hljs-comment">// ab</span><br>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">19</span>            <span class="hljs-comment">// com/sunk/jvm/t1/Demo1_22</span><br>   #<span class="hljs-number">6</span> = Class              #<span class="hljs-number">20</span>            <span class="hljs-comment">// java/lang/Object</span><br>   #<span class="hljs-number">7</span> = Utf8               &lt;init&gt;<br>   #<span class="hljs-number">8</span> = Utf8               ()V<br>   #<span class="hljs-number">9</span> = Utf8               Code<br>  #<span class="hljs-number">10</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">11</span> = Utf8               main<br>  #<span class="hljs-number">12</span> = Utf8               ([Ljava/lang/String;)V<br>  #<span class="hljs-number">13</span> = Utf8               SourceFile<br>  #<span class="hljs-number">14</span> = Utf8               Demo1_22.java<br>  #<span class="hljs-number">15</span> = NameAndType        #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">16</span> = Utf8               a<br>  #<span class="hljs-number">17</span> = Utf8               b<br>  #<span class="hljs-number">18</span> = Utf8               ab<br>  #<span class="hljs-number">19</span> = Utf8               com/sunk/jvm/t1/Demo1_22<br>  #<span class="hljs-number">20</span> = Utf8               java/lang/Object<br>&#123;<br>  <span class="hljs-keyword">public</span> com.sunk.jvm.t1.Demo1_22();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br>         <span class="hljs-number">2</span>: astore_1<br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br>         <span class="hljs-number">5</span>: astore_2<br>         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>         <span class="hljs-number">8</span>: astore_3<br>         <span class="hljs-number">9</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">10</span>: <span class="hljs-number">3</span><br>        line <span class="hljs-number">11</span>: <span class="hljs-number">6</span><br>        line <span class="hljs-number">12</span>: <span class="hljs-number">9</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">10</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>            <span class="hljs-number">3</span>       <span class="hljs-number">7</span>     <span class="hljs-number">1</span>    s1   Ljava/lang/String;<br>            <span class="hljs-number">6</span>       <span class="hljs-number">4</span>     <span class="hljs-number">2</span>    s2   Ljava/lang/String;<br>            <span class="hljs-number">9</span>       <span class="hljs-number">1</span>     <span class="hljs-number">3</span>    s3   Ljava/lang/String;<br><br>&#125;<br>SourceFile: <span class="hljs-string">&quot;Demo1_22.java&quot;</span><br><br></code></pre></td></tr></table></figure><ul><li> 常量池中的信息，都会被加载到运行时常量池中，这时 a b ab 都是常量池中的符号，还没有变为 java字符串对象</li><li> <code>ldc</code> #2 会把 a符号变为 “a”字符串对象</li><li> 变为 “a”字符串对象后，会到 <code>StringTable</code>中去找有没有取值相同的key（”a”）；如果没有则放入串池。</li><li> 执行完<code>String s1 = &quot;a&quot;;</code>，串池就有 “a”字符串对象  </li><li> 用到才会创建，用不到不会提前创建</li><li> StringTable[“a”,”b”,”ab”] hashtable 结构，不能扩容</li><li> 每个字符串对象，在串池中都是唯一的。</li></ul><h4 id="1-5-5-2-字符串变量拼接"><a href="#1-5-5-2-字符串变量拼接" class="headerlink" title="1.5.5.2 字符串变量拼接"></a>1.5.5.2 字符串变量拼接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_22</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>        String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>        String s4 = s1 + s2;<span class="hljs-comment">//new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString() </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>String s4 = s1 + s2;//new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString() new String(&quot;ab&quot;) </code></p><p>图解：</p><p><img src="http://image.cryptomartin.top/img/image-20211224112919717.png" alt="image-20211224112919717"></p><p><code>StringBuilder</code>的<code>toString</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Create a copy, don&#x27;t share the array</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(value, <span class="hljs-number">0</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据拼接好的值，又创建了新的字符串对象！相当于创建”ab”的字符串对象，存入s4</li></ul><p><strong>问：s3==s4？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>    String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>    String s4 = s1 + s2;<br><br>    System.out.println(s3 == s4 );<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>答案为false。虽然s3的“ab”和s4的“ab”值一样，但s3的”ab”是在串池中的，s4的new String(“ab”)是在堆里面的。</li></ul><h4 id="1-5-5-3-编译期优化"><a href="#1-5-5-3-编译期优化" class="headerlink" title="1.5.5.3 编译期优化"></a>1.5.5.3 编译期优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>    String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>    String s4 = s1 + s2;<br>    String s5 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后：</p><p><img src="http://image.cryptomartin.top/img/image-20211224162436968.png" alt="image-20211224162436968"></p><p>直接找拼接好的 “ab”。串池中已经有了“ab”字符串对象，不会再创建新的“ab”字符串对象了</p><p>问：s3==s5？true</p><p><img src="http://image.cryptomartin.top/img/image-20211224162735236.png" alt="image-20211224162735236"></p><p><strong>原理</strong></p><p><code>String s5 = &quot;a&quot; + &quot;b&quot;;</code>javac在编译期间的优化，结果在编译期间确定为<code>&quot;ab&quot;</code>，已经确定的结果。</p><p><code>String s4 = s1 + s2;</code>,<code>s1</code>,<code>s2</code>是变量，在运行时，引用的值可能被修改，结果是不能确定的；所以在运行期间，用<code>StringBuilder</code>来动态拼接。</p><h4 id="1-5-5-4-intern-放入串池"><a href="#1-5-5-4-intern-放入串池" class="headerlink" title="1.5.5.4 intern,放入串池"></a>1.5.5.4 intern,放入串池</h4><blockquote><p><code>intern()</code>将这个字符串对象尝试放入串池，如果有，则不会放入串池，如果没有则放入串池；无论有没有，都会把串池中的对象返回。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo23</span> </span>&#123;<br>    <span class="hljs-comment">//StringTable:[&quot;a&quot;,&quot;b&quot;]，无&quot;ab&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">// StringBuilder 动态拼接 new String(&quot;ab&quot;)</span><br><br>        <span class="hljs-comment">//堆有 new String(&quot;a&quot;)对象  new String(&quot;b&quot;)对象  new String(&quot;ab&quot;)对象</span><br>        <span class="hljs-comment">//问：我们可以把动态创建的 new String(&quot;ab&quot;)对象里的&quot;ab&quot; 放入串池吗？</span><br>        <span class="hljs-comment">//答：可以，用intern</span><br>        System.out.println(<span class="hljs-string">&quot;s是否等于&#x27;ab&#x27;：&quot;</span>+(s==<span class="hljs-string">&quot;ab&quot;</span>));<br>        String s2 = s.intern();<span class="hljs-comment">//将这个字符串对象尝试放入串池，如果有，则不会放入串池。</span><br>        System.out.println(<span class="hljs-string">&quot;使用s.intern()后，s2是否等于&#x27;ab&#x27;:&quot;</span> + (s2 == <span class="hljs-string">&quot;ab&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">s是否等于&#x27;ab&#x27;：false<br>使用s.intern()后，s2是否等于&#x27;ab&#x27;:true<br></code></pre></td></tr></table></figure><p>如果在s2之前打印s==”ab”,那么使用intern之后，s==”ab”都为false; 所以屏蔽<code>//System.out.println(&quot;s是否等于&#39;ab&#39;：&quot; + (s == &quot;ab&quot;));</code>,这时候，s==”ab”为true，s使用了串池的值”ab”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo23</span> </span>&#123;<br>    <span class="hljs-comment">//StringTable:[&quot;a&quot;,&quot;b&quot;]，无&quot;ab&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">// StringBuilder 动态拼接 new String(&quot;ab&quot;)</span><br><br>        <span class="hljs-comment">//堆有 new String(&quot;a&quot;)对象  new String(&quot;b&quot;)对象  new String(&quot;ab&quot;)对象</span><br>        <span class="hljs-comment">//问：我们可以把动态创建的 new String(&quot;ab&quot;)对象里的&quot;ab&quot; 放入串池吗？</span><br>        <span class="hljs-comment">//答：可以，用intern</span><br>        <span class="hljs-comment">//System.out.println(&quot;s是否等于&#x27;ab&#x27;：&quot; + (s == &quot;ab&quot;));</span><br>        String s2 = s.intern();<span class="hljs-comment">//将这个字符串对象尝试放入串池，如果有，则不会放入串池，会把串池中的对象返回。</span><br>        System.out.println(<span class="hljs-string">&quot;使用s.intern()后，s2是否等于&#x27;ab&#x27;:&quot;</span> + (s2 == <span class="hljs-string">&quot;ab&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;s是否等于&#x27;ab&#x27;：&quot;</span> + (s == <span class="hljs-string">&quot;ab&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">使用s.intern()后，s2是否等于&#x27;ab&#x27;:true<br>s是否等于&#x27;ab&#x27;：true<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo23</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String x = <span class="hljs-string">&quot;ab&quot;</span>;<span class="hljs-comment">//&quot;ab&quot;在串池中</span><br>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">//&quot;ab&quot;在堆里</span><br>        <br>        <span class="hljs-comment">//将这个字符串对象尝试放入串池，如果有，则不会放入串池，如果没有则放入串池；无论有没有，都会把串池中的对象返回。</span><br>        String s2 = s.intern();<span class="hljs-comment">//s2是串池中的&quot;ab&quot;；s是堆里创建出的&quot;ab&quot;</span><br>        System.out.println(<span class="hljs-string">&quot;s2 == x:&quot;</span>+(s2 == x));<br>        System.out.println(<span class="hljs-string">&quot;s == x:&quot;</span>+(s == x));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">s2 == x:true<br>s == x:false<br></code></pre></td></tr></table></figure><h4 id="1-5-5-5-回答最初的问题"><a href="#1-5-5-5-回答最初的问题" class="headerlink" title="1.5.5.5 回答最初的问题"></a>1.5.5.5 回答最初的问题</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> s1 = <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-keyword">String</span> s2 = <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-keyword">String</span> s3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-keyword">String</span> s4 = s1 + s2;<br><span class="hljs-keyword">String</span> s5 = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-keyword">String</span> s6 = s4.<span class="hljs-built_in">intern</span>();<br><br><span class="hljs-comment">// 问</span><br>System.out.<span class="hljs-built_in">println</span>(s3 == s4);<br>System.out.<span class="hljs-built_in">println</span>(s3 == s5);<br>System.out.<span class="hljs-built_in">println</span>(s3 == s6);<br><br><span class="hljs-keyword">String</span> x2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;d&quot;</span>);<br><span class="hljs-keyword">String</span> x1 = <span class="hljs-string">&quot;cd&quot;</span>;<br>x2.<span class="hljs-built_in">intern</span>();<br><br><span class="hljs-comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢 </span><br>System.out.<span class="hljs-built_in">println</span>(x1 == x2);<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">false<br>true<br>true<br>false<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> x2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;d&quot;</span>);<br>x2.<span class="hljs-built_in">intern</span>();<br><span class="hljs-keyword">String</span> x1 = <span class="hljs-string">&quot;cd&quot;</span>;<br><span class="hljs-comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢 </span><br>System.out.<span class="hljs-built_in">println</span>(x1 == x2);<br></code></pre></td></tr></table></figure><p><code>输出</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">true<br></code></pre></td></tr></table></figure><ul><li><code>String x2 = new String(&quot;c&quot;) + new String(&quot;d&quot;);</code>堆中创建字符串对象”cd”</li><li><code>x2.intern();</code>，串池中没有<code>&quot;cd&quot;</code>，则将”cd”加入串池中；</li><li><code>String x1 = &quot;cd&quot;;</code>串池中已经有”cd”，引用串池中已有的”cd”对象。</li><li>JDK1.6:false.</li></ul><h3 id="1-5-6-StringTable的位置"><a href="#1-5-6-StringTable的位置" class="headerlink" title="1.5.6 StringTable的位置"></a>1.5.6 StringTable的位置</h3><p>见 1.5.2 组成</p><h3 id="1-5-7-StringTable-垃圾回收"><a href="#1-5-7-StringTable-垃圾回收" class="headerlink" title="1.5.7 StringTable 垃圾回收"></a>1.5.7 StringTable 垃圾回收</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示 StringTable 垃圾回收</span><br><span class="hljs-comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_7</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123; <span class="hljs-comment">// j=100, j=10000</span><br>                String.valueOf(j).intern();<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;504K(2560K)] 2048K-&gt;781K(9728K), 0.0011268 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br><br></code></pre></td></tr></table></figure><h3 id="1-5-8-StringTable-性能调优"><a href="#1-5-8-StringTable-性能调优" class="headerlink" title="1.5.8 StringTable 性能调优"></a>1.5.8 StringTable 性能调优</h3><ul><li>调整 -XX:StringTableSize=桶个数</li><li>考虑将字符串对象是否入池</li></ul><h2 id="1-6-直接内存-操作系统内存"><a href="#1-6-直接内存-操作系统内存" class="headerlink" title="1.6 直接内存-操作系统内存"></a>1.6 直接内存-操作系统内存</h2><h3 id="1-6-1-定义"><a href="#1-6-1-定义" class="headerlink" title="1.6.1 定义"></a>1.6.1 定义</h3><p>Direct Memory</p><ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211224223955718.png" alt="image-20211224223955718"></p><p>有两块缓冲区:系统缓冲区，java缓冲区</p><p>所以比较慢</p><hr><p><img src="http://image.cryptomartin.top/img/image-20211224224225735.png" alt="image-20211224224225735"></p><ul><li><p>系统出的direct memory ，java可以直接访问。系统和java都可以用直接内存。</p></li><li><p>少了一层缓冲区。</p></li></ul><h3 id="1-6-2-分配和回收原理"><a href="#1-6-2-分配和回收原理" class="headerlink" title="1.6.2 分配和回收原理"></a>1.6.2 分配和回收原理</h3><ul><li>使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法</li><li>ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存</li></ul><p><code>-XX:+DisableExplicatGC</code> ：禁用显式GC，<code>System.gc()</code>；对于直接内存的回收有影响！长时间得不到释放。</p><p>如何解决？直接用Unsafe对象，调用 freeMemory 方法手动释放直接内存。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>JVM学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JVM引言</title>
    <link href="/2021/12/22/%E5%AD%A6%E4%B9%A0JVM%E5%BC%95%E8%A8%80/"/>
    <url>/2021/12/22/%E5%AD%A6%E4%B9%A0JVM%E5%BC%95%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="学习JVM引言"><a href="#学习JVM引言" class="headerlink" title="学习JVM引言"></a>学习JVM引言</h1><h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>Java Virtual Machine - java 程序的运行环境（java 二进制字节码的运行环境）</p><h3 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收功能</li><li>数组下标越界检查</li><li>多态</li></ul><h3 id="比较："><a href="#比较：" class="headerlink" title="比较："></a>比较：</h3><p>jvm jre jdk</p><p><img src="http://image.cryptomartin.top/img/image-20211222072056047.png" alt="image-20211222072056047"></p><p>JVM：屏蔽Java代码与底层的操作系统的差异</p><p>JRE：JVM基础上加上基础类库，就是JRE。基础类库是什么？jang.lang.*,集合类，线程类，日期类，IO类</p><p>JDK：JRE基础上加上编译工具，就是JDK。编译工具有javac，javap等</p><h2 id="学习JVM有什么用？"><a href="#学习JVM有什么用？" class="headerlink" title="学习JVM有什么用？"></a>学习JVM有什么用？</h2><ul><li>面试</li><li>理解底层原理的实现原理</li><li>中高级程序员的必备技能</li></ul><h2 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h2><p><img src="http://image.cryptomartin.top/img/image-20211222073020952.png" alt="image-20211222073020952"></p><blockquote><p><a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines">维基百科参考</a></p></blockquote><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="http://image.cryptomartin.top/img/image-20211222073238466.png" alt="image-20211222073238466"></p><blockquote><p><a href="https://www.javainterviewpoint.com/java-virtual-machine-architecture-in-java/">参考资料</a></p></blockquote><p>一个类从Java源代码编译为二进制字节码以后，经过类加载器，才能被加载到JVM中运行；</p><p>类都是放在<code>Method Area方法区</code>中，类将来创建的实例对象放在<code>Heap堆</code>中，而<code>Heap堆</code>里面的对象调用<code>方法</code>时,又会用到<code>JVM Stacks虚拟机栈</code>，<code>PC Register程序计数器</code>,<code>Native Method Stacks 本地方法栈</code>;</p><p><code>方法</code> 执行时，每行代码是由<code>执行引擎</code>中的<code>Interpret解释器</code>逐行进行一个执行；<code>方法里的热点代码</code>,即被频繁调用的代码，会由一个<code>JIT Compiler即时编译器</code>对<code>方法里的热点代码</code>做一个编译，也可以理解为做优化后的执行。</p><p><code>GC垃圾回收</code>会对<code>Heap堆</code>里面不再被引用的对象进行一个垃圾回收。</p><p>还有一些Java代码不方便实现的功能，必须调用底层操作系统的功能，跟操作系统交互需要一个<code>本地方法接口</code></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>JVM学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章 Java线程</title>
    <link href="/2021/12/20/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/12/20/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-Java线程"><a href="#第三章-Java线程" class="headerlink" title="第三章 Java线程"></a>第三章 Java线程</h1><p><strong>本章内容</strong>：</p><ul><li>创建和运行线程</li><li>查看线程</li><li>线程 API</li><li>线程状态</li></ul><h2 id="3-1-创建和运行线程"><a href="#3-1-创建和运行线程" class="headerlink" title="3.1 创建和运行线程"></a>3.1 创建和运行线程</h2><blockquote><p>每个程序一启动，都有一个主程序线程，称之为主线程。默认已经有一个主线程在运行了。</p></blockquote><h3 id="方法一，直接使用Thread"><a href="#方法一，直接使用Thread" class="headerlink" title="方法一，直接使用Thread"></a>方法一，直接使用Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程对象</span><br>Thread t = <span class="hljs-keyword">new</span> Thread() &#123;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 要执行的任务</span><br> &#125;<br>&#125;;<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//构造方法的参数是给线程指定名字，推荐</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//setName给线程指定名称</span><br>        <span class="hljs-comment">//t.setName(&quot;t1&quot;);</span><br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>        log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:42:09 [main] c.Test1 - running<br>16:42:09 [t1] c.Test1 - running<br></code></pre></td></tr></table></figure><h3 id="方法二，使用Runnable配合Thread"><a href="#方法二，使用Runnable配合Thread" class="headerlink" title="方法二，使用Runnable配合Thread"></a>方法二，使用Runnable配合Thread</h3><p>把【线程】和【任务】（要执行的代码）分开</p><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务（线程要执行的代码）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 要执行的任务</span><br>&#125;<br>&#125;;<br><span class="hljs-comment">// 创建线程对象，把runnable对象放入线程中</span><br>Thread t = <span class="hljs-keyword">new</span> Thread( runnable );<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建可运行的任务对象</span><br>        Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//创建线程对象,这边IDE提示：不建议显示创建线程，请使用线程池。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;t2&quot;</span>);<br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:54:14 [t2] c.Test2 - running<br></code></pre></td></tr></table></figure><p>Java8后可以使用lambda简化代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建可运行的任务对象</span><br>        Runnable runnable = () -&gt; log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>        <span class="hljs-comment">//创建线程对象,这边IDE提示：不建议显示创建线程，请使用线程池。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;t2&quot;</span>);<br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="***** 原理之 Thread 与 Runnable 的关系"></a>***** <strong>原理之</strong> <strong>Thread</strong> <strong>与</strong> <strong>Runnable</strong> 的关系</h3><blockquote><p>Test1是用了哪个run方法？</p></blockquote><p><img src="http://image.cryptomartin.top/img/image-20211218171132351.png" alt="image-20211218171132351"></p><blockquote><p>方法1是重写了父类的run方法，以子类的run方法为准。</p></blockquote><hr><blockquote><p>Test2是用了哪个run方法？</p></blockquote><p><img src="http://image.cryptomartin.top/img/image-20211218170423475.png" alt="image-20211218170423475"></p><p><img src="http://image.cryptomartin.top/img/image-20211218170523199.png" alt="image-20211218170523199"></p><p><img src="http://image.cryptomartin.top/img/image-20211218170708785.png" alt="image-20211218170708785"></p><p><img src="http://image.cryptomartin.top/img/image-20211218170923368.png" alt="image-20211218170923368"></p><blockquote><p>如果有Runnable对象，Thread优先采用Runnable对象的run方法。</p></blockquote><p><strong>小结</strong></p><ul><li>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合</li><li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><blockquote><p>更推荐Runnable的方法！！！优先组合关系，不是继承关系。</p></blockquote><h3 id="方法三，FutureTask配置Thread"><a href="#方法三，FutureTask配置Thread" class="headerlink" title="方法三，FutureTask配置Thread"></a>方法三，FutureTask配置Thread</h3><p><img src="http://image.cryptomartin.top/img/image-20211218172101398.png" alt="image-20211218172101398"></p><p><img src="http://image.cryptomartin.top/img/image-20211218172237257.png" alt="image-20211218172237257"></p><p><img src="http://image.cryptomartin.top/img/image-20211218172311299.png" alt="image-20211218172311299"></p><p>Future中的get方法可以返回任务执行的结果；Runnable是void没有返回结果。</p><hr><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        FutureTask&lt;Integer&gt; task =<span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>                <span class="hljs-comment">//让当前线程睡眠1s</span><br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//FutureTask实现了Runnable接口，所以可以放入Thread。</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(task,<span class="hljs-string">&quot;t1&quot;</span>);<br>        t.start();<br><br>        <span class="hljs-comment">//主线程阻塞，等待结果FutureTask结果返回；FutureTask实现了任务及异步结果的集合功能</span><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,task.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">17:32:24 [t1] c.Test2 - running...<br>17:32:26 [main] c.Test2 - 100<br></code></pre></td></tr></table></figure><h2 id="3-2-观察多个线程同时运行"><a href="#3-2-观察多个线程同时运行" class="headerlink" title="3.2 观察多个线程同时运行"></a>3.2 观察多个线程同时运行</h2><p>主要是理解</p><ul><li>交替执行</li><li>谁先谁后，不由我们控制</li></ul><h2 id="3-3-查看进程线程的方法"><a href="#3-3-查看进程线程的方法" class="headerlink" title="3.3 查看进程线程的方法"></a>3.3 查看进程线程的方法</h2><p><strong>windows</strong></p><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li><code>tasklist</code> 查看进程</li><li><code>taskkill</code> 杀死进程</li></ul><p><strong>linux</strong></p><ul><li><code>ps -fe</code> 查看所有进程</li><li><code>ps -fT -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>top</code> 按大写 H 切换是否显示线程</li><li><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li></ul><h2 id="3-4-原理之线程运行"><a href="#3-4-原理之线程运行" class="headerlink" title="3.4 * 原理之线程运行"></a>3.4 * 原理之线程运行</h2><h3 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h3><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</p><ul><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法，互不干扰</li></ul><p>线程运行原理-栈帧图解：</p><p><img src="http://image.cryptomartin.top/img/image-20211218224550413.png" alt="image-20211218224550413"></p><h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul><h2 id="3-5-常见方法"><a href="#3-5-常见方法" class="headerlink" title="3.5 常见方法"></a>3.5 常见方法</h2><p><img src="http://image.cryptomartin.top/img/image-20211218230238918.png" alt="image-20211218230238918"></p><p><img src="http://image.cryptomartin.top/img/image-20211218230301086.png" alt="image-20211218230301086"></p><p><img src="http://image.cryptomartin.top/img/image-20211218230316126.png" alt="image-20211218230316126"></p><h3 id="3-5-1-Start与run"><a href="#3-5-1-Start与run" class="headerlink" title="3.5.1 Start与run"></a>3.5.1 Start与run</h3><p><strong>调用run方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>            log.debug(<span class="hljs-string">&quot;t1 Thread is running...&quot;</span>);<br>        &#125;<br>    &#125;;<br>    t1.run();<br>    log.debug(<span class="hljs-string">&quot;main Thread is running...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">23:16:48 [main] c.Test4 - t1 Thread is running...<br>23:16:48 [main] c.Test4 - main Thread is running...<br></code></pre></td></tr></table></figure><p>程序仍在 main 线程运行。</p><p><strong>调用start方法</strong></p><p>将上述代码中的<code>t1.run()</code>改为<code>t1.start()</code>，输出</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">23:21:01 [t1] c.Test4 - t1 Thread is running...<br>23:21:01 [main] c.Test4 - main Thread is running...<br></code></pre></td></tr></table></figure><p>程序在 t1 线程运行。</p><p><strong>小结</strong></p><ul><li>直接调用 <code>run()</code> 是在主线程中执行了 <code>run()</code>，没有启动新的线程</li><li>使用 <code>start()</code> 是启动新的线程，通过新的线程间接执行 <code>run()</code>方法 中的代码</li></ul><h3 id="3-5-2-sleep与yield"><a href="#3-5-2-sleep与yield" class="headerlink" title="3.5.2 sleep与yield"></a>3.5.2 sleep与yield</h3><p><strong>sleep</strong></p><ol><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 <code>InterruptedException</code>异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】</li><li>睡眠结束后的线程未必会立刻得到执行(需要分配到cpu时间片)</li><li>建议用 TimeUnit 的 <code>sleep()</code> 代替 Thread 的 <code>sleep()</code>来获得更好的可读性</li></ol><p>ps:<code>sleep()</code>方法写在哪个线程中，那个线程就进入睡眠。</p><p><strong>yield(让出的意思)</strong></p><ol><li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)</li></ol><p>阻塞状态与就绪状态线程区别：</p><ul><li>就绪状态，还是有机会被任务调度器调度的，任务调度器会分时间片给就绪状态的线程。</li><li>阻塞状态，任务调度器不会分时间片给阻塞状态的线程，只有睡眠时间到了，醒过来后，任务调度器才会时间片分给醒来的线程。</li></ul><p> <strong>小结</strong></p><p>yield让出cpu使用权，但是cpu可能会再分配时间片给该线程；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片</p><h3 id="3-5-3-线程优先级"><a href="#3-5-3-线程优先级" class="headerlink" title="3.5.3 线程优先级"></a>3.5.3 线程优先级</h3><ul><li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li><li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><h3 id="3-3-4-join"><a href="#3-3-4-join" class="headerlink" title="3.3.4 join"></a>3.3.4 join</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test10&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        test1();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>            r = <span class="hljs-number">10</span>;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">//t1.join();</span><br>        log.debug(<span class="hljs-string">&quot;结果为:&#123;&#125;&quot;</span>, r);<br>        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">11:58:20 [main] c.Test10 - 开始<br>11:58:20 [t1] c.Test10 - 开始<br>11:58:20 [main] c.Test10 - 结果为:0<br>11:58:20 [main] c.Test10 - 结束<br>11:58:21 [t1] c.Test10 - 结束<br></code></pre></td></tr></table></figure><p>分析</p><ul><li>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 <code>r=10</code></li><li>而主线程一开始就要打印 r 的结果，所以只能打印出 <code>r=0</code></li></ul><p>解决方法</p><ul><li>用 <code>sleep()</code> 行不行？为什么？</li><li>用 <code>join()</code>，加在 <code>t1.start()</code> 之后即可</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211219120326852.png" alt="image-20211219120326852"></p><p>以<code>调用方角度</code>来讲，如果:</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><p><img src="http://image.cryptomartin.top/img/image-20211219120527024.png" alt="image-20211219120527024"></p><blockquote><p><code>t1 thread</code>调用<code>join()</code>方法之后，<code>main thread</code>跟<code>t1 thread</code>是同步的，<code>main thread</code>必须等待<code>t1 thread</code>执行完成后，才能继续执行。</p></blockquote><p><strong>join()方法等待多个线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r1 = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r2 = <span class="hljs-number">0</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       test2();<br>   &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>           sleep(<span class="hljs-number">1</span>);<br>           r1 = <span class="hljs-number">10</span>;<br>       &#125;);<br>       Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>           sleep(<span class="hljs-number">2</span>);<br>           r2 = <span class="hljs-number">20</span>;<br>       &#125;);<br>       t1.start();<br>       t2.start();<br>       <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>       log.debug(<span class="hljs-string">&quot;join begin&quot;</span>);<br>       t2.join();<br>       log.debug(<span class="hljs-string">&quot;t2 join end&quot;</span>);<br>       t1.join();<br>       log.debug(<span class="hljs-string">&quot;t1 join end&quot;</span>);<br>       <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>       log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);<br>   &#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">14:16:35 [main] c.TestJoin - join begin<br>14:16:37 [main] c.TestJoin - t2 join end<br>14:16:37 [main] c.TestJoin - t1 join end<br>14:16:37 [main] c.TestJoin - r1: 10 r2: 20 cost: 2003<br></code></pre></td></tr></table></figure><p>分析如下</p><ul><li>第一个 join：等待 t1 时, t2 并没有停止, 而在运行</li><li>第二个 join：1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s</li></ul><p>如果颠倒两个 join 呢？</p><p>答：结果还是一样</p><p><strong>join(long n):最多等待n毫秒</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r1 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r2 = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    test3();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        sleep(<span class="hljs-number">2</span>);<br>        r1 = <span class="hljs-number">10</span>;<br>    &#125;);<br><br>    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>    t1.start();<br><br>    <span class="hljs-comment">// 线程执行结束会导致 join 结束</span><br>    log.debug(<span class="hljs-string">&quot;join begin&quot;</span>);<br>    t1.join(<span class="hljs-number">1500</span>);<br>    <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>    log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">14:24:33 [main] c.TestJoin - join begin<br>14:24:35 [main] c.TestJoin - r1: 0 r2: 0 cost: 1508<br></code></pre></td></tr></table></figure><blockquote><p>没等够时间，就按时间到期结束；如果等待时间还没万，但线程结束了，就不再等待了。</p></blockquote><h3 id="3-5-5-interrupt-方法详解"><a href="#3-5-5-interrupt-方法详解" class="headerlink" title="3.5.5 interrupt 方法详解"></a>3.5.5 interrupt 方法详解</h3><h4 id="interrupt可以打断-sleep，wait，join-的线程"><a href="#interrupt可以打断-sleep，wait，join-的线程" class="headerlink" title="interrupt可以打断 sleep，wait，join 的线程"></a>interrupt可以打断 sleep，wait，join 的线程</h4><p>阻塞</p><p>打断 sleep 的线程, 会清空打断状态，以 sleep 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>sleep(<span class="hljs-number">1</span>);<br>&#125;<br>, <span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>sleep(<span class="hljs-number">0.5</span>);<br>t1.interrupt();<br>log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">java.lang.InterruptedException: sleep interrupted<br> at java.lang.Thread.sleep(Native Method)<br> at java.lang.Thread.sleep(Thread.java:340)<br> at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)<br> at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)<br> at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)<br> at java.lang.Thread.run(Thread.java:745)<br>21:18:10.374 [main] c.TestInterrupt - 打断状态: false<br></code></pre></td></tr></table></figure><p><strong>打断正常运行的线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>Thread current = Thread.currentThread();<br>Boolean interrupted = current.isInterrupted();<br><span class="hljs-keyword">if</span>(interrupted) &#123;<br>log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br>sleep(<span class="hljs-number">0.5</span>);<br>t2.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">20:57:37.964 [t2] c.TestInterrupt - 打断状态: true<br></code></pre></td></tr></table></figure><p><strong>小结</strong></p><ul><li><p>如果位于特殊的阻塞状态，比如调用wait()、wait(long)或者join()或者sleep()等方法，中断标志位将会被清除，并且收到一个InterruptedException</p></li><li><p>打断正常运行的线程，调用<code>interrupt()</code>方法只是给线程打上一个中断标志位，并不会马上打断该线程。我们可以根据中断标志位来做一些操作。</p></li></ul><h4 id="【模式】模式之两阶段终止"><a href="#【模式】模式之两阶段终止" class="headerlink" title="【模式】模式之两阶段终止"></a>【模式】模式之两阶段终止</h4><p><code>Two Phase Termination</code><br>是在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。</p><p><strong>1.错误思路</strong></p><ul><li>使用线程对象的 stop() 方法停止线程<ul><li>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，<br>其它线程将永远无法获取锁</li></ul></li><li>使用 System.exit(int) 方法停止线程<ul><li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li></ul></li></ul><p><strong>2.两阶段终止模式</strong></p><p><img src="http://image.cryptomartin.top/img/image-20211220155929525.png" alt="image-20211220155929525"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        TwoPhaseTermination tpt = <span class="hljs-keyword">new</span> TwoPhaseTermination();<br>        tpt.start();<br><br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        tpt.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//监控类</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTermination</span> </span>&#123;<br>    <span class="hljs-comment">//创建监控线程，作为成员变量</span><br>    <span class="hljs-keyword">private</span> Thread monitor;<br><br>    <span class="hljs-comment">//开启监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">//不断执行</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-comment">//查看当前线程的中断标记</span><br>                Thread currentThread = Thread.currentThread();<br>                <span class="hljs-comment">//判断当前线程是否被打断</span><br>                <span class="hljs-keyword">if</span> (currentThread.isInterrupted()) &#123;<br>                    <span class="hljs-comment">//如果被打断</span><br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//如果当前线程没有被打断,睡眠1秒</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    <span class="hljs-comment">//没被打断，且没有异常；记录日志</span><br>                    log.debug(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                    <span class="hljs-comment">//在睡眠中被打断，会清除打断标记，打断标记此时为false;需要将中断标记置为真;重新设置打断标记为true</span><br>                    currentThread.interrupt();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//开启线程</span><br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">//停止监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:25:32 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>16:25:33 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>16:25:34 [Thread-0] c.TwoPhaseTermination - 执行监控记录<br>java.lang.InterruptedException: sleep interrupted<br><span class="hljs-code">at java.lang.Thread.sleep(Native Method)</span><br><span class="hljs-code">at com.sunk.test.TwoPhaseTermination.lambda$start$0(Test3.java:41)</span><br><span class="hljs-code">at java.lang.Thread.run(Thread.java:748)</span><br><span class="hljs-code">16:25:35 [Thread-0] c.TwoPhaseTermination - 料理后事</span><br></code></pre></td></tr></table></figure><p><strong>isInterrupted()与interrupted()区别</strong></p><ul><li><code>isInterrupted()</code>：判断当前线程是否被打断；不会清除打断标记</li><li><code>interrupted()</code>:判断当前线程是否被打断；会清除打断标记，如果打断标记为<code>true</code>，调用此方法后，变为<code>false</code></li></ul><h4 id="interrupted打断park线程"><a href="#interrupted打断park线程" class="headerlink" title="interrupted打断park线程"></a>interrupted打断park线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test14&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test14</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        test3();<br>    &#125;<br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>            log.debug(<span class="hljs-string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());<br>            <span class="hljs-comment">//打断标记为true，park就失效了。</span><br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        sleep(<span class="hljs-number">0.5</span>);<br>        t1.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">16:38:28 [t1] c.Test14 - park...<br>16:38:28 [t1] c.Test14 - unpark...<br>16:38:28 [t1] c.Test14 - 打断状态：true<br>16:38:28 [t1] c.Test14 - unpark...<br></code></pre></td></tr></table></figure><blockquote><p>如果打断标记已经是 true, 则 park 会失效</p></blockquote><h2 id="3-6-不推荐的方法"><a href="#3-6-不推荐的方法" class="headerlink" title="3.6 不推荐的方法"></a>3.6 不推荐的方法</h2><p><img src="http://image.cryptomartin.top/img/image-20211220164128203.png" alt="image-20211220164128203"></p><h2 id="3-7-守护线程"><a href="#3-7-守护线程" class="headerlink" title="3.7 守护线程"></a>3.7 守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做<code>守护线程</code>，<strong>只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test15&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test15</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;t1线程结束&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-comment">//设置t1线程为守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束</span><br>        t1.setDaemon(<span class="hljs-keyword">true</span>);<br>        t1.start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;主线程结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">19:06:21 [main] c.Test15 - 主线程结束<br></code></pre></td></tr></table></figure><blockquote><p>注意:</p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等<br>待它们处理完当前请求</li></ul></blockquote><h2 id="3-8-线程的五种状态"><a href="#3-8-线程的五种状态" class="headerlink" title="3.8 线程的五种状态"></a>3.8 线程的五种状态</h2><p>五种状态的划分主要是从操作系统的层面进行划分的</p><p><img src="http://image.cryptomartin.top/img/20200307093417-638644.png" alt="1583507073055"></p><ol><li><p>初始状态，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联</p></li><li><p>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</p></li><li><p>运行状态，指线程获取了CPU时间片，正在运行</p><ul><li>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</li></ul></li><li><p>阻塞状态</p><ul><li><p>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】</p></li><li><p>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p></li><li><p>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</p></li></ul></li><li><p>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ol><h2 id="3-9-线程的六种状态"><a href="#3-9-线程的六种状态" class="headerlink" title="3.9 线程的六种状态"></a>3.9 线程的六种状态</h2><p>这是从 Java API 层面来描述的，我们主要研究的就是这种。状态转换详情图：<a href="https://www.jianshu.com/p/ec94ed32895f">地址</a><br>根据 Thread.State 枚举，分为六种状态 </p><p><img src="http://image.cryptomartin.top/img/20200307093352-614933.png" alt="1583507709834"></p><ul><li>NEW 跟五种状态里的初始状态是一个意思</li><li> RUNNABLE 是当调用了 <code>start()</code> 方法之后的状态，注意，Java API 层面的 <code>RUNNABLE</code> 状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【io阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li><li><code>BLOCKED</code> ， <code>WAITING</code> ， <code>TIMED_WAITING</code> 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节<br> 详述</li></ul><h2 id="3-10-习题-统筹规划"><a href="#3-10-习题-统筹规划" class="headerlink" title="3.10 习题-统筹规划"></a>3.10 习题-统筹规划</h2><p><img src="http://image.cryptomartin.top/img/image-20211220194112708.png" alt="image-20211220194112708"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test16&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test16</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;洗水壶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            log.debug(<span class="hljs-string">&quot;烧开水，花费15分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">15</span>);<br>        &#125;, <span class="hljs-string">&quot;老王&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;洗茶壶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            log.debug(<span class="hljs-string">&quot;洗茶杯，花费2分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>            log.debug(<span class="hljs-string">&quot;拿茶叶，花费1分钟&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//小王模拟泡茶，等待开水烧开。</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                t1.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;可以泡茶了！&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;小王&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>输出</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">19:38:37 [老王] c.Test16 - 洗水壶，花费1分钟<br>19:38:37 [小王] c.Test16 - 洗茶壶，花费1分钟<br>19:38:38 [老王] c.Test16 - 烧开水，花费15分钟<br>19:38:38 [小王] c.Test16 - 洗茶杯，花费2分钟<br>19:38:40 [小王] c.Test16 - 拿茶叶，花费1分钟<br>19:38:53 [小王] c.Test16 - 可以泡茶了！<br></code></pre></td></tr></table></figure><p>ps:秒代替分钟。</p><p>执行到<code>19:38:38 [老王] c.Test16 - 烧开水，花费15分钟</code>，会等待15秒，然后会执行<code>19:38:53 [小王] c.Test16 - 可以泡茶了！</code></p><h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><p>本章的重点在于掌握</p><ul><li><p>线程创建</p></li><li><p>线程重要 api，如 start，run，sleep，join，interrupt 等</p></li><li><p>线程状态</p></li><li><p>应用方面</p><ul><li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li><li>提高效率：并行计算，缩短运算时间</li><li>同步等待：join</li><li>统筹规划：合理使用线程，得到最优效果</li></ul></li><li><p>原理方面</p><ul><li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li><li>Thread 两种创建方式 的源码</li></ul></li><li><p>模式方面</p><ul><li>两阶段终止模式</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 七牛云外链图片无法显示</title>
    <link href="/2021/12/16/Hexo%20%E5%A4%96%E9%93%BE%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/"/>
    <url>/2021/12/16/Hexo%20%E5%A4%96%E9%93%BE%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-七牛云外链图片无法显示"><a href="#Hexo-七牛云外链图片无法显示" class="headerlink" title="Hexo 七牛云外链图片无法显示"></a>Hexo 七牛云外链图片无法显示</h1><h2 id="1-起因"><a href="#1-起因" class="headerlink" title="1. 起因"></a>1. 起因</h2><p>打算好好做Hexo博客，结果太折腾了。七牛云的图床，在Hexo博客结果不能显示，网上的方法用了很多都失败了，自己查了一下错误。</p><p>大概原因是：<code>github请求的协议是用HTTPS，而七牛云是HTTP，协议不兼容导致</code></p><p><img src="http://image.cryptomartin.top/img/image-20211216185546365.png" alt="image-20211216185546365"></p><h2 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h2><p><code>在七牛云打开强制HTTPS</code></p><p><img src="http://image.cryptomartin.top/img/image-20211216190015768.png" alt="image-20211216190015768"></p><p><img src="http://image.cryptomartin.top/img/image-20211216190203695.png" alt="image-20211216190203695"></p><h2 id="3-结果"><a href="#3-结果" class="headerlink" title="3. 结果"></a>3. 结果</h2><p>等待5分钟左右，就有七牛云发邮件，提示成功开启<code>强制HTTPS</code></p><p><img src="http://image.cryptomartin.top/img/image-20211216190318735.png" alt="image-20211216190318735"></p><p>Hexo成功显示七牛云外链图片：</p><p><img src="http://image.cryptomartin.top/img/image-20211216190503464.png" alt="image-20211216190503464"></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 进程与线程</title>
    <link href="/2021/12/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/12/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 进程与线程</h1><p><strong>本章内容</strong></p><ul><li>进程和线程的概念</li><li>并行和并发的概念</li><li>线程基本应用</li></ul><h2 id="2-1-进程与线程概念"><a href="#2-1-进程与线程概念" class="headerlink" title="2.1 进程与线程概念"></a>2.1 进程与线程概念</h2><h3 id="2-1-1-进程"><a href="#2-1-1-进程" class="headerlink" title="2.1.1 进程"></a>2.1.1 进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在<br>指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器<br>等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><p>简单说就是：</p><blockquote><p>进程：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程.</p></blockquote><h3 id="2-1-2-线程"><a href="#2-1-2-线程" class="headerlink" title="2.1.2 线程"></a>2.1.2 线程</h3><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作<br>为线程的容器</li></ul><blockquote><p>线程是进程当中的一条执行流程.</p></blockquote><blockquote><p>线程 = 进程 - 共享资源</p></blockquote><h3 id="2-1-3-进程与线程对比"><a href="#2-1-3-进程与线程对比" class="headerlink" title="2.1.3 进程与线程对比"></a>2.1.3 进程与线程对比</h3><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li><li>进程间通信较为复杂<ul><li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h2 id="2-2-并发与并行的概念"><a href="#2-2-并发与并行的概念" class="headerlink" title="2.2 并发与并行的概念"></a>2.2 并发与并行的概念</h2><p>单核 cpu 下，线程实际还是 <code>串行执行</code> 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows<br>下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感<br>觉是 同时运行的 。总结为一句话就是： <code>微观串行，宏观并行</code> ，<br>一般会将这种 线程轮流使用 CPU 的做法称为并发， concurrent</p><p><img src="http://image.cryptomartin.top/img/image-20211216152119986.png" alt="image-20211216152119986"></p><p>多核 cpu下，每个 核（core） 都可以调度运行线程，这时候线程可以是并行的。</p><p><img src="http://image.cryptomartin.top/img/image-20211216152309525.png" alt="image-20211216152309525"></p><blockquote><p>并发：一段时间内运行多个进程</p><p>并行：一个时间点运行多个进程，一般要求有多个CPU</p></blockquote><h2 id="2-3-应用"><a href="#2-3-应用" class="headerlink" title="2.3 应用"></a>2.3 应用</h2><h3 id="2-3-1-应用之异步调用（案例1）"><a href="#2-3-1-应用之异步调用（案例1）" class="headerlink" title="2.3.1 应用之异步调用（案例1）"></a>2.3.1 应用之异步调用（案例1）</h3><p>以调用方角度来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><h4 id="1-设计"><a href="#1-设计" class="headerlink" title="1) 设计"></a>1) 设计</h4><p>多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，这么cpu只能等5秒，啥都不能做。</p><h4 id="2-结论"><a href="#2-结论" class="headerlink" title="2) 结论"></a>2) 结论</h4><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li><li>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><h3 id="2-3-2-应用之提高效率（案例1）"><a href="#2-3-2-应用之提高效率（案例1）" class="headerlink" title="2.3.2 应用之提高效率（案例1）"></a>2.3.2 应用之提高效率（案例1）</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">计算 <span class="hljs-number">1</span> 花费 <span class="hljs-number">10</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">计算 2</span> 花费 <span class="hljs-number">11</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">计算 3</span> 花费 <span class="hljs-number">9</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">汇总需要 1</span> ms<br></code></pre></td></tr></table></figure><ul><li>如果是串行执行，那么总共花费的时间是 <code>10 + 11 + 9 + 1 = 31ms</code></li><li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个<br>线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 <code>11ms</code> 最后加上汇总时间只会花费 <code>12ms</code></li></ul><p><strong>注意</strong></p><blockquote><p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程学习笔记学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 并发编程概览</title>
    <link href="/2021/12/16/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E8%A7%88/"/>
    <url>/2021/12/16/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-并发编程概览"><a href="#第一章-并发编程概览" class="headerlink" title="第一章 并发编程概览"></a>第一章 并发编程概览</h1><h2 id="1-1-这门课主要学什么"><a href="#1-1-这门课主要学什么" class="headerlink" title="1.1 这门课主要学什么"></a>1.1 这门课主要学什么</h2><p>这门课中的【并发】一词涵盖了在 Java 平台上的</p><ul><li>进程</li><li>线程</li><li>并发</li><li>并行</li></ul><p>以及 Java 并发工具、并发问题以及解决方案，同时我也会讲解一些其它领域的并发</p><h2 id="1-2-为什么要学并发编程"><a href="#1-2-为什么要学并发编程" class="headerlink" title="1.2 为什么要学并发编程"></a>1.2 为什么要学并发编程</h2><ul><li><p>我工作中用不到并发啊？</p><p>  做CRUD，用不到并发编程；但希望往更高层面发展，必须学并发编程！平时用的Tomcat服务器、Dubbo、消息中间件等，这些底层肯定涉及多线程！</p></li></ul><h2 id="1-3-学习路线"><a href="#1-3-学习路线" class="headerlink" title="1.3 学习路线"></a>1.3 学习路线</h2><p>本门课程以并发、并行为主线，穿插讲解</p><p><strong>应用</strong> - 结合实际<br><strong>原理</strong> - 了然于胸<br><strong>模式</strong> - 正确姿势</p><ul><li><input disabled="" type="checkbox"> 思维导图</li></ul><h2 id="1-4-预备知识"><a href="#1-4-预备知识" class="headerlink" title="1.4 预备知识"></a>1.4 预备知识</h2><ul><li>有一定的框架经验</li><li>线程安全问题，需要你接触过 Java Web 开发、Jdbc 开发、Web 服务器、分布式框架时才会遇到</li><li>基于 JDK 8，最好对函数式编程、lambda 有一定了解</li><li>采用了 slf4j 打印日志，这是好的实践</li><li>采用了 lombok 简化 java bean 编写</li><li>给每个线程好名字，这也是一项好的实践</li></ul><p>pom.xml 依赖如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>logback.xml配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://ch.qos.logback/xml/ns/logback&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://ch.qos.logback/xml/ns/logback logback.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%date&#123;HH:mm:ss&#125; [%t] %logger - %m%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;c&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
      <category>Java并发编程学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
